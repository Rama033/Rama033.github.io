---
layout: post
disqus_disabled: false
title: "[자바 ORM 표준 JPA 프로그래밍] 6장. 다양한 연관관계 매핑"
date: 2022-02-05T17:45:00+09:00
author: Jo
categories: jpa-study
tags: jpa relation relationship-mapping 1:1 N:N 1:N N:1
cover: "/assets/instacode.png"
---
# 6장. 다양한 relationship mapping

# 6.1 N:1
- 항상 N:1 의 반대 방향은 1:N, 1:N의 반대 방향은 N:1
- 1:N, N:1 관계에서 foreign key는 항상 N 쪽에 위치
  - 따라서 owner는 N 쪽

<br/>
<br/>

## 6.1.1 N:1 단방향 [N:1]

<img src="/assets/img/jpa_study/ch.6/pic-6-1.png">

```java
// member entity
@Entity
public class Member {
  @Id
  @GeneratedValue
  private Long id;

  private String username;

  @ManyToOne
  @JoinColumn(name = "team_id")
  private Team team;

  ...
}

...

// team entity
@Entity
public class Team {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  ...
}
```

- member 에서는 Member.team 으로 team entity 참조 가능, team 에서는 member 참조 불가능 -> N:1 단방향 relationship
  - Member entity 에서 Member.team 으로 member table team_id foreign key 관리

<br/>
<br/>

## 6.1.2 N:1 양방향 [N:1 & 1:N]

<img src="/assets/img/jpa_study/ch.6/pic-6-2.png">

```java
// member entity
@Entity
public class Member {
  @Id
  @GeneratedValue
  private Long id;

  private String username;

  @ManyToOne
  @JoinColumn(name = "team_id")
  private Team team;

  public void setTeam(Team team) {
    this.team = team;

    // 무한루프 방지
    if (!team.getMembers().contains(this)) {
      team.getMembers().add(this);
    }
  }

  ...
}

...

// team entity
@Entity
public class Team {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  @OneToMany(mappedBy = "team")
  private List<Member> members = new ArrayList<Member>();

  public void setMembers(Member member) {
    this.members.add(member);
    
    // 무한루프 방지
    if (member.getTeam() != this) {
      member.setTeam(this);
    }
  }

  ...
}
```

- 위 N:1 양방향 예제에서 실선이 relation owner side(Member.team), 점선이 non-owning side(Team.members)
- **양방향에선 foreign key 있는 쪽이 owner**
  - N:1, 1:N 에선 항상 N 쪽에 foreign key 위치
  - 여기선 N 쪽인 member 의 Member.team 이 owner
  - non-owning side인 Team.members 는 조회를 위한 JPQL 또는 객체 그래프 탐색 시 사용
- **양방향 relationship 에선 항상 서로 참조해야 함**
  - 어느 한 쪽만 참조시 양방향 성립 X
  - 이를 위해 relationship 편의 method 작성하는게 좋음
    - 위 예제에서의 setTeam, setMembers

<br/>
<br/>
<br/>

# 6.2 1:N
- 1:N 에서는 entity를 하나 이상 참조할 수 있음
  - 자바 컬렉션인 Collection, List, Set, Map 중 하나 사용

<br/>
<br/>

## 6.2.1 1:N 단방향 [1:N]
- 1:N 단방향 관계는 JPA 2.0부터 지원
- 1:N, N:1 관계에서는 항상 N 쪽 table에 fk 있기 때문에 1:N 단방향 관계는 좀 특수
- 아래 예제처럼 N쪽 table에 있는 fk를 반대쪽 entity 에서 관리하게 됨
- 1:N 단방향 mapping 시에는 @JoinColumn 명시해야 함
  - 명시하지 않을 경우 JPA는 JoinTable 전략을 기본으로 사용하여 mapping
    - JoinTable 전략: 연결 테이블을 중간에 두고 relationship을 관리하는 방식

<img src="/assets/img/jpa_study/ch.6/pic-6-3.png">

```java
@Entity
public clas Team {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  @OneToMany
  @JoinColumn(name = "team_id") // member table 에 있는 fk 사용
  private List<Member> members = new ARrayList<Member>();
  
  ...
}

...

@Entity
public class Member {
  @Id
  @GeneratedValue
  private Long id;

  private String username;

  ...
}
```

- **1:N 단방향 mapping 단점**
  - 다른 테이블에 있는 fk를 관리하게 되기 때문에 쿼리 추가로 필요해짐
    - INSERT 한번으로 끝날 게 relationship 처리를 위해 UPDATE 쿼리를 추가로 실행해야 함

```java
Member member1 = new Member("Alice");
Member member2 = new Member("Bob");

Team team1 = new Team("Alpha");
team1.getMembers().add(member1);
team1.getMembers().add(member2);

em.persist(member1);  // INSERT member1
em.persist(member2);  // INSERT member2
em.persist(team1);    // INSERT team1, UPDATE member1.fk, UPDATE member2.fk

...
```

<br/>
<br/>

## 6.2.2 1:N 양방향 [1:N & N:1]
- 원칙적으로 1:N 양방향은 존재 X
- 대신 N:1 양방향 mapping 사용
- 굳이 1:N 양방향 mapping 구현하려면 1:N 단방향과 함께 반대편에서 같은 fk 쓰는 N:1 단방향 mapping 을 read only로 추가하면 됨

<img src="/assets/img/jpa_study/ch.6/pic-6-4.png">

```java
@Entity
public class Team {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  // 1:N 단방향
  @OneToMany
  @JoinColumn(name = "team_id")
  private List<Member> members = new ARrayList<Member>();

  ...
}

...

@Entity
public class Member {
  @Id
  @GeneratedValue
  private Long id;

  private String username;

  // N:1 단방향 read only
  @ManyToOne
  @JoinColumn(name = "team_id", insertable = false, updatable = false)
  private Team team;
  ...
}
```

- 위 예제처럼 1:N, N:1 모두 동일한 fk 사용하게 하고 N:1 쪽에서 ```insertable = false, updatable = false``` 로 설정해서 read only 만들면 됨

<br/>
<br/>
<br/>

# 6.3 1:1
- 1:1 관계에서는 양쪽이 서로 하나의 관계만 가짐
- 어느 쪽이던 fk 가질 수 있음
  - 주 테이블이랑 대상 테이블 중 어느쪽이 fk 가질 지 선택해야 함
- **대상 테이블에 fk**
  

<br/>
<br/>

## 6.3.1 주 테이블에 fk
- 주 객체가 대상 객체 참조하듯 주 테이블에 fk 두고 대상 테이블을 참조
- fk를 객체 참조와 유사하게 사용할 수 있음
  - 주로 객체지향 개발자들이 선호
  - JPA에서도 좀 더 편리하게 mapping 
- 주 테이블만 확인해도 대상 테이블과 연관관계 파악 가능

<br/>

### 단방향
<img src="/assets/img/jpa_study/ch.6/pic-6-5.png">

```java
@Entity
public class Member {
  @Id
  @GeneratedValue
  private long id;

  private String username;

  @OneToOne
  @JoinColumn(name = "locker_id")
  private Locker locker;

  ...
}

...

@Entity
public class Locker {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  ...
}
```

- 1:1 이므로 @OneToOne 으로 객체 mapping
- DB member table locker_id foregin key에 유니크 제약조건 UNI 추가

<br/>

### 양방향
<img src="/assets/img/jpa_study/ch.6/pic-6-6.png">

```java
@Entity
public class Member {
  @Id
  @GeneratedValue
  private long id;

  private String username;

  @OneToOne
  @JoinColumn(name = "locker_id")
  private Locker locker;

  ...
}

...

@Entity
public class Locker {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  @OneToOne(mappedBy = "locker")
  private Member member;
  ...
}
```

- 양방향이므로 relationship owner 필요
  - member table이 fk 가지고 있으므로 Member entitiy의 Member.locker 가 owner
  - 반대쪽인 Locker entity 의 Locker.member 는 mappedBy 설정

<br/>
<br/>

## 6.3.2 대상 테이블에 fk
- 테이블 관계를 1:1에서 1:N으로 변경할 때에도 테이블 구조 유지 가능
- DB 개발자들이 주로 선호

<br/>

### 단방향
<img src="/assets/img/jpa_study/ch.6/pic-6-7.png">

- JPA 에서는 위와 같이 대상 테이블에 fk 있는 1:1 단방향 관계 지원 안함

<br/>

### 양방향
<img src="/assets/img/jpa_study/ch.6/pic-6-8.png">

```java
@Entity
public class Member {
  @Id
  @GeneratedValue
  private long id;

  private String username;

  @OneToOne
  @JoinColumn(name = "member")
  private Locker locker;

  ...
}

...

@Entity
public class Locker {
  @Id
  @GeneratedValue
  private Long id;

  private String name;

  @OneToOne(mappedBy = "member_id")
  private Member member;
  ...
}
```

- 1:1 mapping 시 대상 테이블에 fk 두려면 이렇게 양방향으로 해야 함

> **!!주의사항!!** <br/>
> proxy 사용할 때 fk 직접 관리하지 않는 1:1 관계는 lazy loading 설정이 안먹힘 <br/>
> 예를 들어 위 예제에서 Locker.member 는 lazy loading 가능, Member.locker 는 불가능 <br/>
> proxy 대신 bytecode instrumentation 사용하면 해결할 수 있음

*작성중...(2022-02-07 / ~ 6.4)*