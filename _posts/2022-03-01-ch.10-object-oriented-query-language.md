---
layout: post
disqus_disabled: false
title: "[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어"
date: 2022-03-01T21:03:00+09:00
author: Jo
categories: jpa-study
tags: jpa object-oriented query language jpql criteria querydsl nativesql
cover: "/assets/instacode.png"
---

# 10장. 객체지향 쿼리 언어

<br/>
<br/>
<br/>

# 10.1 객체지향 쿼리 소개
- JPQL 특징
  - DB 테이블이 아닌 엔티티 객체를 대상으로 검색하는 객체지향 쿼리
  - SQL을 추상화하여 특정 DB SQL에 의존 X
- JPA에서 공식 지원하는 기능
  - JPQL(Java Persistence Query Langauge)
  - Creiteria 쿼리: JPA 작성 도와주는 API, 빌더 클래스 모음
  - 네이티브 SQL: JPA에서 JPQL 대신 직접 SQL 사용 도움
- JPA에서 공식 지원하는 건 아니지만 유용한 기능
  - QueryDSL: Criteria 쿼리처럼 JPQL 작성 편의 도와주는 빌더 클래스 모음. 비표준 오픈소스 프레임워크임
  - JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용: 필요하면 직접 JDBC 사용 가능k

<br/>
<br/>
<br/>

# JPQL
- 객체지향 쿼리 언어
- 테이블 대상이 아닌 엔티티 객체를 대상으로 쿼리
- SQL을 추상화하여 특정 DB SQL에 의존하지 않음
- SQL로 변환되어 실행
- JPQL API는 대부분 메소드 체인 방식으로 설계되어있어서 연속으로 작성 가능

**샘플 모델 UML**
<img src="/assets/img/jpa_study/ch.10/pic-10-1.png">

**샘플 모델 ERD**
<img src="/assets/img/jpa_study/ch.10/pic-10-2.png">


<br/>
<br/>

## 10.2.1 기본 문법과 쿼리 API
- JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문 사용 가능
- 저장시에는 ```EntityManager::persist()``` 사용하면 되서 INSERT 는 없음

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```
select_문 ::=
  select_절
  from_절
  [where_절]
  [groupby_절]
  [having_절]
  [orderby_절]

update_문 ::= update_절 [where_절]
delete_문 ::= delete_절 [where_절]
```

</div>
</details>

<br/>

#### SELECT 문
```SELECT m FROM Member AS m WHERE m.username = 'Hello'```

- 대소문자 구분
  - 엔티티, 속성은 대소문자를 구분 O
  - SELECT, FROM, AS 같은 JPQL 키워드는 대소문자 구분 X
- 엔티티 이름
  - 디폴드 값은 클래스 명
  - ```@Entity(name="")``` 으로 지정 가능
- 별칭은 필수
  - ```Member As m``` 처럼 JPQL에선 alias 지정 필수임
  - AS는 생략 가능

<br/>

### TypeQuery, Query
- 작성한 JPQL 실행 위해 쿼리 객체 필요
  - 반환할 타입 명확하게 지정 가능하면 TypeQuery 객체 사용
  - 반환 타입 명확하게 지정 불가능하면 Query 객체 사용

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
public void useTypeQuery(EntityManager em) {
  TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

  List<Member> resultList = query.getResultList();

  for (Member member: resultList) {
    System.out.println("member = " + member);
  }
}

...

public void useQuery(EntityManager em) {
  Query query = em.createQuery("SELECT m.username, m.age FROM Member m");

  List resultList = query.getResultList();

  for (Object o: resulstList) {
    Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[] 반환
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
  }
}
```

</div>
</details>

<br/>

### 결과 조회
- 아래 메소드들 호출시 실제 쿼리 실행하여 DB 조회함
  - ```query.getResultList()```: 결과를 반환. 없으면 빈 컬렉션 반환
  - ```query.getSingleResult()```: 결과가 정확히 하나일 때 사용
    - 결과 없으면 ```javax.persistence.NoResultException``` 발생
    - 결과가 1개보다 많으면 ```javax.persistence.NoUniqueResultException``` 발생

<br/>
<br/>

## 10.2.2 파라미터 바인딩
- JPQL은 이름 기준 파라미터 바인딩 지원
  - JDBC는 위치 기준 파라미터 바인딩만 지원
- 파라미터 바인딩을 사용하지 않고 직접 문자 더해 만들어 넣으면 SQL 인젝션 공격 당할 수 있음
- 또한 파라미터 바인딩 방식 쓰면 파리미터 값 달라도 같은 쿼리로 인식해 JPQL을 SQL로 파싱한 결과를 재사용 할 수 있음
  
<br/>

### 이름 기준 파라미터
- 파라미터를 이름으로 구분하는 방법
- 이름 기준 파라미터는 앞에 : 붙임

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
Strign usernameParam = "User1";

List<Member> resulstList = em
  .createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class) // :username이 이름 기준 파라미터 정의
  .setParameter("username", usernameParam);                                         // setParameter로 파라미터 바인딩
  .getResultList();
```

</div>
</details>

<br/>

### 위치 기준 파라미터
- 파라미터를 위치 기준으로 구분하는 방법
- ? 다음에 위치 값 주면 됨
- 위치 값은 1부터 시작

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
List<Member> members = em
  .createQuery("SELECT m FROM Member m WHERE m.username = ?1", Member.class)
  .setParameter(1, usernameParam)
  .getResultList();
```

</div>
</details>

<br/>
<br/>

## 10.2.3 프로젝션
- SELECT 절에 조회할 대상을 지정하는 것 = **projection**
- ```SELECT {프로젝션 대상} FROM```으로 대상 선택
- 대상으로는 엔티티, 임베디드 타입, 스칼라 타입이 있음

<br/>

### 엔티티 프로젝션
```java
SELECT m FROM Member m         // Member
SELECT m.team FROM Member m    // Team
```

- 위 예시처럼 엔티티를 프로젝션 대상으로 사용해서 원하는 객체를 바로 조회
- 이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리됨

<br/>

### 임베디드 타입 프로젝션
```java
List<Address> address = em
  .createQuery("SELECT o.address FROM Order o", Address.class)
  .getResultList();
```

- 임베디드 타입은 조회의 시작점이 될 수 없음
- 위 예시처럼 엔티티를 통해서 조회해야 함
- 임베디드 타입은 값 타입이기 때문에 영속성 컨텍스트에서 관리 X

<br/>

### 스칼라 타입 프로젝션
```java
List<String> usernames = em
  .createQuery("SELECT username FROM Member m", String.class)
  .getResultList();
```

- 숫자, 문자, 날짜와 같은 기본 데이터 타입들
- AVG, SUM 같은 통계 쿼리도 주로 스칼라 타입으로 조회함

<br/>

### 여러 값 조회

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
List<Object[]> resultList = em
  .createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
  .getResultList();

for (Object[] row: resultList) {
  Member member = (Member) row[0];    // 엔티티
  Product product = (Product) row[1]; // 엔티티
  int orderAmount = (Integer) row[2]; // 스칼라
}
```

</div>
</details>

- 프로젝션에 여러 값 선택시 TypeQuery 대신 Query 써야 함
- 엔티티 타입도 여러 값 함께 조회 가능하며, 이 엔티티들도 영속성 컨텍스트로 관리 됨

<br/>

### NEW 명령어

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
TypeQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```

</div>
</details>

- SELECT 다음에 NEW 명령어 사용하여 반환받을 클래스 지정하고 해당 클래스의 생성자에 JPQL 조회 결과 넘겨줄 수 있음
- 이렇게 하면 TypeQuery 사용해서 바로 변환된 객체로 리턴받을 수 있음
- NEW 명령어 사용시 주의점
  - 패키지 명을 포함한 전체 클래스 명 써야함
  - 순서와 타입이 일치하는 생성자 있어야 함

<br/>
<br/>

## 10.2.4 페이징 API
- JPA는 페이징을 아래 두 API로 추상화
  - ```setFirstResult(int startPosition)```: 조회 시작 위치(0부터 시작)
  - ```setMaxResults(int maxResult)```: 조회할 데이터 수
- DB dialect에 따라 사용중인 DB에 알맞은 SQL로 자동 변환되어 쿼리 수행됨
  - 최적화 더 하려면 Native SQL 사용해야 함

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
List<Member> resultList = em
  .createQuery("SELECT m FROM Member m ORDER BY m.username DESC", Member.class)
  .setFirstResult(10);    // 조회 시작 위치는 11번째(0번째가 시작이므로)
  .setMaxResults(20);     // 조회할 데이터 수는 20개
  .getResultList();       // 결과적으로 11~30번 데이터가 조회됨
```

</div>
</details>

<br/>
<br/>

## 10.2.5 집합과 정렬
- 집합은 집합함수와 함께 통계 정보 구할 때 사용

<br/>

### 집합 함수

| 함수 | 설명 | 리턴 타입 |
|:----|:----|:--------|
| COUNT | 결과 갯수를 구함 | Long |
| MAX, MIN | 최대, 최솟값 구함. 문자, 숫자, 날짜 등에 사용 | |
| AVG | 평균값 구함. 숫자 타입만 사용 가능 | Double | 
| SUM | 합을 구함. 숫자 타입만 사용 가능 | 정수합: Long<br/>소수합: Double<br/>BigInteger합: BigInteger<br/>BigDecimal합: BigDecimal |

- 집합 함수 사용시 참고사항
  - null 값은 무시하므로 통계에 잡히지 않음(DISTINCT 정의되어 있어도 무시됨)
  - 값 없는데 SUM, AVG, MAX, MIN 사용시 null 값이 됨
    - COUNT는 0 됨
  - DISTINCT 를 집합 함수 안에 사용해서 중복값 제거 후 집합 구할 수 있음
    - ex) ```SELECT COUNT(DISTINCT m.age) FROM Member m```
  - DISTINCT 를 COUNT 에서 사용할 때 임베디드 타입은 지원 X

<br>

### GROUP BY, HAVING
```
groupby_절 ::= GROUP BY {단일값 경로 | alias}+
having_절 ::= HAVING 조건식
```

- GROUP BY는 통계 데이터 구할 때 특정 그룹끼리 묶어줌

```java
// 팀 이름을 기준으로 그룹화하여 통계 데이터 구하기
SELECT t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
FROM Member m
  LEFT JOIN m.team t
GROUP BY t.name
```

- HAVING 은 GROUP BY 와 함께 사용하며 그룹화된 통계 데이터를 기준으로 필터링 함

```java
// 그룹별 통계 데이터 중 평균 나이가 10살 이상인 그룹 조회
// 팀 이름을 기준으로 그룹화하여 통계 데이터 구하기
SELECT t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
FROM Member m
  LEFT JOIN m.team t
GROUP BY t.name
HAVING AGV(m.age) >= 10
```

<br/>

### 정렬(ORDER BY)
```orderby_절 ::= ORDER BY {상태필드 경로 | 결과 변수 [ASC | DESC]}+```

- 결과 정렬시 사용
- ASC: 오름차순 (default)
- DESC: 내림차순
- 상태필드는 ```t.name``` 과 같이 객체의 상태를 나타내는 필드를 말함
- 결과 변수는 SELECT 절에 나타나는 값을 말함
  - 아래 예제의 경우 t.name, cnt 가 결과 변수이고, 그중 cnt를 기준으로 정렬시킴
  
```java
SELECT t.name, COUNT(m.age) as cnt
FROM Member m
  LEFT JOIN m.team t
GROUP BY t.name
ORDER BY cnt
```

<br/>
<br/>

## 10.2.6 JPQL 조인
- SQL 조인과 기능 동일, 문법만 약간 상이함

<br/>

### 내부 조인

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
String teamName = "teamA";

List<Member> members = em
  .createQuery("SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName", Member.class)
  .setParameter("teamName", teamName)
  .getResultList();
```

</div>
</details>

- INNSER JOIN 사용, INNER 는 생략 가능
- JPQL 은 연관 필드를 사용하여 조인함
  - 연관 필드는 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드
  - 위 예제의 경우 ```m.team``` 이 연관필드임

<br/>

### 외부 조인

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
SELECT m
FROM Member m
  LEFT OUTER JOIN m.team t
```

</div>
</details>

- OUTER 는 생략 가능
- 마찬가지로 연관필드 가지고 조인

<br/>

### 컬렉션 조인
- 1:1, N:N  관계처럼 컬렉션 사용하는 곳에 조인하는 것
- [Member -> Team] 조인은 N:1 조인이면서 단일 값 연관 필드(m.team) 사용
- [Team -> Member]는 1:N 조인이면서 컬렉션 값 연관 필드(m.members) 사용 

```java
SELECT t, m 
FROM Team t 
  LEFT JOIN t.members m   // Team 과 Team 이 보유한 Member 목록을 컬렉션 값 연관 필드로 외부 조인한 것
```

<br/>

### 세타 조인
- WHERE 절을 사용해서 세타 조인 가능
- 내부 조인만 지원함
- 세타 조인을 사용해 전혀 관계없는 엔티티도 조인 가능

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
SELECT count(m)
FROM Member m,
  Team t
WHERE m.username = t.name   // WHERE 절에서 전혀 관계 없는 Member.username 과 Team.name 을 조인함
```

</div>
</details>

<br/>

### JOIN ON 절(JPA 2.1 이상 지원)
- JPA 2.1 부터 조인시 ON 절을 지원
- ON 절 사용하면 조인 대상 필터링 후 조인 가능
- 내부 조인의 ON절은 WHERE 절 사용하는 거랑 결과 같으므로 보통 외부 조인에서만 사용함

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
SELECT m, t
FROM Member m
  LEFT JOIN m.team t ON t.name = 'A'    // t.name = 'A' 로 조인 시점에 조인 대상을 필터링
```

</div>
</details>

<br/>
<br/>

## 10.2.7 페치 조인
- JPQL에서 성능 최적화를 위해 제공
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능
- JOIN FETCH 명령어로 사용 가능
- 페치 조인에서는 alias 못씀

```페치 조인 ::\ [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로```

<br/>

### 엔티티 페치 조인

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
List<Member> members = em
  .createQuery("SELECT m FROM Member m JOIN FETCH m.team")
  .getResultList();

for (Member member: members) {
  // 페치 조인으로 Member 조회시 Team 도 함께 조회되어 지연 로딩 X
  System.out.println("username = " + member.getUsername() + ", " + "teamname = " + member.getTeam().name());
}
```

</div>
</details>

- 위 예제의 경우 Member(m) 과 Team(m.team) 을 함께 조회함
- ```SELECT m``` 으로 Member 만 선택했지만 실제로 실행된 SQL에서는 ```SELECT m.*, t.*``` 로 member와 연관된 team 도 함께 조회함
- 따라서 지연 로딩 설정 해놨어도 Member 조회시 Team 도 같이 조회되어 지연 로딩 발생 안함

<br/>

### 컬렉션 페치 조인

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
List<Team> teams = em
  .createQuery("SELECT t FROM Team t JOIN FETCH t.members WHERE t.name = 'teamA'", Team.class)
  .getResultList();

for (Team team: teams) {
  System.out.println("teamname = " + team.getName() + ", team = " + team);

  for (Member member: team.getMembers()) {
    // 페치 조인으로 Team 조회시 Member 도 함께 조회되어 지연 로딩 X
    System.out.println("->username = " + member.getUsername() + ", member = " + member);
  }
}
```

</div>
</details>

- ```SELECT t``` 로 Team 만 선택했지만 실제로 실행되는건 ```SELECT t.*, m.*``` 로 team 과 연관된 member도 함께 조회함
- 만약 'teamA'에 속한 member가 여러명이라면 ```getResultList()```의 결과로 member 수만큼의 team이 반환됨
  - 반환되는 team은 모두 동일한(identity) 객체임

<br/>

### 페치 조인과 DISTINCT
- JPQL의 DITSINCT는 SQL에 DISTINCT 명령어 추가 및 에플리케이션에서 한번 더 중복 제거
- 앞서 컬렉션 페치 조인 같은 경우 그냥 조회하면 여러 member 속한 team은 그 수만큼 반환
  - DISTINCT 붙여서 조회해도 원래 sql이라면 각 row의 member 데이터가 달라서 중복 제거가 안됨
  - 하지만 JPQL에서의 DISTINCT는 에플리케이션에서 한번 더 중복 제거해주므로 중복된 team  entity 제거됨

<br/>

### 페치 조인과 일반 조인의 차이
- 일반 조인
  - JPQL은 결과 반환시 연관관계까지 고려 X, SELECT 절에 지정한 엔티티만 조회
  - 따라서 지연 로딩 설정시엔 프록시를, 즉시 로딩 설정시엔 연관된 엔티티 조회를 위해 쿼리를 한번 더 실행함
- 페치 조인
  - 연관된 엔티티도 함께 조회
  - 따라서 연관된 엔티티 위해 쿼리 한번더 실행하지 않고 한번에 해결

<br/>

### 페치 조인의 특징과 한계
- 특징
  - 페치 조인 사용시 쿼리 한번으로 연관된 엔티티 함께 조회할 수 있어 호출 회수 줄이고 성능 최적화 가능
  - 페치 조인은 글로벌 로딩 전략(엔티티에 직접 작용하는 로딩 전략, ex. ```@OneToMany(fetch = FetchType.LAZY)```)보다 우선함 
    - 따라서 글로벌 로딩 전략을 지연 로딩으로 해놔도 JPQL 에서 페치 조인 쓰면 페치 조인 적용해서 한번에 조회함
    - 최적화를 위해 글로벌 로딩 전략으로 즉시 로딩 설정시 일부는 효율적일 수 있지만 전체적으로는 안쓰는거 자주 로딩해서 악영향 올 수 있음
    - 따라서 글로벌 로딩 전략은 지연 로딩, 최적화 필요한 곳에 페치 조인 적용하는게 좋음
  - 객체 그래프 유지할 때 사용하면 유용ㅍ
  - 여러 테이블 조인해서 엔티티 본 모양이 아닌 다른 결과 내어야 하면 그냥 필요한 필드들만 각각 조회해서 DTO로 반환하는게 나을수도 있음
- 한계
  - 페치 조인 대상에는 alias 불가
    - 따라서 SELECT, WHERE, 서브쿼리에 페치 조인 대상 사용 불가
    - 하이버네이트등 일부 구현체는 alias 지원하나 잘못 쓰면 연관된 데이터 수 달라져 데이터 무결성 깨질 수 있으므로 조심해야함
      - 2차 캐시랑 같이 쓸 때 특히 조심
  - 둘 이상의 컬렉션 페치 불가
    - 구현체의 따라 가능하나 컬렉션 * 컬렉션의 카테시안 곱 만들어지므로 주의 필요
    - 하이버네이트는 예외 발생
  - 컬렉션 페치 조인시 페이징 API(setFirstResult, setMaxResults) 사용 불가
    - 컬렉션(1:N)이 아닌 단일 값 연관 필드(1:1, N:1) 들은 페치 조인 써도 페이징 API 못씀
    - 하이버네이트에서는 경고 로그 남기고 메모리에서 페이징 처리함 => 성능 이슈 및 메모리 초과 예외 발생 가능

<br/>
<br/>

## 10.2.8 경로 표현식 (Path Expression)

```java
SELECT m.username
FROM Member m
  join m.team t
  join m.orders o
WHERE t.name = 'teamA'
```

- .을 찍어 객체 그래프를 탐색하는 것
- 위 예제에서 ```m.username```, ```m.team```, ```m.orders```, ```t.name```이 모두 경로 표현식 사용 예

<br/>

### 경로 표현식의 용어 정리
- **상태 필드 state field:** 단순히 값 저장하기 위한 필드(필드 or 프로퍼티)
  - ```m.username```, ```t.name```
- **연관 필드 association field:** 연관관계 위한 필드, 임베디드 타입 포함(필드 or 프로퍼티)
  - **단일 값 연관 필드:** ```@ManyToOne```, ```@OneToOne```, 대상이 엔티티
    - ```m.team```
  - **컬렉션 값 연관 필드:** ```@OneToMany```, ```@ManyToMany```, 대상이 컬렉션
    - ```m.orders```
  - 
<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
@Entity
public class Member {
  @Id
  @GeneratedValue
  private Long id;

  @Column(name = "name")
  private String username;  // state field
  private Integer age;  // stae field

  @ManyToOne(...)
  private Team team;  // association field

  @OneToMany(...)
  private List<Order> orders; // association field
}
```

</div>
</details>

<br/>

### 경로 표현식과 특징
- 상태 필드 경로: 경로 탐색의 끝. 더이상 탐색 X
- 단일 값 연관 경로: 묵시적으로 내부 조인 일어남. 계속 탐색 O
- 컬렉션 값 연관 경로: 묵시적으로 내부 조인 일어남. 더이상 탐색 X 지만 FROM 절에서 조인 통해 alias 얻으면 alias 로 탐색 O

```
// 상태 필드 경로 탐색
// JPQL
SELECT m.username, m.age FROM Member m

// 실행 쿼리
SELECT m.name, m.age
FROM Member m

...

// 단일 값 연관 경로 탐색
// JPQL
SELECT o.member FROM Order o

// 실행 쿼리
SELECT m.*
FROM Orders o
  INNER JOIN Member m on o.member_id = m.id // 묵시적 조인(내부 조인). 외부 조인은 JPQL에 JOIN 키워드 명시적으로 사용해야 함

...

// 컬렉션 값 연관 경로 탐색
// JPQL
SELECT t.members from Team t // 성공
SELECT t.members.username FROM Team t // 실패
// t.members 처럼 컬렉션 까지는 경로 탐색 가능하지만, 
// t.members.username 처럼 컬렉션에서 경로 탐색 시작은 불가능
// 계속 하려면 아래처럼 조인을 사용해서 새로운 alias 획득해야 함
SELECT m.username FROM Team t JOIN t.members m

// 컬렉션에서는 크기 구할 수 있느 size 기능 사용 가능
// COUNT 함수 쓰는 쿼리로 알아서 변환됨
SELECT t.members.size FROM Team t
```

<br/>

### 경로 탐색을 사용한 묵시적 조인 시 주의사항
- 항상 내부 조인임
- 컬렉션은 경로 탐색의 끝
  - 컬렉션에서 경로 탐색 하려면 명시적 조인으로 alias 획득 필요
- 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 FROM 절에 영향 줌
- 묵시적 조인은 조인 발생 현환 파악 어려우므로 명시적 조인 쓰는게 좋음

<br/>
<br/>

## 10.2.9 서브 쿼리
- WHERE, HAVING 절에만 사용 가능, SELECT, FROM 절에선 못 씀
  - 하이버네이트 HQL은 SELECT 절 서브쿼리 까지는 허용

```java
// 나이가 평균보다 많은 회원 조회
SELECT m FROM Member m
WHERE m.age > (SELECT AVG(m2.age) FROM Member m2)

// 한 건이라도 주문한 고객 조회
SELECT m FROM Member m
WHERE (SELECT COUNT(o) FROM Order o WHERE m = o.member) > 0

// 한 건이라도 주문한 고객 조회 (컬렉션 크기 값 구할 수 있는 size 기능 활용, 실행 쿼리는 위에거랑 동일)
SELECT m FROM Member m
WEHRE m.orders.size > 0
```

<br/>

### 서브 쿼리 함수
- **EXISTS**
  - [NOT] EXISTS (subquery)
  - subquery에 결과 존재하면 참, NOT 붙으면 반대
- **ALL, ANY, SOME**
  - {ALL | ANY | SOME} (subquery)
  - 비교 연산자와 같이 사용
    - {= | > | >= | < | <= | <>}
  - ALL:  조건 모두 만족시 참
  - ANY, SOME: 조건 하나라도 만족하면 참
- **IN**
  - [NOT] IN (subquery)
  - subquery 결과 중 하나라도 같은 것 있으면 참

<br/>
<br/>

## 10.2.10 조건식

<br/>

### 타입 표현

| 종류 | 설명 | 예제 |
|:----|:----|:----|
| 문자 | 작은 따옴표 사이에 표현<br/>작은 따옴표 표현하려면 연속 두개 사용('') | 'HELLO'<br/>'She''s' |
| 숫자 | L(Long)<br/>D(Double)<br/>F(Float) | 10L<br/>10D<br/>10F |
| 날짜 | DATE {d 'yyyy-mm-dd'}<br/>TIME {t 'hh-mm-ss'}<br/>DATETIME {ts 'yyyy-mm-dd hh:mm:ss.f'} | {d '2021-03-03'}<br/>{t '11-11-11'}<br/>{ts '2021-03-03 11-11-11.111'}<br/>m.createDate = {d ' 2021-03-03'} |
| Boolean | True, False | |
| Enum | 패키지명 포함 전체 이름 사용 | jpabook.MemberType.Admin |
| 엔티티 타입 | 엔티티의 타입을 표현. 주로 상속과 관련하여 사용 | TYPE(m) = Member |

<br/>

### 연산자 우선 순위
1. 경로 탐색 연산: .
2. 수학 연산: 단항 연산자 +, 단항 연산자 -, *, /, +, -
3. 비교 연산: =, >, >=, <, <=, <>, [NOT] BETWEEN, [NOT] LIKE, [NOT] IN, IS [NOT] NULL, IS [NOT] EMPTY, [NOT] MEMBER [OF], [NOT] EXISTS
4. 논리 연산: NOT, AND, OR

<br/>

### 논리 연산과 비교식
- **논리 연산**
  - AND: 둘 다 만족하면 참
  - OR: 둘 중 하나 만족하면 참
  - NOT: 조건식의 결과 반대
- **비교식**
  - = | > | >= | < | <= | <>

<br/>

### Between, IN, Like, NULL 비교
- **Between 식**
  - X [NOT] BETWEEN A AND B
  - X는 A ~ B 사이 값이면 참(A, B 포함)
- **IN 식**
  - X [NOT] IN (예제)
  - X와 같은 값이 예제에 하나라도 있으면 참
  - 예제에는 서브쿼리 사용 가능
- **Like 식**
  - 문자 표현식 [NOT] LIKE 패턴값 [EXCAPE 이스케이프 문자]
  - 문자 표현식과 패턴값을 비교
  - %: 아무 값들이 입력되어도 됨(값이 없어도 됨)
  - _: 한 글자는 아무 값이 입력되어도 되지만 값은 있어야 함
- **NULL 비교식**
  - {단일값 경로 | 입력 파라미터 } IS [NOT] NULL
  - NULL 인지 비교

<br/>

### 컬렉션 식
- 컬렉션에만 사용하는 특별한 기능
- 컬렉션에선 컬렉션 식 외에 다른건 못 씀

- **빈 컬렉션 비교식**
  - { 컬렉션 값 연관 경로 } IS [NOT] EMPTY
  - 컬렉션에 값이 비었으면 참
- **컬렉션의 멤버 식**
  - {엔티티나 값} [NOT] MEMBER [OF] {컬렉션 값 연관 경로}
  - 엔티티나 값이 컬렉션에 포함되어 있으면 참

<br/>

### 스칼라 식
- 숫자, 문자, 날짜, case, 엔티티 타입(엔티티의 타입 정보) 같은 기본적인 타입(스칼라)에 사용하는 식

- **수학 식**
  - +, -: 단항 연산자
  - *, /, +, -: 사칙연산
- **문자 함수**

| 함수 | 설명 | 예제 |
|:----|:----|:----|
| CONCAT(문자1, 문자2, ...) | 문자 합침. (HQL에선 || 로도 사용 가능) | CONCAT('A', 'B') = AB |
| SUBSTRING(문자, 위치[, 길이]) | 위치부터 시작해 길이만큼 문자 구함. 길이 값 없으면 나머지 전체 길이 의미 | SUBSTRING('ABCDEF', 2, 3) = BCD |
| TRIM([[LEADING | TRAILING | BOTH] [트림 문자] FROM] 문자) | LEADING: 왼쪽만, TRAILING: 오른쪽만, BOTH:양쪽 다 트림 문자 제거(기본값은 BOTH, 트림 문자의 기본값은 공백(SPACE)) | TRIM(' ABC ') = 'ABC' |
| LOWER(문자) | 소문자화 | LOWER('ABC') = 'abc' |
| UPPER(문자) | 대문자화 | UPPER('abc') = 'ABC' |
| LENGTH(문자) | 문자 길이 | LENGTH('abc') = 3 |
| LOCATE(찾을 문자, 원본 문자[, 검색시작위치]) | 검색시작위치부터 문자를 검색. 1부터 시작, 못찾으면 0 반환 | LOCATE('DE', 'ABCDEFG') = 4 |

- **수학 함수**

| 함수 | 설명 | 예제 |
|:----|:----|:----|
| ABS(수학식) | 절대값 | ABS(-10) = 10 |
| SQRT(수학식) | 제곱근 | SQRT(4) = 2.0 |
| MOD(수학식, 나눌 수) | 나머지 | MOD(4, 3) = 1 |
| SIZE(컬렉션 값 연관 경로식) | 컬렉션 크기 | SIZE(t.members) | 
| INDEX(별칭) | LIST 타입 컬렉션의 위치값 구함(@OrderColumn 사용하는 LIST 타입일 떄만 사용 가능) | t.members m WHERE INDEX(m) > 3 |

- **날짜 함수**
  - CURRENT_DATE: 현재 날짜
  - CURRENT_TIME: 현재 시간
  - CURRENT_TIMESTAMP: 현재 날짜 시간

<br/>

### CASE 식
- 특정 조건에 따라 분기할 떄 사용
- **기본 CASE**

```
CASE
  {WHEN <조건식> THEN <스칼라식>}+
  ELSE <스칼라식>
END

// 예제
SELECT
  CASE 
    WHEN m.age <= 10 then '학생요금'
    WHEN m.age >= 60 then '경로요금'
    ELSE '일반요금'
  END
FROM Member m
```

- **심플 CASE**
  - 조건식 사용 X, 문법 단순
  - 자바의 switch case 문과 비슷

```
CASE <조건대상>
  {WHEN <스칼라식1> THEN <스칼라식2>}+
  ELSE <스칼라식>
END

// 예제
SELECT
  CASE t.name
    WHEN 'teamA' then '인센티브110%'
    WHEN 'teamB' then '인센티브120%'
    ELSE '인센티브105%'
  END
FROM Team t
```

- **COALESCE**
  - COALESCE(<스칼라식> {,<스칼라식>}+)
  - 스칼라식을 차례로 조회해서 null 아니면 반환
  - ```SELECT COALESCE(m.username, 'unknown member') FROM Member m // m.username null 이면  'unknown member' 반환```

- **NULLIF**
  - NULLIF(<스칼라식>, <스칼라식>)
  - 두 값 같으면 null, 다르면 첫 번째 값 반환
  - ```SELECT NULLIF(m.username, 'admin') FROM Member m // m.username이 'admin' 이면 null, 나머진 m.username 값 반환```

<br/>
<br/>

## 10.2.11 다형성 쿼리
- JPQL로 부모 엔티티 조회시 자식 엔티티도 함께 조회

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
@Entity
@Inheritance(startegy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {...}

@Entity
@DiscriminatorValue("B")
public class Book extends Item {
  ...
  private String author;
}

// Album, Movie ...
...
```

</div>
</details>

<br/>

### TYPE
- 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용

```
// Item 중 Book, Movie 조회
// JPQL
SELECT i 
ROM Item i
WHERE TYPE(i) 
  IN (Book, Movie)

// SQL
SELECT i 
FROM Item i
WHERE i.DTYPE 
  IN ('B', 'M')
```

<br/>

### TREAT
- JPA 2.1 에 추가된 기능
- 자바의 타입 캐스팅과 유사함
- 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
- 표준은 FROM, WHERE 절에서 사용 가능, 하이버네이트는 SELECT 절에서도 사용 가능

```
// 부모인 Item, 자식인 Book
// Item 을 Book 타입처럼 다뤄서 author 필드 접근
// JPQL
SELECT i 
FROM i 
WHERE TREAT(i AS Book).author = 'kim'

// SQL
SELECT i.*
FROM Item i
WHERE i.DTYPE = 'B'
  AND i.author = 'kim
```

<br/>
<br/>

## 10.2.12 사용자 정의 함수 호출
- JPA 2.1 부터 지원
- function_invocation::=FUNCTION(function_name {, function_arg}*)
- ```SELECT FUNCTION('group_concat', i.name) FROM Item i```
- 하이버네이트 구현체 사용시 아래 코드와 같이 방언 클래스(H2Dialect) 상속, 구현하고 사용할 DB 함수 미리 등록하고 ```hibernate.dialect``` 에 해당 방언 등록해야 함
  - 하이버네이트 구현체 사용시 위 예제를 다음과 같이 축약 가능 ```SELECT group_concat(i.name) FROM Item i```

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드 확인</b></summary>
<div markdown="1">

```java
// 방언 클래스 상속
public class MyH2Dialect extends H2Dialect {
  public MyH2Dialect() {
    registerFunction("group_concat", 
      new StandardSQLFunction("group_concat", StrandardBasicTypes.STRING));
  }
}
```

```xml
// 상속한 방언 클래스 등록
<property name="hibernate.dialect" value=hello.MyH2Dialect" />
```

</div>
</details>

<br/>
<br/>

### 10.2.13 기타 정리
- enum은 = 비교 연산만 지원
- 임베디드 타입은 비교 지원 X

<br/>

### EMPTY STRING
- JPA 표준은 ''를 길이 0인 Empty String 으로 정함
  - DB에 따라 NULL 로 사용하는 곳도 있으므로 확인 후 사용

<br/>

### NULL 정의
- 조건 만족 데이터 하나도 없으면 NULL
- NULL 은 unknown value
- NULL 과의 모든 수학적 계산 결과는 NULL
- NULL == NULL 은 unknown value
- NULL is NULL 은 참

| AND | T | F | U |
|:---:|:-:|:-:|:-:|
| T | T | F | U |
| F | F | F | F |
| U | U | F | U |

<br/>

| OR | T | F | U |
|:---:|:-:|:-:|:-:|
| T | T | T | T |
| F | T | F | U |
| U | T | U | U |

<br/>

| NOT | |
|:---:|:-:|
| T | F |
| F | T |
| U | U |

<br/>
<br/>

## 10.2.14 엔티티 직접 사용

<br/>

### 기본 키 값
- JPQL에서 엔티티 객체 직접 사용시 SQL에서는 해당 엔티티의 기본 키 값을 사용

```java
SELECT COUNT(m.id) FROM Member m  // 엔티티의 id 사용
SELECT COUNT(m) FROM Member m // 엔티티 직접 사용
```

- 두 번쨰 count(m)에서 엔티티 별칭 넘겨줘서 엔티티 직접 사용함
- 이렇게 하면 SQL 변환시 해당 엔티티 기본 키 사용하게 바뀜
- 따라서 위 두 예제는 동일한 쿼리로 변환됨

```sql
SELECT count(m.id) AS cnt
FROM Member m
```

<br/>

### 외래 키 값

```java
Team team = em.find(Team.class, 1L);

String qlString = "SELECT m FROM Member m WHERE m.team = :team";  // m.team_id 사용하도록 변환됨
List resultList = em.createQuery(qlString)
  .setParameter("team", team)
  .getResultList();
```

- ```m.team``` 이 ```m.team_id``` fk 와 매핑되어 있으므로 ```m.team_id``` 사용하도록 변환됨

<br/>
<br/>

## 10.2.15 Named 쿼리: 정적 쿼리
- JPQL 쿼리는 크게 동적, 정적 쿼리로 구분 가능
- **동적 쿼리:** ```em.createQuery("SELECT ...") 처럼 JPQL을 문자로 오나성해서 직접 넘기는 것. 런타임에 특정 조건 따라 동적으로 구성 가능
- **정적 쿼리:** 미리 정의한 쿼리에 이름 부여해서 필요할때 사용하는 쿼리(Named 쿼리). 한번 정의하면 변경 못함
  - Named 쿼리는 애플리케이션 로딩 시점에 JPQL 문법 체크 후 미리 파싱해둠
  - 따라서 오류 확인 빠르고 파싱된 결과 재사용하여 성능상 이점 있음
  - 또한 변하지 않는 정적 SQL 생성되어 DB 조회 성능 최적화에도 도움됨
  - ```@NamedQuery``` 어노테이션으로 자바 코드에 작성하거나 XML 문서에 작성 가능

<br/>

### Named 쿼리를 어노테이션에 정의

```java
// Named 쿼리 정의
@Entity
@NamedQuery(
  name = "Member.findByUsername", // Named 쿼리 이름
  query = "SELECT m FROM Member m WHERE m.username = :username" // Named 쿼리로 사용할 쿼리
)
/*
@NamedQueries({ // named 쿼리 여러개 쓰려면 @NamedQueries 어노테이션 쓰면 됨
  @NamedQuery(
    name = "Member.findByUsername", // Named 쿼리 이름
    query = "SELECT m FROM Member m WHERE m.username = :username" // Named 쿼리로 사용할 쿼리
  ),
  @NamedQuery(
    name = "Member.count", // Named 쿼리 이름
    query = "SELECT COUNT(m) FROM Member m" // Named 쿼리로 사용할 쿼리
  )
})
*/
public class Member {
  ...
}

...

// Named 쿼리 사용
public List<Member> findByUsername(EntityManager em, String username) {
  return em.createNamedQuery("Member.findByUsername", Member.class) // EntityManger::createNamedQuery 메소드에 사용할 named 쿼리 이름 넣어서 사용
    .setParameter("username", username)
    .getResultList();
}
```

<br/>

### Named 쿼리를 XML에 정의
- 자바에서 멀티라인 문자 쓰는건 불편한데 xml 로 쓰면 편리함
- 그래서 named 쿼리 작성할 때 xml 쓰는게 좀 더 편함
- 아래와 같이 xml 에 named 쿼리 정의 후 해당 xml 파일 인식할 수 있도록 persistence.xml 파일에 설정정보 추가
  - META-INF/orm.xml 은 JPA가 기본 매핑파일로 인식해서 별도 설정 필요없음
  - 아래 예제처럼 파일 이름이나 경로가 다를 때 persistence.xml 파일에 설정 정보 추가해줘야 함
- XML과 어노테이션에 동일 설정 있으면 XML이 우선권 가짐

```xml
<!-- META-INF/ormMember.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm" version="2.1">
  <named-query name="Member.findByUsername">
    <query><CDATA[
      SELECT m
      FROM Member m
      WHERE m.username = :username
    ]></query>
  </named-query>

  <named-query name="Member.count">
  <query>SELECT COUNT(m) FROM Member m</query>
  </named-query>
</entity-mappings>

...

<!-- META-INF/persistence.xml -->
...
<persistence-unit name="jpabook" >
  <mapping-file>META-INF/ormMember.xml</mapping-file>
...
```

> XML에서 &, <, > 는 예약 문자라 못씀<br/>
> 대신 ```&amp;```, ```&lt;```, ```&gt;``` 써야 함<br/>
> ```<![CDATA[...]]>``` 쓰면 예약 문자도 그냥 사용 가능


*작성중..(2022-03-15 p.406 10.3 Criteria 전까지)*