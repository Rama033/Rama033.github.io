---
layout: post
disqus_disabled: false
title: "[자바 ORM 표준 JPA 프로그래밍] 16장. 트랜잭션과 락, 2차 캐시"
date: 2022-04-07T21:14:00+09:00
author: Jo
categories: jpa-study
tags: jpa transaction lock 2nd-cache cache
cover: "/assets/instacode.png"
---

# 16장. 트랜잭션과 락, 2차 캐시

<br>

# 16.1 트랜잭션과 락

<br>
<br>

## 16.1.1 트랜잭션과 격리 수준
- 트랜잭션은 ACID를 보장해야 함
  - **원자성 (Atomicity):** 트랜잭션 내에서 실행한 작업들은 하나의 작업인것 처럼 모두 성공하거나 모두 실패해야 함
  - **일관성 (Consistencey):** 모든 트랜잭션은 일관성 있는 DB 상태 유지해야 함(ex. DB에서 정한 무결성 제약 조건을 항상 만족)
  - **격리성 (Isolation):** 동시에 실행되는 트랜잭션들이 서로 영향 미치지 않도록 격리해야 함. 격리 수준은 선택 가능 (ex. 동시에 같은 데이터 수정 불가)
  - **지속성 (Durability):** 트랜잭션 성공적으로 종료시 결과가 항상 기록되어야 함. 중간에 시스템 문제 발생해도 DB 로그 등으로 성공한 트랜잭션 내용을 복구
- 이 중에서 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야 하는데, 이럴 경우 동시성 처리 성능이 나빠져서 ANSI 표준에선 트랜잭션 격리 수준을 4단계로 정의
  - **READ UNCOMMITTED:** 커밋되지 않은 읽기 (격리 수준 가장 낮음)
  - **READ COMMITTED:** 커밋된 읽기
  - **REPEATABLE READ:** 반복 가능한 읽기
  - **SERIALIZABLE:** 직렬화 가능 (격리 수준 가장 높음)
- 격리 수준 낮을수록 동시성 증가하지만 더 많은 문제가 발생하게 됨
  - **DIRTY READ:** 커밋하지 않은 데이터 읽을 수 있음
  - **NON-REPEATABLE READ:** 반복해서 같은 데이터 읽을 수 없음
  - **PHANTOM READ:** 반복 조회 시 결과 집합이 달라짐
- 애플리케이션 대부분 동시성 처리가 중요하므로 보통 READ COMMITED 격리 수준을 기본으로 사용
  - 중요한 비즈니스 로직 등에서 더 높은 격리 수준 필요할 경우 DB 트랜잭션이 제공하는 락 기능 사용

| 격리 수준 | DIRTY READ | NON-REPEATABLE READ | PAHNTOM READ |
|:--------|:----------:|:-------------------:|:------------:|
| READ UNCOMMITTED | O | O | O |
| READ COMMITTED | | O | O |
| REPEATABLE READ | | | O |
| SERIALIZABLE | | | |

#### READ UNCOMMITTED
- DIRTY READ 까지 허용하는 격리 수준
- 예시
  - 트랜잭션 1이 수정중인 데이터를 트랜잭션 2가 조회할 경우 DIRTY READ
  - 이 때 트랜잭션 1이 롤백하면 데이터 정합성에 문제 발생할 수 있음

#### READ COMMITTED
- DIRTY READ 는 허용 안함
- NON-REPEATABLE READ 까지는 허용하는 격리 수준
- 예시
  - 트랜잭션 1이 회원 A 조회 중 트랜잭션 2가 회원 A 수정, 커밋
  - 트랜잭션 1이 회원 A 다시 조회하면 수정된 데이터 조회됨

#### REPEATABLE READ
- DIRTY READ, NON-REPEATABLE READ 허용 안함
- PHANTOM READ 까지는 허용하는 격리 수준
- 예시
  - 트랜잭션 1이 10살 이하의 회원 조회
  - 트랜잭션 2가 5살 회원 추가, 커밋
  - 트랜잭션 1이 다시 10살 이하 회원 조회 시 회원 하나가 추가된 상태로 조회됨

#### SERIALIZABLE
- DIRTY READ, NON-REPEATABLE READ, PHANTOM READ 모두 허용 안함
- 가장 엄격한 트랜잭션 격리 수준
- 동시성 처리 성능이 급격히 떨어질 수 있음

<br>
<br>

## 16.1.2 낙관적 락과 비관적 락 기초
- JPA 영속성 컨텍스트(1차 캐시) 활용시 READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 REPEATABLE READ 가능함
- JPA는 DB 트랜잭션 격리 수준을 READ COMMITTED 정도로 가정하며 더 높은 격리 수준 필요할 경우 낙관적 락, 비관적 락 중 하나를 사용하면 됨
  - **낙관적 락**
    - 트랜잭션 대부분은 충돌 발생하지 않는다고 가정하는 방법
    - DB 락 대신 JPA 버전 관리 기능을 사용
    - 트랜잭션 커밋 전까지는 충돌 여부 알 수 없음
  - **비관적 락**
    - 트랜잭션 충돌 발생을 가정하고 락을 걸고 보는 방법
    - DB 제공 락 기능을 사용
- **두 번의 갱신 분실 문제 (second loast updates problem):** DB 트랜잭션의 범위를 넘어서는 문제로 트랜잭션 만으로는 해결 불가능
  - A와 B가 같은 데이터를 동시에 수정중인 상황
  - A가 먼저 커밋한 후 이어서 B가 커밋하면 A의 수정사항은 사라지고 B 의 수정사항만 남게됨
  - 해결 방법은 3가지
    - **마지막 커밋만 인정하기:** A의 수정 내용 무시하고 마지막 커밋인 A 의 수정 사항만 인정
      - 기본적으로 사용되는 방법
    - **최초 커밋만 인정하기:** A가 이미 수정 끝냈으므로 B가 커밋할 때 오류 발생
      - JPA 버전 관리 기능으로 구현할 수 있음
    - **충돌하는 갱신 내용 병합하기:** A, B 의 수정사항을 병함
      - 개발자가 직접 병합 방법 제공해야 함

<br>
<br>

## 16.1.3 @Version
- 엔티티에 버전 관리용 필드 추가후 ```@Version``` 어노테이션 붙이면 버전 관리 기능 적용됨
- ```@Version``` 적용 가능 타입은 아래와 같음
  - Long
  - Integer
  - Short
  - Timestamp
- 이후 엔티티 수정할 때마다 버전이 자동으로 증가하며 조회 시점 버전과 수정 시점 버전이 다르면 예외 발생
  - 최초 커밋만 인정하기 적용

```java
// 버전 관리 추가
@Entity
public class Board {
  @Id
  private String id;
  private String title;

  @Version
  private Integer version;
}

...

// 버전 관리 사용
public void versionTest() {
  // 트랜잭션 1 조회 title="제목A", version=1
  Board board = em.find(Board.class, id);

  // 트랜잭션 2에서 게시물 수정하여 title="제목C', version=2로 증가

  board.setTitle("제목B");  // 트랜잭션 1 데이터 수정
  save(board);
  tx.commit();  // DB version=2, entity version=1이라 에외 발생
}
```

<img src="/assets/img/jpa_study/ch.16/pic-16-1.png">

1. 트랜잭션 1에서 title=제목A, version=1 인 데이터 조회
2. 트랜잭션 2에서 title=제목A, version=1 인 데이터 조회
3. 트랜잭션 2에서 title=제목C로 수정 후 커밋
4. DB에서 title=제목C로 변경, version=2로 증가됨
5. 트랜잭션 1에서 title=제목B로 수정 후 커밋
6. DB의 version과 트랜잭션 1의 엔티티 버전이 달라서 예외가 발생함

<br>

### 버전 정보 비교 방법

```sql
UPDATE board
SET
  title=?,
  version=? (버전 +1 증가)
WHERE
  id=?
  AND version=? (버전 비교)
```

- 엔티티 수정, 트랜잭션 커밋 시 위와 같은 UPDATE 쿼리 실행
- DB 버전과 엔티티 버전 같으면 데이터 수정하며 버전 하나 증가시킴
- DB 버전과 엔티티 버전 다르면 WHERE 절 조건의 version 비교때문에 조회되는 값 없음
  - 이미 버전이 증가한 것으로 판단해 JPA 에서 예외 발생시킴

<br>

- 버전은 엔티티 값 변경시 증가함
- 값 타입인 임베디드 타입, 값 타입 컬렉션 수정시에도 버전 증가
- 연관관계 필드는 연관관계 주인 필드를 수정할 때만 버전 증가
- 버전 관리 필드는 JPA가 직접 관리하므로 임의로 수정하면 안됨
  - 벌크 연산은 제외. 벌크 연산은 버전 무시해서 증가시키려면 강제로 값 올려줘야 함
- 버전 값 강제로 증가하려면 특별한 락 옵션이 필요

<br>
<br>

## 16.1.4 JPA 락 사용
- 락은 다음 위치에 적용 가능
  - ```EntityManager.lock()```, ```EntityManager.find()```, ```EntityManager.refresh()```
  - ```Query.setLockMode()  // TypeQuery 포함```
  - ```@NamedQuery```
- 조회하면서 즉시 락 걸 수 있음
  - ```Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);```
- 나중에 필요할 때 락 걸 수도 있음
  - ```em.lock(board, LockModeType.OPTIMISTIC);```
- LockModeType 은 아래 표와 같음

| 락 모드 | 타입 | 설명 |
|:------|:----|:----|
| 낙관적 락 | OPTIMISTIC | 낙관적 락 사용 |
| 낙관적 락 | OPTIMISTIC_FORCE_INCREMENT | 낙관적 락 + 버전 정보 강제 증가 |
| 비관적 락 | PESSIMISTIC_READ | 비관적 락, 읽기 락 사용 |
| 비관적 락 | PESSIMISTIC_WRITE | 비관적 락, 쓰기 락 사용 |
| 비관적 락 | PESSIMISTIC_FORCE_INCREMENT | 비관적 락 | 버전 정보 강제 증가 |
| 기타 | NONE | 락 걸지 않음 |
| 기타 | READ | JPA 1.0 호환 기능<br>OPTIMISITC 과 동일 |
| 기타 | WRITE | JPA 1.0 호환 기능<br>OPTIMISTIC_FORCE_INCREMENT와 동일 |

<br>
<br>

## 16.1.5 JPA 낙관적 락
- JPA 낙관적 락은 ```@Version``` 사용
- 트랜잭션 커밋 시점에 충돌 알 수 있음
- 낙관적 락에서는 다음과 같은 예외들이 발생함
  - ```javax.persistence.OptimisticLockException```: JPA 예외
  - ```org.hibernate.StaleObjectStateException```: 하이버네이트 예외
  - ```org.springframework.orm.ObjectOptimisticLockingFailureException```: 스프링 예외 추상화
- 락 옵션 없어도 ```@Version``` 만 있으면 낙관적 락 적용됨
  - 옵션 있을 경우 더 세밀하게 제어가 가능

<br>

### NONE
- 락 옵션 없이 ```@Version``` 적용된 필드만으로 낙관적 락 사용
- 엔티티 수정해야 버전 체크함
- **용도**
  - 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경, 삭제 되지 않아야 함
  - 조회 시점부터 수정 시점까지 보장
- **동작**
  - 엔티티 수정 시 버전 체크하면서 증가시킴(UPDATE 쿼리 사용)
  - DB 버전 값 현재 버전 아니면 예외 발생
- **이점**
  - 두 번의 갱신 분실 문제 예방

<br>

### OPTIMISTIC
- 이 옵션 추가시 엔티티 조회만 해도 버전을 체크함
- **용도**
  - 조회한 엔티티는 트랜잭션 끝날 때 까지 다른 트랜잭션에 의해 변경되지 않아야 함
  - 조회 시점부터 트랜잭션 끝날 때까지 조회한 엔티티가 변경 되지 않음을 보장
- **동작**
  - 트랜잭션 커밋할 때 버전 정보 조회(SELECT 쿼리 사용)
  - 현재 엔티티 버전과 같은지 검증해서 다르면 예외 발생
- **이점**
  - DIRTY READ, NON-REPEATABLE READ 방지

```java
// OPTIMISTIC 예제

// 트랜잭션 1 조회 title="제목A", version=1
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC);

// 중간에 트랜잭션 2에서 해당 게시물 수정해서 title="제목C", version=2로 증가

// 트랜잭션 1 커밋 시점에서 버전 정보 검증, 예외 발생
// DB version=2, 엔티티 version=1
tx.commit();
```

<img src="/assets/img/jpa_study/ch.16/pic-16-2.png">

1. 트랜잭션 1에서 OPTIMISTIC 락으로 데이터 조회 (title=제목A, version=1)
2. 트랜잭션 2에서 해당 데이터 수정, version 증가 (title=제목C, version=2)
3. 트랜잭션 1에서 트랜잭션 커밋 시 DB에 있는 버전 정보를 SELECT 쿼리로 조회해서 처음 조회한 엔티티 버전과 비교
   - 버전 정보 다르면 예외 발생

<br>

### OPTIMISTIC_FORCE_INCREMENT
- 낙관적 락 사용하며 버전 정보를 강제로 증가시킴
- **용도**
  - 논리적 단위의 엔티티 묶음 관리
  - ex. 게시물과 첨부파일이 일대다, 다대일 양방향 연관관계, 첨부파일이 연관관계 주인인 경우
    - 게시물 수정시 첨부파일 추가만 하면 게시물 버전은 증가하지 않음
    - 게시물은 물리적으로 변경되지 않았으나 논리적으로는 변경됨
    - 이럴 때 게시물 버전 강제 증가시키기 위해서 사용함
- **동작**
  - 엔티티 수정 안해도 트랜잭션 커밋 시 버전 정보 강제로 증가(UPDATE 쿼리 사용)
  - DB 버전과 엔티티 버전 다르면 예외 발생
  - 추가로 엔티티 수정하면 수정 시 버전 UPDATE 쿼리 발생해서 총 2 번의 버전 증가 나타날 수 있음
- **이점**
  - 논리적 단위의 엔티티 묶음 버전 관리할 수 있음

```java
// OPTIMISTIC_FORCE_INCREMENT

// 트랜잭션 1 조회 title="제목A", version=1
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC_FORCE_INCREMENT);

// 트랜잭션 1 커밋 시 버전 강제 증가
tx.commit();
```

<img src="/assets/img/jpa_study/ch.16/pic-16-3.png">

<br>
<br>

## 16.1.6 JPA 비관적 락
- DB 트랜잭션 락 메커니즘에 의존하는 방법
- 주로 쿼리에 ```SELECT FOR UPDATE``` 구문 사용하며 시작, 버전 정보는 안씀
- 주로 PESSIMISTIC_WRITE 모드 사용함
- 특징은 다음과 같음
  - 엔티티가 아닌 스칼라 타입 조회 시에도 사용 가능
  - 데이터 수정 즉시 트랜잭션 충돌 감지 가능
- 발생하는 예외는 다음과 같음
  - ```javax.persistence.PessimisticLockException```: JPA 예외
  - ```org.springframework.dao.PessimisticLockingFailureException```: 스프링 예외 추상화

<br>

### PESSIMISTIC_WRITE
- 일반적으로 말하는 비관적 락 옵션
- **용도**
  - DB에 쓰기 락 검
- **동작**
  - DB ```SELECT FOR UPDATE``` 사용
- **이점**
  - NON-REPEATABLE READ 방지
  - 락이 걸린 row는 다른 트랜잭션이 수정 불가

<br>

### PESSIMISTIC_READ
- 데이터 반복 읽기만 하고 수정 안하는 용도로 락 걸때 사용
- 대부분 DB에서 방언에 의해 PESSIMISTIC_WRITE 로 동작
- **MySQL:** lock in share mode
- **PostgreSQL:** for share

<br>

### PESSIMISTIC_FORCE_INCREMENT
- 버전 정보를 사용하는 유일한 비관적 락
- 버전 정보를 강제로 증가시킴
- 하이버네이트는 nowait 지원 DB에 한해서 for update nowait 옵션을 적용
- **오라클:** for update nowait
- **PostgreSQL:** for update nowait
- nowait 지원 안하면 for update 사용

<br>
<br>

## 16.1.7 비관적 락과 타임아웃
- 비관적 락 사용하면 락 획득시까지 트랜잭션이 대기하는데 이 때 타임아웃 시간을 설정할 수 있음
- 지정한 타임아웃 시간 지나면 ```javax.persistence.LockTimeoutException``` 예외 발생
- DB 특성 따라 동작 안할 수도 있으므로 주의

```java
// 타임아웃 설정 예제
Map<String, Object> properties = new HashMap<String, Object>();

// timeout 10초 설정
properties.put("javax.persistence.lock.timeout", 10000);  // ms 단위로 설정

// 10초 안에 락 획득 못하면 예외 발생함
Board board = em.find(Board.class, "boardId", LockModeType.PESSIMISTIC_WRITE, properties);
```

*작성중...(2022-04-07 p.707 16.2 2차캐시 전까지 함*