---
layout: post
disqus_disabled: false
title: "[자바 ORM 표준 JPA 프로그래밍] 3장. 영속성 관리"
date: 2022-01-20T12:17:00+09:00
author: Jo
categories: jpa-study
tags: jpa entity entity-manager persistence-context lifecycle flush
cover: "/assets/instacode.png"
---

JPA가 제공하는 기능은 크게 다음과 같이 분류 가능
1. 엔티티와 테이블을 매핑하는 설계
2. 매핑한 엔티티를 실제로 사용 

<br/>
<br/>
<br/>

# 3.1 엔티티 매니저 팩토리와 엔티티 매니저

### 엔티티 매니저 팩토리
- **역할**
  - 엔티티 매니저를 만드는 공장
- **비용**
  - 생성 비용이 매우 크기 때문에 한 개를 만들어서 애플리케이션 전체에서 공유
  - 일반적으로 데이터베이스 하나만 사용할 경우 EntityManagerFactory 하나 생성
- **스레드 세이프**
  - 엔티티 매니저 팩토리는 스레드 세이프
  - 따라서 여러 스레드에서 하나 공유
- ```Persistence.createEntityManagerFactory()``` 호출시 ```META-INF/persistence.xml``` 에 있는 정보를 바탕으로 EntityManagerFactory 생성

<br/>

### 엔티티 매니저
- **역할**
  - 엔티티를 저장, 수정, 삭제, 조회하는 등 엔티티와 관련된 모든 일을 처리, 관리하는 관리자
  - 엔티티를 저장하는 가상의 데이터베이스로 생각하면 됨
- **비용**
  - 엔티티 매니저 팩토리로 생성하는 엔티티 매니저는 생성 비용이 거의 들지 않음
  - 필요할 때마다 생성
- **스레드 세이프**
  - 엔티티 매니저는 스레드 세이프하지 않음
  - 동시성 문제 발생하기 때문에 스레드 간 공유하면 안됨
- **커넥션**
  - 엔티티 매니저는 데이터베이스 연결이 필요한 시점까지 커넥션 얻지 않음
    - 일반적으로 트랜잭션을 시작할 때 커넥션 획득
  - JPA 구현체들은 EntityManagerFactory 생성시 persistence.xml의 데이터베이스 접속 정보를 이용하여 커넥션풀도 만듬 (J2SE 환경)
    - 스프링 프레임워크를 포함한 J2EE 환경에서는 해당 컨테이너가 제공하는 데이터소스를 사용함

<br/>
<br/>
<br/>

# 3.2 영속성 컨텍스트란?
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저로 엔티티를 저장, 조회시 엔티티 매니저는 영속성 컨텍스트로 엔티티를 보관, 관리
- 영속성 컨텍스트는 엔티티 매니저 생성시 하나 만들어짐
- 엔티티 매니저를 통해 접근 및 관리 가능

<br/>
<br/>
<br/>

# 3.3 엔티티의 생명 주기
- 엔티티의 4가지 상태
  1. **비영속(new/transient):** 영속성 컨텍스트와 전혀 관계가 없는 상태
  2. **영속(managed):** 영속성 컨텍스트에 저장된 상태
  3. **준영속(detached):** 영속성 컨텍스트에 저장되었다가 분리된 상태
  4. **삭제(removed):** 삭제된 상태


<img src="/assets/img/jpa_study/ch.3/pic-3-2.png">

<br/>

### 비영속 (new/transient)
- 엔티티 객체 생성 후 아직 저장하지 않아 영속성 컨텍스, 데이터베이스와는 관련 없는 순수한 객체 상태
- 
```
// 객체를 생성한 상태 (비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```

<br/>

### 영속 (managed)
- 엔티티 매니저를 통해 영속성 컨텍스트에 저장되어 영속성 컨텍스트에 의해 관리하는 엔티티
- ```em.find()``` 또는 JPQL을 사용해서 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태가 됨
- 
```
// 객체를 저장한 상태(영속)
em.persist(member);
```

<br/>

### 준영속(detached)
- 영속성 컨텍스트가 관리하던 엔티티가 영속성 컨텍스트에 의해 관리되지 않으면 준영속 상태가 됨
- 다음을 이용하여 엔티티를 준영속 상태로 변경할 수 있음
  - ```em.detach()``` 를 호출
  - ```em.close()``` 로 영속성 컨텍스트를 종료
  - ```em.clear()``` 로 영속성 컨텍스트를 초기화

```
// 영속성 컨텍스트에서 분리된 상태(준영속)
em.detach(member);
```

<br/>

### 삭제
- 엔티티를 영속성 컨텍스트 및 데이터베이스에서 삭제

```
// 객체를 삭제한 상태(삭제)
em.remove(member);
```

<br/>
<br/>
<br/>

# 3.4 영속성 컨텍스트의 특징
1. 영속성 컨텍스트와 식별자 값
   - 영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분
   - 따라서 식별자 값은 non-null
2. 영속성 컨텍스트와 데이터베이스 저장
   - JPA는 보통 트랜잭션 커밋시 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영 (**flush**)
3. 영속성 컨텍스트에 의한 엔티티 관리시 장점
   - 1차 캐시
   - 동일성 보장
   - 트랜잭션을 지원하는 쓰기 지연
   - 변경 감지
   - 지연 로딩

<br/>
<br/>

## 3.4.1 엔티티 조회
### 1차 캐시
- 영속성 컨텍스트 내부의 캐시
- 영속 상태의 엔티티는 이곳에 저장
- key는 @Id로 DB pk와 매핑된 식별자 값
  - 따라서 영속성 컨텍스트에 데이터 저장, 조회하는 모든 기준은 데이터베이스 기본 키 값
- value는 엔티티 인스턴스

#### 엔티티 조회
1. 우선 1차 캐시에서 식별자 값으로 엔티티 조회
2. 1차 캐시에 엔티티 없을 경우 데이터베이스를 조회해서 엔티티 생성
3. 1차 캐시에 저장 후 영속 상태의 엔티티 반환

- 이처럼 먼저 메모리상의 1차 캐시부터 조회하여 성능상 이점을 누릴 수 있음

#### 영속 엔티티의 동일성 보장
```
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b);    // 동일성 비교 결과: true
```
- ```em.find()``` 반복 호출시에도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환
- 따라서 엔티티의 동일성을 보장

> **동일성과 동등성**
> 동일성(identity): 실제 인스턴스가 같음
> 동등성(equality): 인스턴스는 다를 수 있음. 인스턴스가 가지고 있는 값이 같음

> **REPEATABLE READ**
> JPA는 1차 캐시를 통해 반복 가능한 읽기 등급(REPEATABLE READ)의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공

*작성중...(2022-01-20 01:34)*