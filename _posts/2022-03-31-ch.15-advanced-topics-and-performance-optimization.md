---
layout: post
disqus_disabled: false
title: "[자바 ORM 표준 JPA 프로그래밍] 15장. 고급 주제와 성능 최적화"
date: 2022-03-31T23:20:00+09:00
author: Jo
categories: jpa-study
tags: jpa performance-optimization performance optimization exception compare proxy
cover: "/assets/instacode.png"
---

# 15장. 고급 주제와 성능 최적화

<br/>

# 15.1 예외 처리

<br/>

## 15.1.1 JPA 표준 예외 정리
- ```RuntimeException```
  - ㄴ ```javax.persistence.PersistenceException```
    - ㄴ JPA 표준 예외
      - 트랜잭션 롤백을 표시하는 예외
        - 심각한 예외, 복구 X
        - 트랜잭션 강제 커밋해도 안먹히고 ```javax.persistence.RollbackException``` 발생
      - 트랜잭션 롤백을 표시하지 않는 예외
        - 심각하지 않은 예외
        - 개발자가 커밋, 롤백 여부 판단해서 선택

| 트랜잭션 롤백을 표시하는 예외 | 설명 |
|:-----------------------|:----|
| javax.persistence.EntityExistsException | EntityManager.persist(...) 호출 시 이미 같은 엔티티 있는 경우 |
| javax.persistence.EntityNotFoundException | EntityManager.getReference(...) 호출했는데 실제 사용 시 엔티티가 존재하지 않으면 발생<br/>refresh(...), lock(...) 에서도 발생함 |
| javax.persistence.OptimisticLockException | 낙관적 락 충돌 시 발생 |
| javax.persistence.PessimisticLockException | 비관적 락 충돌 시 발생 | 
| javax.persistence.RollbackException | EntityTranscation.commit() 실패 시 발생<br/>롤백 표시되어 있는 트랜잭션 커밋 시에도 발생함 |
| javax.persistence.TranscationRequiredException | 트랜잭션 필요할 때 없으면 발생<br/> 트랜잭션 없이 엔티티 변경 시 주로 발생함|

<br/>

| 트랜잭션 롤백을 표시하지 않는 예외 | 설명 |
|:---------------------------|:----|
| javax.persistence.NoResultException | Query.getSingleResult() 호출 시 결과 하나도 없으면 발생 |
| javax.persistence.NonUniqueResultException | Query.getSingleResult() 호출 시 결과 둘 이상이면 발생 |
| javax.persistence.LockTimeoutException | 비관적 락에서 시간 초과 시 발생 |
| javax.persistence.QueryTimeoutException | 쿼리 실행 시간 초과 시 발생 |

<br/>
<br/>

## 15.1.2 스프링 프레임워크의 JPA 예외 변환
- 서비스 레이어에서 데이터 엑세스 레이어 구현 기술에 의존하는건 좋은 설계 아님
- 예외도 마찬가지로 서비스 레이어에서 JPA 예외 직접 사용해 JPA 에 의존하게 되는건 좋지 않음
- 이를 해결하기 위해 스프링에선 데이터 엑세스 레이어에 대한 예외를 추상화해서 제공해주고 있음

| JPA 예외 | 스프링 변환 예외 |
|:--------|:-------------|
| javax.persistence.PersistenceException | org.springframework.orm.jpa.JpaSystemException |
| javax.persistence.NoResultException | org.springframework.dao.EmptyResultDataAccessException |
| javax.persistence.NonUniqueResultException | org.springframework.dao.EmptyResultDataAccessException |
| javax.persistence.LockTimeoutException | org.springframework.dao.CannotAcquireLockException |
| javax.persistence.QueryTimeoutException | org.springframework.dao.QueryTimeoutException |
| javax.persistence.EntityExistsException | org.springframework.dao.DataIntegrityViolationException |
| javax.persistence.EntityNotFoundException | org.springframework.dao.JpaObjectRetrievalFailureException |
| javax.persistence.OptimisticLockException | org.springframework.dao.JpaOptimisticLockingFailureException |
| javax.persistence.PessimisticLockException | org.springframework.dao.PessimisticLockingFailureException |
| javax.persistence.TransactionRequiredException | org.springframework.dao.InvalidDataAccessApiUsageException |
| javax.persistence.RollbackException | org.springframework.dao.TRansactionSystemException |
| javax.persistence.IllegalStateException | org.springframework.dao.InvalidDataACcessApiUsageException |
| javax.persistence.IllegalArgumnentException | org.springframework.dao.InvalidDataAccessApiUsageException |

<br/>
<br/>

## 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
- ```PersistenceExceptionTranslationPostProcessor``` 를 스프링 빈으로 등록하여 JPA 예외 -> 스프링 예외 변환 기능 사용 가능
- ```@Repository``` 어노테이션 사용한 곳에 예외 변환 AOP 적용해서 JPA 예외를 스프링 프레임워크의 추상화한 예외로 변환해줌

```xml
<!-- xml로 설정 -->
<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslactionPostProcessor" />
```

```java
// JavaConfig으로 설정
@Bean
public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {
    return new PersistenceExceptionTranslationPostProcessor();
}
```

```java
// 예외 변환 예제
@Repostiroy
public class NoResultExceptionTestRepository {
    @PersistnceContext EntityManger em;

    public Member findMember() {
        // 조회된 member 없음
        return em.createQuery("SELECT m FROM Member m", Member.class)
            .getSingleResult();
    }
}
```
1. ```getSingleResult()``` 메소드 호출
2. 조회된 결과 없어서 ```javax.persistence.NoResultException``` 발생
3. ```PersistenceExceptionTranslationPostProcessor``` 에서 등록한 AOP 인터셉터가 동작해 해당 예외를 ```org.springframework.dao.EmptyResultDatAcessExcetpion``` 으로 변환해서 리턴

- 예외 변환하지 않고 그대로 반환하려면 throws 절에 그대로 반환할 JPA 예외나 JPA 예외의 부모 클래스를 직접 명시
    - ```public member findMember() throws javax.persistence.NoResultException {    // NoResultException 은 변환하지 않고 리턴함```

<br/>
<br/>

## 15.1.4 트랜잭션 롤백 시 주의사항
- 트랜잭션 롤백은 DB 반영사항만 롤백, 수정한 자바 객체는 원상태 복구 안해줌
  - DB 데이터는 원래대로 돌아가도 엔티티 객체는 수정된 상태로 영속성 컨텍스트에 남음
- ∴ 새로운 영속성 컨텍스트 생성하거나 ```EntityManager.clear()``` 호출해서 초기화한 다음 사용해야 함
- 스프링 프레임워크는 이런 문제 예방을 위해 영속성 컨텍스트 범위에 따라 다른 방법을 사용
  - 트랜잭션당 영속성 컨텍스트 전략
    - 문제 발생시 트랜잭션 AOP 종료 시점에 트랜잭션 롤백 되며 영속성 컨텍스트도 종료되어 문제 없음
  - OSIV 처럼 영속성 컨텍스트 범위를 트랜잭션 범위보다 넒게 사용해 여러 트랜잭션이 하나의 영속성 컨텍스트 사용하는 경우
    - 트랜잭션 롤백해서 영속성 컨텍스트 이상 발생해도 다른 트랜잭션이 해당 영속성 컨텍스트 그대로 사용하게 되는 문제 있음
    - 스프링에서는 영속성 컨텍스트 범위를 트랜잭션 보다 넓게 설정하면 트랜잭션 롤백 시 ```EntityManager.clear()``` 로 영속성 컨텍스트 초기화 시켜서 문제 예방함


*작성중...(2022-03-31 15장 p.645 15.2 엔티티 비교 전까지 함)*