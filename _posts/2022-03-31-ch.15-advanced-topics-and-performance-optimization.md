---
layout: post
disqus_disabled: false
title: "[자바 ORM 표준 JPA 프로그래밍] 15장. 고급 주제와 성능 최적화"
date: 2022-03-31T23:20:00+09:00
author: Jo
categories: jpa-study
tags: jpa performance-optimization performance optimization exception compare proxy
cover: "/assets/instacode.png"
---

# 15장. 고급 주제와 성능 최적화

<br/>

# 15.1 예외 처리

<br/>

## 15.1.1 JPA 표준 예외 정리
- ```RuntimeException```
  - ㄴ ```javax.persistence.PersistenceException```
    - ㄴ JPA 표준 예외
      - 트랜잭션 롤백을 표시하는 예외
        - 심각한 예외, 복구 X
        - 트랜잭션 강제 커밋해도 안먹히고 ```javax.persistence.RollbackException``` 발생
      - 트랜잭션 롤백을 표시하지 않는 예외
        - 심각하지 않은 예외
        - 개발자가 커밋, 롤백 여부 판단해서 선택

| 트랜잭션 롤백을 표시하는 예외 | 설명 |
|:-----------------------|:----|
| javax.persistence.EntityExistsException | EntityManager.persist(...) 호출 시 이미 같은 엔티티 있는 경우 |
| javax.persistence.EntityNotFoundException | EntityManager.getReference(...) 호출했는데 실제 사용 시 엔티티가 존재하지 않으면 발생<br/>refresh(...), lock(...) 에서도 발생함 |
| javax.persistence.OptimisticLockException | 낙관적 락 충돌 시 발생 |
| javax.persistence.PessimisticLockException | 비관적 락 충돌 시 발생 | 
| javax.persistence.RollbackException | EntityTranscation.commit() 실패 시 발생<br/>롤백 표시되어 있는 트랜잭션 커밋 시에도 발생함 |
| javax.persistence.TranscationRequiredException | 트랜잭션 필요할 때 없으면 발생<br/> 트랜잭션 없이 엔티티 변경 시 주로 발생함|

<br/>

| 트랜잭션 롤백을 표시하지 않는 예외 | 설명 |
|:---------------------------|:----|
| javax.persistence.NoResultException | Query.getSingleResult() 호출 시 결과 하나도 없으면 발생 |
| javax.persistence.NonUniqueResultException | Query.getSingleResult() 호출 시 결과 둘 이상이면 발생 |
| javax.persistence.LockTimeoutException | 비관적 락에서 시간 초과 시 발생 |
| javax.persistence.QueryTimeoutException | 쿼리 실행 시간 초과 시 발생 |

<br/>
<br/>

## 15.1.2 스프링 프레임워크의 JPA 예외 변환
- 서비스 레이어에서 데이터 엑세스 레이어 구현 기술에 의존하는건 좋은 설계 아님
- 예외도 마찬가지로 서비스 레이어에서 JPA 예외 직접 사용해 JPA 에 의존하게 되는건 좋지 않음
- 이를 해결하기 위해 스프링에선 데이터 엑세스 레이어에 대한 예외를 추상화해서 제공해주고 있음

| JPA 예외 | 스프링 변환 예외 |
|:--------|:-------------|
| javax.persistence.PersistenceException | org.springframework.orm.jpa.JpaSystemException |
| javax.persistence.NoResultException | org.springframework.dao.EmptyResultDataAccessException |
| javax.persistence.NonUniqueResultException | org.springframework.dao.EmptyResultDataAccessException |
| javax.persistence.LockTimeoutException | org.springframework.dao.CannotAcquireLockException |
| javax.persistence.QueryTimeoutException | org.springframework.dao.QueryTimeoutException |
| javax.persistence.EntityExistsException | org.springframework.dao.DataIntegrityViolationException |
| javax.persistence.EntityNotFoundException | org.springframework.dao.JpaObjectRetrievalFailureException |
| javax.persistence.OptimisticLockException | org.springframework.dao.JpaOptimisticLockingFailureException |
| javax.persistence.PessimisticLockException | org.springframework.dao.PessimisticLockingFailureException |
| javax.persistence.TransactionRequiredException | org.springframework.dao.InvalidDataAccessApiUsageException |
| javax.persistence.RollbackException | org.springframework.dao.TRansactionSystemException |
| javax.persistence.IllegalStateException | org.springframework.dao.InvalidDataACcessApiUsageException |
| javax.persistence.IllegalArgumnentException | org.springframework.dao.InvalidDataAccessApiUsageException |

<br/>
<br/>

## 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
- ```PersistenceExceptionTranslationPostProcessor``` 를 스프링 빈으로 등록하여 JPA 예외 -> 스프링 예외 변환 기능 사용 가능
- ```@Repository``` 어노테이션 사용한 곳에 예외 변환 AOP 적용해서 JPA 예외를 스프링 프레임워크의 추상화한 예외로 변환해줌

```xml
<!-- xml로 설정 -->
<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslactionPostProcessor" />
```

```java
// JavaConfig으로 설정
@Bean
public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {
    return new PersistenceExceptionTranslationPostProcessor();
}
```

```java
// 예외 변환 예제
@Repostiroy
public class NoResultExceptionTestRepository {
    @PersistnceContext EntityManger em;

    public Member findMember() {
        // 조회된 member 없음
        return em.createQuery("SELECT m FROM Member m", Member.class)
            .getSingleResult();
    }
}
```
1. ```getSingleResult()``` 메소드 호출
2. 조회된 결과 없어서 ```javax.persistence.NoResultException``` 발생
3. ```PersistenceExceptionTranslationPostProcessor``` 에서 등록한 AOP 인터셉터가 동작해 해당 예외를 ```org.springframework.dao.EmptyResultDatAcessExcetpion``` 으로 변환해서 리턴

- 예외 변환하지 않고 그대로 반환하려면 throws 절에 그대로 반환할 JPA 예외나 JPA 예외의 부모 클래스를 직접 명시
    - ```public member findMember() throws javax.persistence.NoResultException {    // NoResultException 은 변환하지 않고 리턴함```

<br/>
<br/>

## 15.1.4 트랜잭션 롤백 시 주의사항
- 트랜잭션 롤백은 DB 반영사항만 롤백, 수정한 자바 객체는 원상태 복구 안해줌
  - DB 데이터는 원래대로 돌아가도 엔티티 객체는 수정된 상태로 영속성 컨텍스트에 남음
- ∴ 새로운 영속성 컨텍스트 생성하거나 ```EntityManager.clear()``` 호출해서 초기화한 다음 사용해야 함
- 스프링 프레임워크는 이런 문제 예방을 위해 영속성 컨텍스트 범위에 따라 다른 방법을 사용
  - 트랜잭션당 영속성 컨텍스트 전략
    - 문제 발생시 트랜잭션 AOP 종료 시점에 트랜잭션 롤백 되며 영속성 컨텍스트도 종료되어 문제 없음
  - OSIV 처럼 영속성 컨텍스트 범위를 트랜잭션 범위보다 넒게 사용해 여러 트랜잭션이 하나의 영속성 컨텍스트 사용하는 경우
    - 트랜잭션 롤백해서 영속성 컨텍스트 이상 발생해도 다른 트랜잭션이 해당 영속성 컨텍스트 그대로 사용하게 되는 문제 있음
    - 스프링에서는 영속성 컨텍스트 범위를 트랜잭션 보다 넓게 설정하면 트랜잭션 롤백 시 ```EntityManager.clear()``` 로 영속성 컨텍스트 초기화 시켜서 문제 예방함

<br/>
<br/>
<br/>

# 15.2 엔티티 비교
- **애플리케이션 수준의 반복 가능한 읽기**
  - 1차 캐시의 가장 큰 장점
  - 같은 영속성 컨텍스트에서 엔티티 조회 시 항상 같은 엔티티 인스턴스를 반환

<br/>
<br/>

## 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교

<img src="/assets/img/jpa_study/ch.15/pic-15-1.png">

```java
// 회원가입 테스트 케이스에서의 테스트와 트랜잭션 범위 예제
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:appConfig.xml")
@Transactional  // 트랜잭션 안에서 테스트를 실행
public class MemberServiceTest {
    @Autowired MemberService memberService;
    @Autowired MemberRepsotiroy memberRepository;

    @Test
    public void joinTest() throws Exception {
        // Given
        Member member = new Member("kim");

        // When
        Long saveId = memberService.join(member);

        // Then
        Member findMember = memberRepository.findOne(saveId)
        asertTrue(member == findMember);    // 참조값 비교
    }
}

...

@Transactional  // 이 예제에서는 Test 클래스에서 Transaction 시작해서 그거 이어받아서 사용함
public class MemberService {
    @Autowired MemberRepository memberRepository;

    public Long join(Member member) {
        ...

        memberRepository.save(member);
        return member.getId();
    }
}

...

@Repository
public class MemberRepository {
    @PersistenceContext
    EntityManager em;

    public void save(Member member) {
        em.persist(member);
    }

    public Member findOne(Long id) {
        return em.find(Member.class, id);
    }
}
```

<img src="/assets/img/jpa_study/ch.15/pic-15-2.png">

- 테스트 클래스에 ```@Transactional``` 선언되어 있으면 트랜잭션 먼저 시작 후 테스트 메소드 실행되므로 ```joinTest()``` 메소드는 트랜잭션 범위의 안쪽, 해당 메소드 끝나면 트랜잭션 종료됨
  - 테스트 클래스에 ```@Transactional``` 적용하면 테스트 끝날 때 트랜잭션 강제 롤백함
- ∴ ```joinTest()``` 에서 사용된 코드는 항상 같은 트랜잭션, 같은 영속성 컨텍스트에 접근
  - 위 예제에서 저장한 member와 레포지토리에서 조회해온 엔티티가 완전히 같은 인스턴스 => 같은 트랜잭션 범위 안이라 동일한 영속성 컨텍스트를 사용하기 때문
- 영속성 컨텍스트가 같으면 엔티티 비교시 다음 3가지 조건 모두 만족함
  - **동일성 identical:** ```==``` 비교가 같음
  - **동등성 equinalent:** ```equals()``` 비교가 같음
  - **DB 동등성:** ```@Id``` 인 DB 식별자가 같음

<br/>
<br/>

## 15.2.2 영속성 컨텍스트가 다를 때 엔티티 비교

<img src="/assets/img/jpa_study/ch.15/pic-15-3.png">

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:appConfig.xml")
// @Transcational   테스트에서 트랜잭션 사용 안함
public class MemberServiceTest {
    @Autowired
    MemberService memberService;
    @Autowired
    MemberRepsotiroy memberRepository;

    @Test
    public void joinTest() throws Exception {
        // Given
        Member member = new Member("kim");

        // When
        Long saveId = memberService.join(member);

        // Then
        Member findMember = memberRepository.findOne(saveId)    // Transaction은 MemberRepository::findOne 종료되며 같이 끝났기 때문에 findMember 는 준영속 상태
        asertTrue(member == findMember);    // member 와 findMEmber 는 다른 주소값을 가진 인스턴스 => 테스트 실패
    }
}

...

@Transactional  // 서비스 클래스에서 트랜잭션이 시작됨
public class MemberService {
    @Autowired MemberRepository memberRepository;

    public Long join(Member member) {
        ...

        memberRepository.save(member);
        return member.getId();
    }
}

...

@Repository
@Transactional  // 이 예제에서는 Test 클래스에서 트랜잭션 시작 안하기 때문에 여기도 추가
public class MemberRepository {
    @PersistenceContext
    EntityManager em;

    public void save(Member member) {
        em.persist(member);
    }

    public Member findOne(Long id) {
        return em.find(Member.class, id);
    }
```

<img src="/assets/img/jpa_study/ch.15/pic-15-4.png">

1. Test 코드에서 ```memberService.join(member)``` 호출, 회원가입 시도하면 서비스 레이어에서 트랜잭션 시작, *영속성 컨텍스트 1* 생성됨
2. ```memberRepsitory``` 에서 ```em.persist()``` 호출해서 member 엔티티 영속화
3. 서비스 레이어 끝날 때 트랜잭션 커밋되며 영속성 컨텍스트 플러시 되고 트랜잭션, 영속성 컨텍스트 종료. member 엔티티 인스턴스는 준영속 상태 됨
4. 테스트 코드에서 ```memberRepository.findOne(saveId)``` 호출해 저장한 엔티티 조회하면 레포지토리 레이어에서 새로운 트랜잭션 시작, *영속성 컨텍스트 2* 생성됨
5. 저장된 member 조회하지만 *영속성 컨텍스트 2* 에는 해당 member 없음
6. DB 에서 해당 member 조회해 옴
7. DB 에서 조회된 member 엔티티를 영속성 컨텍스트에 보관하고 반환
8. ```memberRepository.findOne()``` 메소드 끝나며 트랜잭션 종료, *영속성 컨텍스트 2* 종료

- member 와 findMember 는 다른 영속성 컨텍스트에서 관리되어 서로 다른 인스턴스
  - ```assertTrue(member == findMember)``` 실패함
- 영속성 컨텍스트 다른 경우 엔티티 비교 결과는 아래와 같음
  - **동일성 identical:** ```==``` 비교 실패
  - **동등성 equinalent:** ```equals()``` 비교 만족. 대신 ```equals()``` 구현해야 함
    - 엔티티 비교를 위해 ```equals()``` 구현시엔 비즈니스 키를 활용한 동등성 비교를 권장
  - **DB 동등성:** @Id 인 DB 식별자 값 같음

<br/>
<br/>
<br/>

# 15.3 프록시 심화 주제

<br/>
<br/>

## 15.3.1 영속성 컨텍스트와 프록시
- 영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성 보장
- 프록시로 조회한 엔티티의 경우에도 동일성을 보장함
  - **프록시 먼저 조회 후 원본 엔티티 조회한 경우**
    - 이미 프록시로 조회한 엔티티에 대해 같은 엔티티 조회 요청 오면 **원본이 아닌 처음 조회된 프록시를 반환**
    - ∴ 둘다 동일한 프록시 반환되어 동일성 보장
  - **원본 엔티티 먼저 조회 후 프록시 조회한 경우**
    - 원본 엔티티를 이미 DB에서 조회해서 영속성 컨텍스트에서 관리중이므로 **프록시로 요청해도 원본 엔티티를 반환**
    - ∴ 둘다 동일한 원본 엔티티 반환되어 동일성 보장

<br/>
<br/>

## 15.3.2 프록시 타입 비교

<img src="/assets/img/jpa_study/ch.15/pic-15-5.png">

- 프록시는 원본 엔티티 상속받아 만들어지므로 타입 비교시 ```==``` 대신 ```instanceof``` 사용해야 함
- 프록시와 원본 엔티티를 ```==``` 로 비교하게 되면 부모 클래스와 자식 클래스를 비교한 것이 됨 => 결과는 false
- ∴ ```instanceof``` 를 통해 비교해야 함

<br/>
<br/>

## 15.3.3 프록시 동등성 비교
- 엔티티 동등성 비교 시 비즈니스 키 이용해 ```equals()``` 메소드 오버라이딩 하여 비교하면 됨
- IDE나 외부 라이브러리 사용해서 구현한 ```equals()``` 메소드를 엔티티 비교에 사용해도 원본 엔티티면 문제 없음
  - 프록시인 경우엔 문제 발생할 수 있음   

```java
@Entity
public class Member {
    @Id
    private String id;
    private String name;

    ...

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (this.getClass() != obj.getClass()) return false;    // 문제점 1

        Member member = (Member) obj;

        if (name != null ? !name.equals(member.name) : member.name != null) return false;    // 문제점 2

        return true;
    }

    @Override
    public int hashCode() {
        return name != null ? name.hashCode() : 0;
    }
}

...

@TEst
public void proxyEquivalnceTest() {
    Member saveMember = new Member("member1", "memberA");
    em.persiste(saveMember);
    em.flush();
    em.clear();

    Member newMEmber = new Member("member1", "memberA");
    Member refMember = em.getReference(Member.class, "memberA");

    Assert.assertTrue(newMember.equals(refMember)); // 실패
}
```

<img src="/assets/img/jpa_study/ch.15/pic-15-6.png">

- 위 예제에서 ```Assert.assertTrue(newMember.equals(refMember));``` 가 실패하는 이유는 다음과 같음

<br/>

### 문제점 1: 타입 비교

 ```java
 if (this.getClass() != obj.getClass()) return false;
 ```

- 프록시는 원본을 상속받은 자식 타입이므로 프록시 타입 비교시 ```==``` 가 아닌 ```instanceof``` 를 사용해야 함

<br/>

### 문제점 2: 프록시 멤버 변수 접근
```java
Member member = (Member) obj;

if (name != null ? !name.equals(member.name) : member.name != null) return false;
```

<img src="/assets/img/jpa_study/ch.15/pic-15-7.png">

<img src="/assets/img/jpa_study/ch.15/pic-15-8.png">

- 프록시는 실제 데이터를 가지고 있지 않음
- 따라서 프록시의 멤버 변수에 직접 접근하면 아무 값도 조회할 수 없음
- 접근자를 사용해 멤버 변수에 접근해야 원본 엔티티 조회해와서 실제 값에 접근할 수 있음

<br/>

### 문제 해결한 equals() 메소드 예제

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof Member)) return false; // 프록시의 타입 비교는 == 대신 instanceof 사용

    Member member = (Member) obj;

    if (name != null ? !name.equals(member.getName()) : member.getName() != null) return false; // 프록시의 멤버 변수에 직접 접근하지 말고 getter 메소드 사용

    return true;
}
```



*작성중...(2022-03-31 15장 p.660 15.3.4 상속관계와 프록시 전까지 함)*