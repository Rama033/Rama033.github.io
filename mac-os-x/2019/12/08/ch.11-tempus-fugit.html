<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[OS X Internals] CH.11 Tempus Fugit</title>
  <meta name="description" content="Mach Scheduling">
  
  <meta name="author" content="Jo">
  <meta name="copyright" content="&copy; Jo 2020">
  

  <!-- External libraries -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css">

  <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
  <link rel="shortcut icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  
  <!-- Facebook OGP cards -->
  <meta property="og:description" content="Mach Scheduling" />
  <meta property="og:url" content="https://sungunjo.github.io/mac-os-x/2019/12/08/ch.11-tempus-fugit.html">
  <meta property="og:site_name" content="감자는 맛있다" />
  <meta property="og:title" content="[OS X Internals] CH.11 Tempus Fugit" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://sungunjo.github.io/assets/instacode.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="612" />
  <meta property="og:image:height" content="605" />
  

  
  <!-- Twitter: card tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[OS X Internals] CH.11 Tempus Fugit">
  <meta name="twitter:description" content="Mach Scheduling">
  <meta name="twitter:image" content="https://sungunjo.github.io/assets/instacode.png">
  <meta name="twitter:url" content="https://sungunjo.github.io/mac-os-x/2019/12/08/ch.11-tempus-fugit.html">
  

  

  <!-- Site styles -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://sungunjo.github.io/mac-os-x/2019/12/08/ch.11-tempus-fugit.html">
	<link rel="alternate" type="application/rss+xml" title="감자는 맛있다" href="https://sungunjo.github.io/feed.xml" />
	
	<!-- Tooltips -->
	<script type="text/javascript">
		window.tooltips = []
	</script>
</head>


  <body>

    <header class="navigation" role="banner">
  <div class="navigation-wrapper">
    <a href="/" class="logo">
      
      <img src="/assets/logo.png" alt="감자는 맛있다">
      
    </a>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
      <i class="fa fa-bars"></i>
    </a>
    <nav role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
				
	
	<li class="nav-link"><a href="/about/">About</a>
	

	

	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </nav>
  </div>
</header>


    <div class="page-content">
        <div class="post">

<div class="post-header-container has-cover" style="background-image: url(/assets/instacode.png);">
  <div class="scrim has-cover">
    <header class="post-header">
      <h1 class="title">[OS X Internals] CH.11 Tempus Fugit</h1>
      <p class="info">by <strong>Jo</strong></p>
    </header>
  </div>
</div>

<div class="wrapper">



<section class="post-meta">
  <div class="post-date">December 8, 2019</div>
  <div class="post-categories">
  in 
    
    <a href="/category/mac-os-x">Mac-os-x</a>
    
  
  </div>
</section>

<article class="post-content">
  <h1 id="mach-scheduling">Mach Scheduling</h1>

<p>이번 챕터에서는 스케줄링에 초점을 맞춘다.</p>

<ul>
  <li><strong>Scheduling Primitives:</strong> task와 thread, 그리고 그들이 제공하는 APIs</li>
  <li><strong>Scheduling:</strong> 알고리즘과 같은 높은 수준의 scheduling 개념</li>
  <li><strong>Asynchronous Software Traps(AST):</strong> scheduling에 중요한 Mach의 AST 개념</li>
  <li><strong>Exception Handling:</strong> 하드웨어 trap에 대한 Mach의 고유한 접근 방식</li>
  <li><strong>Scheduling Algorithms:</strong> Mach의 default scheduler뿐만 아니라 다른 알고리즘 구현방식을 가진 scheduler로의 확장 및 교체가 가능한 scheduling framework</li>
</ul>

<h2 id="scheduling-primitives">SCHEDULING PRIMITIVES</h2>

<p>다른 모든 modern OS와 마찬가지로 Mach도 process가 아닌 thread를 본다. 다만 실제로 process에 대한 인식은 UN*X와 조금 다른데, process 보다는 lightweight task의 개념을 사용한다. Classic UN*X  는 process를 기본 object로 하여 하나 이상의 thread로 더 분할 되는 top-down 접근 방식이지만, Mach의 경우는 기본 단위가 thread 이고 하나 이상의 thread가 process에 포함되는 bottom-up 접근방식을 사용한다.</p>

<h3 id="threads">Threads</h3>

<p>thread는 Mach의 원자 단위 execution을 정의하며 underlying machine register state 및 다양한 scheduling statistics를 나타낸다. <br />
가능한 한 가장 낮은 오버헤드를 유지하면서 scheduling에 필요한 최대한의 정보를 제공하도록 설계되었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="kr">thread</span> <span class="p">{</span>

<span class="cp">#if MACH_ASSERT
#define THREAD_MAGIC 0x1234ABCDDCBA4321ULL
</span>	<span class="cm">/* Ensure nothing uses &amp;thread as a queue entry */</span>
	<span class="kt">uint64_t</span>                <span class="n">thread_magic</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* MACH_ASSERT */</span><span class="cp">
</span>
	<span class="cm">/*
	 *	NOTE:	The runq field in the thread structure has an unusual
	 *	locking protocol.  If its value is PROCESSOR_NULL, then it is
	 *	locked by the thread_lock, but if its value is something else
	 *	then it is locked by the associated run queue lock. It is
	 *	set to PROCESSOR_NULL without holding the thread lock, but the
	 *	transition from PROCESSOR_NULL to non-null must be done
	 *	under the thread lock and the run queue lock.
	 *
	 *	New waitq APIs allow the 'links' and 'runq' fields to be
	 *	anywhere in the thread structure.
	 */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">queue_chain_t</span>           <span class="n">runq_links</span><span class="p">;</span>     <span class="cm">/* run queue links */</span>
		<span class="n">queue_chain_t</span>           <span class="n">wait_links</span><span class="p">;</span>     <span class="cm">/* wait queue links */</span>
	<span class="p">};</span>

	<span class="n">processor_t</span>             <span class="n">runq</span><span class="p">;</span>           <span class="cm">/* run queue assignment */</span>

	<span class="n">event64_t</span>               <span class="n">wait_event</span><span class="p">;</span>     <span class="cm">/* wait queue event */</span>
	<span class="k">struct</span> <span class="n">waitq</span>           <span class="o">*</span><span class="n">waitq</span><span class="p">;</span>          <span class="cm">/* wait queue this thread is enqueued on */</span>

	<span class="cm">/* Data updated during assert_wait/thread_wakeup */</span>
<span class="cp">#if __SMP__
</span>	<span class="n">decl_simple_lock_data</span><span class="p">(,</span><span class="n">sched_lock</span><span class="p">)</span>	<span class="cm">/* scheduling lock (thread_lock()) */</span>
	<span class="n">decl_simple_lock_data</span><span class="p">(,</span><span class="n">wake_lock</span><span class="p">)</span>	<span class="cm">/* for thread stop / wait (wake_lock()) */</span>
<span class="cp">#endif
</span>	<span class="n">integer_t</span>		<span class="n">options</span><span class="p">;</span>			<span class="cm">/* options set by thread itself */</span>
<span class="cp">#define TH_OPT_INTMASK		0x0003		</span><span class="cm">/* interrupt / abort level */</span><span class="cp">
#define TH_OPT_VMPRIV		0x0004		</span><span class="cm">/* may allocate reserved memory */</span><span class="cp">
#define TH_OPT_DTRACE		0x0008		</span><span class="cm">/* executing under dtrace_probe */</span><span class="cp">
#define TH_OPT_SYSTEM_CRITICAL	0x0010		</span><span class="cm">/* Thread must always be allowed to run - even under heavy load */</span><span class="cp">
#define TH_OPT_PROC_CPULIMIT	0x0020		</span><span class="cm">/* Thread has a task-wide CPU limit applied to it */</span><span class="cp">
#define TH_OPT_PRVT_CPULIMIT	0x0040		</span><span class="cm">/* Thread has a thread-private CPU limit applied to it */</span><span class="cp">
#define TH_OPT_IDLE_THREAD	0x0080		</span><span class="cm">/* Thread is a per-processor idle thread */</span><span class="cp">
#define TH_OPT_GLOBAL_FORCED_IDLE	0x0100	</span><span class="cm">/* Thread performs forced idle for thermal control */</span><span class="cp">
#define TH_OPT_SCHED_VM_GROUP	0x0200		</span><span class="cm">/* Thread belongs to special scheduler VM group */</span><span class="cp">
#define TH_OPT_HONOR_QLIMIT	0x0400		</span><span class="cm">/* Thread will honor qlimit while sending mach_msg, regardless of MACH_SEND_ALWAYS */</span><span class="cp">
#define TH_OPT_SEND_IMPORTANCE	0x0800		</span><span class="cm">/* Thread will allow importance donation from kernel rpc */</span><span class="cp">
#define TH_OPT_ZONE_GC		0x1000		</span><span class="cm">/* zone_gc() called on this thread */</span><span class="cp">
</span>
	<span class="n">boolean_t</span>			<span class="n">wake_active</span><span class="p">;</span>	<span class="cm">/* wake event on stop */</span>
	<span class="kt">int</span>					<span class="n">at_safe_point</span><span class="p">;</span>	<span class="cm">/* thread_abort_safely allowed */</span>
	<span class="n">ast_t</span>				<span class="n">reason</span><span class="p">;</span>			<span class="cm">/* why we blocked */</span>
	<span class="kt">uint32_t</span> 			<span class="n">quantum_remaining</span><span class="p">;</span>
	<span class="n">wait_result_t</span> 			<span class="n">wait_result</span><span class="p">;</span> 	<span class="cm">/* outcome of wait -
							 * may be examined by this thread
							 * WITHOUT locking */</span>
	<span class="n">thread_continue_t</span>	<span class="n">continuation</span><span class="p">;</span>	<span class="cm">/* continue here next dispatch */</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">parameter</span><span class="p">;</span>		<span class="cm">/* continuation parameter */</span>

	<span class="cm">/* Data updated/used in thread_invoke */</span>
	<span class="n">vm_offset_t</span>     	<span class="n">kernel_stack</span><span class="p">;</span>		<span class="cm">/* current kernel stack */</span>
	<span class="n">vm_offset_t</span>			<span class="n">reserved_stack</span><span class="p">;</span>		<span class="cm">/* reserved kernel stack */</span>

<span class="cp">#if KASAN
</span>	<span class="k">struct</span> <span class="n">kasan_thread_data</span> <span class="n">kasan_data</span><span class="p">;</span>
<span class="cp">#endif
</span>
	<span class="cm">/* Thread state: */</span>
	<span class="kt">int</span>					<span class="n">state</span><span class="p">;</span>
<span class="cm">/*
 *	Thread states [bits or'ed]
 */</span>
<span class="cp">#define TH_WAIT			0x01			</span><span class="cm">/* queued for waiting */</span><span class="cp">
#define TH_SUSP			0x02			</span><span class="cm">/* stopped or requested to stop */</span><span class="cp">
#define TH_RUN			0x04			</span><span class="cm">/* running or on runq */</span><span class="cp">
#define TH_UNINT		0x08			</span><span class="cm">/* waiting uninteruptibly */</span><span class="cp">
#define TH_TERMINATE		0x10			</span><span class="cm">/* halted at termination */</span><span class="cp">
#define TH_TERMINATE2		0x20			</span><span class="cm">/* added to termination queue */</span><span class="cp">
</span>
<span class="cp">#define TH_IDLE			0x80			</span><span class="cm">/* idling processor */</span><span class="cp">
</span>
	<span class="cm">/* Scheduling information */</span>
	<span class="n">sched_mode_t</span>			<span class="n">sched_mode</span><span class="p">;</span>		<span class="cm">/* scheduling mode */</span>
	<span class="n">sched_mode_t</span>			<span class="n">saved_mode</span><span class="p">;</span>		<span class="cm">/* saved mode during forced mode demotion */</span>

	<span class="cm">/* This thread's contribution to global sched counters */</span>
	<span class="n">sched_bucket_t</span>                  <span class="n">th_sched_bucket</span><span class="p">;</span>

	<span class="n">sfi_class_id_t</span>			<span class="n">sfi_class</span><span class="p">;</span>		<span class="cm">/* SFI class (XXX Updated on CSW/QE/AST) */</span>
	<span class="n">sfi_class_id_t</span>			<span class="n">sfi_wait_class</span><span class="p">;</span>	<span class="cm">/* Currently in SFI wait for this class, protected by sfi_lock */</span>


	<span class="kt">uint32_t</span>			<span class="n">sched_flags</span><span class="p">;</span>		<span class="cm">/* current flag bits */</span>
<span class="cm">/* TH_SFLAG_FAIRSHARE_TRIPPED (unused)	0x0001 */</span>
<span class="cp">#define TH_SFLAG_FAILSAFE		0x0002		</span><span class="cm">/* fail-safe has tripped */</span><span class="cp">
#define TH_SFLAG_THROTTLED		0x0004		</span><span class="cm">/* throttled thread forced to timeshare mode (may be applied in addition to failsafe) */</span><span class="cp">
#define TH_SFLAG_DEMOTED_MASK      (TH_SFLAG_THROTTLED | TH_SFLAG_FAILSAFE)	</span><span class="cm">/* saved_mode contains previous sched_mode */</span><span class="cp">
</span>
<span class="cp">#define	TH_SFLAG_PROMOTED		0x0008		</span><span class="cm">/* sched pri has been promoted */</span><span class="cp">
#define TH_SFLAG_ABORT			0x0010		</span><span class="cm">/* abort interruptible waits */</span><span class="cp">
#define TH_SFLAG_ABORTSAFELY		0x0020		</span><span class="cm">/* ... but only those at safe point */</span><span class="cp">
#define TH_SFLAG_ABORTED_MASK		(TH_SFLAG_ABORT | TH_SFLAG_ABORTSAFELY)
#define	TH_SFLAG_DEPRESS		0x0040		</span><span class="cm">/* normal depress yield */</span><span class="cp">
#define TH_SFLAG_POLLDEPRESS		0x0080		</span><span class="cm">/* polled depress yield */</span><span class="cp">
#define TH_SFLAG_DEPRESSED_MASK		(TH_SFLAG_DEPRESS | TH_SFLAG_POLLDEPRESS)
</span><span class="cm">/* unused TH_SFLAG_PRI_UPDATE           0x0100 */</span>
<span class="cp">#define TH_SFLAG_EAGERPREEMPT		0x0200		</span><span class="cm">/* Any preemption of this thread should be treated as if AST_URGENT applied */</span><span class="cp">
#define TH_SFLAG_RW_PROMOTED		0x0400		</span><span class="cm">/* sched pri has been promoted due to blocking with RW lock held */</span><span class="cp">
</span><span class="cm">/* unused TH_SFLAG_THROTTLE_DEMOTED     0x0800 */</span>
<span class="cp">#define TH_SFLAG_WAITQ_PROMOTED		0x1000		</span><span class="cm">/* sched pri promoted from waitq wakeup (generally for IPC receive) */</span><span class="cp">
</span>

<span class="cp">#define TH_SFLAG_EXEC_PROMOTED          0x8000		</span><span class="cm">/* sched pri has been promoted since thread is in an exec */</span><span class="cp">
#define TH_SFLAG_PROMOTED_MASK	        (TH_SFLAG_PROMOTED | TH_SFLAG_RW_PROMOTED | TH_SFLAG_WAITQ_PROMOTED | TH_SFLAG_EXEC_PROMOTED)
</span>
<span class="cp">#define TH_SFLAG_RW_PROMOTED_BIT	(10)	</span><span class="cm">/* 0x400 */</span><span class="cp">
</span>
	<span class="kt">int16_t</span>                         <span class="n">sched_pri</span><span class="p">;</span>              <span class="cm">/* scheduled (current) priority */</span>
	<span class="kt">int16_t</span>                         <span class="n">base_pri</span><span class="p">;</span>               <span class="cm">/* base priority */</span>
	<span class="kt">int16_t</span>                         <span class="n">max_priority</span><span class="p">;</span>           <span class="cm">/* copy of max base priority */</span>
	<span class="kt">int16_t</span>                         <span class="n">task_priority</span><span class="p">;</span>          <span class="cm">/* copy of task base priority */</span>

<span class="cp">#if defined(CONFIG_SCHED_GRRR)
</span><span class="c">#if 0
	uint16_t			grrr_deficit;		/* fixed point (1/1000th quantum) fractional deficit */
#endif
</span><span class="cp">#endif
</span>	
	<span class="kt">int16_t</span>				<span class="n">promotions</span><span class="p">;</span>			<span class="cm">/* level of promotion */</span>
	<span class="kt">int16_t</span>				<span class="n">pending_promoter_index</span><span class="p">;</span>
	<span class="k">_Atomic</span> <span class="kt">uint32_t</span>		<span class="n">ref_count</span><span class="p">;</span>		<span class="cm">/* number of references to me */</span>
	<span class="kt">void</span>				<span class="o">*</span><span class="n">pending_promoter</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="kt">uint32_t</span>			<span class="n">rwlock_count</span><span class="p">;</span>	<span class="cm">/* Number of lck_rw_t locks held by thread */</span>

	<span class="n">integer_t</span>			<span class="n">importance</span><span class="p">;</span>			<span class="cm">/* task-relative importance */</span>
	<span class="kt">uint32_t</span>                        <span class="n">was_promoted_on_wakeup</span><span class="p">;</span>

	<span class="cm">/* Priority depression expiration */</span>
	<span class="n">integer_t</span>			<span class="n">depress_timer_active</span><span class="p">;</span>
	<span class="n">timer_call_data_t</span>	<span class="n">depress_timer</span><span class="p">;</span>
										<span class="cm">/* real-time parameters */</span>
	<span class="k">struct</span> <span class="p">{</span>								<span class="cm">/* see mach/thread_policy.h */</span>
		<span class="kt">uint32_t</span>			<span class="n">period</span><span class="p">;</span>
		<span class="kt">uint32_t</span>			<span class="n">computation</span><span class="p">;</span>
		<span class="kt">uint32_t</span>			<span class="n">constraint</span><span class="p">;</span>
		<span class="n">boolean_t</span>			<span class="n">preemptible</span><span class="p">;</span>
		<span class="kt">uint64_t</span>			<span class="n">deadline</span><span class="p">;</span>
	<span class="p">}</span>					<span class="n">realtime</span><span class="p">;</span>

	<span class="kt">uint64_t</span>			<span class="n">last_run_time</span><span class="p">;</span>		<span class="cm">/* time when thread was switched away from */</span>
	<span class="kt">uint64_t</span>			<span class="n">last_made_runnable_time</span><span class="p">;</span>	<span class="cm">/* time when thread was unblocked or preempted */</span>
	<span class="kt">uint64_t</span>			<span class="n">last_basepri_change_time</span><span class="p">;</span>	<span class="cm">/* time when thread was last changed in basepri while runnable */</span>
	<span class="kt">uint64_t</span>			<span class="n">same_pri_latency</span><span class="p">;</span>
<span class="cp">#define THREAD_NOT_RUNNABLE (~0ULL)
</span>

<span class="cp">#if defined(CONFIG_SCHED_MULTIQ)
</span>	<span class="n">sched_group_t</span>			<span class="n">sched_group</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_SCHED_MULTIQ) */</span><span class="cp">
</span>
  <span class="cm">/* Data used during setrun/dispatch */</span>
	<span class="n">timer_data_t</span>		<span class="n">system_timer</span><span class="p">;</span>		<span class="cm">/* system mode timer */</span>
	<span class="n">processor_t</span>			<span class="n">bound_processor</span><span class="p">;</span>	<span class="cm">/* bound to a processor? */</span>
	<span class="n">processor_t</span>			<span class="n">last_processor</span><span class="p">;</span>		<span class="cm">/* processor last dispatched on */</span>
	<span class="n">processor_t</span>			<span class="n">chosen_processor</span><span class="p">;</span>	<span class="cm">/* Where we want to run this thread */</span>

	<span class="cm">/* Fail-safe computation since last unblock or qualifying yield */</span>
	<span class="kt">uint64_t</span>			<span class="n">computation_metered</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">computation_epoch</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">safe_release</span><span class="p">;</span>	<span class="cm">/* when to release fail-safe */</span>

	<span class="cm">/* Call out from scheduler */</span>
	<span class="kt">void</span>				<span class="p">(</span><span class="o">*</span><span class="n">sched_call</span><span class="p">)(</span>
							<span class="kt">int</span>			<span class="n">type</span><span class="p">,</span>
							<span class="n">thread_t</span>	<span class="kr">thread</span><span class="p">);</span>
<span class="cp">#if defined(CONFIG_SCHED_PROTO)
</span>	<span class="kt">uint32_t</span>			<span class="n">runqueue_generation</span><span class="p">;</span>	<span class="cm">/* last time runqueue was drained */</span>
<span class="cp">#endif
</span>	
	<span class="cm">/* Statistics and timesharing calculations */</span>
<span class="cp">#if defined(CONFIG_SCHED_TIMESHARE_CORE)
</span>	<span class="n">natural_t</span>			<span class="n">sched_stamp</span><span class="p">;</span>	<span class="cm">/* last scheduler tick */</span>
	<span class="n">natural_t</span>			<span class="n">sched_usage</span><span class="p">;</span>	<span class="cm">/* timesharing cpu usage [sched] */</span>
	<span class="n">natural_t</span>			<span class="n">pri_shift</span><span class="p">;</span>		<span class="cm">/* usage -&gt; priority from pset */</span>
	<span class="n">natural_t</span>			<span class="n">cpu_usage</span><span class="p">;</span>		<span class="cm">/* instrumented cpu usage [%cpu] */</span>
	<span class="n">natural_t</span>			<span class="n">cpu_delta</span><span class="p">;</span>		<span class="cm">/* accumulated cpu_usage delta */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SCHED_TIMESHARE_CORE */</span><span class="cp">
</span>
	<span class="kt">uint32_t</span>			<span class="n">c_switch</span><span class="p">;</span>		<span class="cm">/* total context switches */</span>
	<span class="kt">uint32_t</span>			<span class="n">p_switch</span><span class="p">;</span>		<span class="cm">/* total processor switches */</span>
	<span class="kt">uint32_t</span>			<span class="n">ps_switch</span><span class="p">;</span>		<span class="cm">/* total pset switches */</span>

	<span class="n">integer_t</span> <span class="n">mutex_count</span><span class="p">;</span>  <span class="cm">/* total count of locks held */</span>
	<span class="cm">/* Timing data structures */</span>
	<span class="kt">int</span>					<span class="n">precise_user_kernel_time</span><span class="p">;</span> <span class="cm">/* precise user/kernel enabled for this thread */</span>
	<span class="n">timer_data_t</span>		<span class="n">user_timer</span><span class="p">;</span>			<span class="cm">/* user mode timer */</span>
	<span class="kt">uint64_t</span>			<span class="n">user_timer_save</span><span class="p">;</span>	<span class="cm">/* saved user timer value */</span>
	<span class="kt">uint64_t</span>			<span class="n">system_timer_save</span><span class="p">;</span>	<span class="cm">/* saved system timer value */</span>
	<span class="kt">uint64_t</span>			<span class="n">vtimer_user_save</span><span class="p">;</span>	<span class="cm">/* saved values for vtimers */</span>
	<span class="kt">uint64_t</span>			<span class="n">vtimer_prof_save</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">vtimer_rlim_save</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">vtimer_qos_save</span><span class="p">;</span>

	<span class="n">timer_data_t</span>		<span class="n">ptime</span><span class="p">;</span>			<span class="cm">/* time executing in P mode */</span>

<span class="cp">#if CONFIG_SCHED_SFI
</span>	<span class="cm">/* Timing for wait state */</span>
	<span class="kt">uint64_t</span>		<span class="n">wait_sfi_begin_time</span><span class="p">;</span>    <span class="cm">/* start time for thread waiting in SFI */</span>
<span class="cp">#endif
</span>
	<span class="cm">/* Timed wait expiration */</span>
	<span class="n">timer_call_data_t</span>	<span class="n">wait_timer</span><span class="p">;</span>
	<span class="n">integer_t</span>			<span class="n">wait_timer_active</span><span class="p">;</span>
	<span class="n">boolean_t</span>			<span class="n">wait_timer_is_set</span><span class="p">;</span>


	<span class="cm">/*
	 * Processor/cache affinity
	 * - affinity_threads links task threads with the same affinity set
	 */</span>
	<span class="n">affinity_set_t</span>			<span class="n">affinity_set</span><span class="p">;</span>
	<span class="n">queue_chain_t</span>			<span class="n">affinity_threads</span><span class="p">;</span>

	<span class="cm">/* Various bits of state to stash across a continuation, exclusive to the current thread block point */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
		  	<span class="n">mach_msg_return_t</span>	<span class="n">state</span><span class="p">;</span>		<span class="cm">/* receive state */</span>
			<span class="n">mach_port_seqno_t</span>	<span class="n">seqno</span><span class="p">;</span>		<span class="cm">/* seqno of recvd message */</span>
		  	<span class="n">ipc_object_t</span>		<span class="n">object</span><span class="p">;</span>		<span class="cm">/* object received on */</span>
		  	<span class="n">mach_vm_address_t</span>	<span class="n">msg_addr</span><span class="p">;</span>	<span class="cm">/* receive buffer pointer */</span>
			<span class="n">mach_msg_size_t</span>		<span class="n">rsize</span><span class="p">;</span>		<span class="cm">/* max size for recvd msg */</span>
			<span class="n">mach_msg_size_t</span>		<span class="n">msize</span><span class="p">;</span>		<span class="cm">/* actual size for recvd msg */</span>
		  	<span class="n">mach_msg_option_t</span>	<span class="n">option</span><span class="p">;</span>		<span class="cm">/* options for receive */</span>
			<span class="n">mach_port_name_t</span>	<span class="n">receiver_name</span><span class="p">;</span>	<span class="cm">/* the receive port name */</span>
			<span class="k">struct</span> <span class="n">knote</span>		<span class="o">*</span><span class="n">knote</span><span class="p">;</span>		<span class="cm">/* knote fired for rcv */</span>
			<span class="k">union</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">ipc_kmsg</span>   <span class="o">*</span><span class="n">kmsg</span><span class="p">;</span>	<span class="cm">/* received message */</span>
				<span class="k">struct</span> <span class="n">ipc_mqueue</span> <span class="o">*</span><span class="n">peekq</span><span class="p">;</span>	<span class="cm">/* mqueue to peek at */</span>
				<span class="k">struct</span> <span class="p">{</span>
					<span class="n">mach_msg_priority_t</span> <span class="n">qos</span><span class="p">;</span>	<span class="cm">/* received message qos */</span>
					<span class="n">mach_msg_priority_t</span> <span class="n">oqos</span><span class="p">;</span>	<span class="cm">/* override qos for message */</span>
				<span class="p">}</span> <span class="n">received_qos</span><span class="p">;</span>
			<span class="p">};</span>
			<span class="n">mach_msg_continue_t</span>	<span class="n">continuation</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">receive</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">semaphore</span>	<span class="o">*</span><span class="n">waitsemaphore</span><span class="p">;</span>  	<span class="cm">/* semaphore ref */</span>
			<span class="k">struct</span> <span class="n">semaphore</span>	<span class="o">*</span><span class="n">signalsemaphore</span><span class="p">;</span>	<span class="cm">/* semaphore ref */</span>
			<span class="kt">int</span>					<span class="n">options</span><span class="p">;</span>			<span class="cm">/* semaphore options */</span>
			<span class="n">kern_return_t</span>		<span class="n">result</span><span class="p">;</span>				<span class="cm">/* primary result */</span>
			<span class="n">mach_msg_continue_t</span> <span class="n">continuation</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">sema</span><span class="p">;</span>
	  	<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">int</span>					<span class="n">option</span><span class="p">;</span>		<span class="cm">/* switch option */</span>
			<span class="n">boolean_t</span>				<span class="n">reenable_workq_callback</span><span class="p">;</span>	<span class="cm">/* on entry, callbacks were suspended */</span>
		<span class="p">}</span> <span class="n">swtch</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">saved</span><span class="p">;</span>

	<span class="cm">/* Only user threads can cause guard exceptions, only kernel threads can be thread call threads */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="cm">/* Group and call this thread is working on behalf of */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">thread_call_group</span> <span class="o">*</span> <span class="n">thc_group</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">thread_call</span> <span class="o">*</span>       <span class="n">thc_call</span><span class="p">;</span>                    <span class="cm">/* debug only, may be deallocated */</span>
		<span class="p">}</span> <span class="n">thc_state</span><span class="p">;</span>

		<span class="cm">/* Structure to save information about guard exception */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">mach_exception_code_t</span>           <span class="n">code</span><span class="p">;</span>
			<span class="n">mach_exception_subcode_t</span>        <span class="n">subcode</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">guard_exc_info</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="cm">/* Kernel holds on this thread  */</span>
	<span class="kt">int16_t</span>                                         <span class="n">suspend_count</span><span class="p">;</span>
	<span class="cm">/* User level suspensions */</span>
	<span class="kt">int16_t</span>                                         <span class="n">user_stop_count</span><span class="p">;</span>

	<span class="cm">/* IPC data structures */</span>
<span class="cp">#if IMPORTANCE_INHERITANCE
</span>	<span class="n">natural_t</span> <span class="n">ith_assertions</span><span class="p">;</span>			<span class="cm">/* assertions pending drop */</span>
<span class="cp">#endif
</span>	<span class="k">struct</span> <span class="n">ipc_kmsg_queue</span> <span class="n">ith_messages</span><span class="p">;</span>		<span class="cm">/* messages to reap */</span>
	<span class="n">mach_port_t</span> <span class="n">ith_rpc_reply</span><span class="p">;</span>			<span class="cm">/* reply port for kernel RPCs */</span>

	<span class="cm">/* Ast/Halt data structures */</span>
	<span class="n">vm_offset_t</span>					<span class="n">recover</span><span class="p">;</span>		<span class="cm">/* page fault recover(copyin/out) */</span>

	<span class="n">queue_chain_t</span>				<span class="n">threads</span><span class="p">;</span>		<span class="cm">/* global list of all threads */</span>

	<span class="cm">/* Activation */</span>
		<span class="n">queue_chain_t</span>			<span class="n">task_threads</span><span class="p">;</span>

		<span class="cm">/* Task membership */</span>
		<span class="k">struct</span> <span class="n">task</span>				<span class="o">*</span><span class="n">task</span><span class="p">;</span>
		<span class="n">vm_map_t</span>				<span class="n">map</span><span class="p">;</span>

		<span class="n">decl_lck_mtx_data</span><span class="p">(,</span><span class="n">mutex</span><span class="p">)</span>


		<span class="cm">/* Pending thread ast(s) */</span>
		<span class="n">ast_t</span>					<span class="n">ast</span><span class="p">;</span>

		<span class="cm">/* Miscellaneous bits guarded by mutex */</span>
		<span class="kt">uint32_t</span>
			<span class="nl">active:</span><span class="mi">1</span><span class="p">,</span>                       <span class="cm">/* Thread is active and has not been terminated */</span>
			<span class="nl">started:</span><span class="mi">1</span><span class="p">,</span>                      <span class="cm">/* Thread has been started after creation */</span>
			<span class="nl">static_param:</span><span class="mi">1</span><span class="p">,</span>                 <span class="cm">/* Disallow policy parameter changes */</span>
			<span class="nl">inspection:</span><span class="mi">1</span><span class="p">,</span>                   <span class="cm">/* TRUE when task is being inspected by crash reporter */</span>
			<span class="nl">policy_reset:</span><span class="mi">1</span><span class="p">,</span>                 <span class="cm">/* Disallow policy parameter changes on terminating threads */</span>
			<span class="nl">suspend_parked:</span><span class="mi">1</span><span class="p">,</span>               <span class="cm">/* thread parked in thread_suspended */</span>
			<span class="nl">corpse_dup:</span><span class="mi">1</span><span class="p">,</span>                   <span class="cm">/* TRUE when thread is an inactive duplicate in a corpse */</span>
			<span class="o">:</span><span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Ports associated with this thread */</span>
		<span class="k">struct</span> <span class="n">ipc_port</span>			<span class="o">*</span><span class="n">ith_self</span><span class="p">;</span>		<span class="cm">/* not a right, doesn't hold ref */</span>
		<span class="k">struct</span> <span class="n">ipc_port</span>			<span class="o">*</span><span class="n">ith_sself</span><span class="p">;</span>		<span class="cm">/* a send right */</span>
		<span class="k">struct</span> <span class="n">ipc_port</span>			<span class="o">*</span><span class="n">ith_special_reply_port</span><span class="p">;</span> <span class="cm">/* ref to special reply port */</span>
		<span class="k">struct</span> <span class="n">exception_action</span>	<span class="o">*</span><span class="n">exc_actions</span><span class="p">;</span>

<span class="cp">#ifdef	MACH_BSD
</span>		<span class="kt">void</span>					<span class="o">*</span><span class="n">uthread</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#if CONFIG_DTRACE
</span>		<span class="kt">uint32_t</span> <span class="n">t_dtrace_flags</span><span class="p">;</span>	<span class="cm">/* DTrace thread states */</span>
<span class="cp">#define	TH_DTRACE_EXECSUCCESS	0x01
</span>		<span class="kt">uint32_t</span> <span class="n">t_dtrace_predcache</span><span class="p">;</span><span class="cm">/* DTrace per thread predicate value hint */</span>
		<span class="kt">int64_t</span> <span class="n">t_dtrace_tracing</span><span class="p">;</span>       <span class="cm">/* Thread time under dtrace_probe() */</span>
		<span class="kt">int64_t</span> <span class="n">t_dtrace_vtime</span><span class="p">;</span>
<span class="cp">#endif
</span>
	        <span class="n">clock_sec_t</span> <span class="n">t_page_creation_time</span><span class="p">;</span>
	        <span class="kt">uint32_t</span>    <span class="n">t_page_creation_count</span><span class="p">;</span>
	        <span class="kt">uint32_t</span>    <span class="n">t_page_creation_throttled</span><span class="p">;</span>
<span class="cp">#if (DEVELOPMENT || DEBUG)
</span>	        <span class="kt">uint64_t</span>    <span class="n">t_page_creation_throttled_hard</span><span class="p">;</span>
	        <span class="kt">uint64_t</span>    <span class="n">t_page_creation_throttled_soft</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* DEVELOPMENT || DEBUG */</span><span class="cp">
</span>
<span class="cp">#ifdef KPERF
</span><span class="cm">/* The high 7 bits are the number of frames to sample of a user callstack. */</span>
<span class="cp">#define T_KPERF_CALLSTACK_DEPTH_OFFSET     (25)
#define T_KPERF_SET_CALLSTACK_DEPTH(DEPTH) (((uint32_t)(DEPTH)) &lt;&lt; T_KPERF_CALLSTACK_DEPTH_OFFSET)
#define T_KPERF_GET_CALLSTACK_DEPTH(FLAGS) ((FLAGS) &gt;&gt; T_KPERF_CALLSTACK_DEPTH_OFFSET)
#endif
</span>
<span class="cp">#define T_KPERF_AST_CALLSTACK (1U &lt;&lt; 0) </span><span class="cm">/* dump a callstack on thread's next AST */</span><span class="cp">
#define T_KPERF_AST_DISPATCH  (1U &lt;&lt; 1) </span><span class="cm">/* dump a name on thread's next AST */</span><span class="cp">
#define T_KPC_ALLOC           (1U &lt;&lt; 2) </span><span class="cm">/* thread needs a kpc_buf allocated */</span><span class="cp">
</span><span class="cm">/* only go up to T_KPERF_CALLSTACK_DEPTH_OFFSET - 1 */</span>

<span class="cp">#ifdef KPERF
</span>	<span class="kt">uint32_t</span> <span class="n">kperf_flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">kperf_pet_gen</span><span class="p">;</span>  <span class="cm">/* last generation of PET that sampled this thread*/</span>
	<span class="kt">uint32_t</span> <span class="n">kperf_c_switch</span><span class="p">;</span> <span class="cm">/* last dispatch detection */</span>
	<span class="kt">uint32_t</span> <span class="n">kperf_pet_cnt</span><span class="p">;</span>  <span class="cm">/* how many times a thread has been sampled by PET */</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef KPC
</span>	<span class="cm">/* accumulated performance counters for this thread */</span>
	<span class="kt">uint64_t</span> <span class="o">*</span><span class="n">kpc_buf</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#if HYPERVISOR
</span>	<span class="cm">/* hypervisor virtual CPU object associated with this thread */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">hv_thread_target</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* HYPERVISOR */</span><span class="cp">
</span>
		<span class="kt">uint64_t</span> <span class="n">thread_id</span><span class="p">;</span>	<span class="cm">/*system wide unique thread-id*/</span>

	<span class="cm">/* Statistics accumulated per-thread and aggregated per-task */</span>
	<span class="kt">uint32_t</span>		<span class="n">syscalls_unix</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">syscalls_mach</span><span class="p">;</span>
	<span class="n">ledger_t</span>		<span class="n">t_ledger</span><span class="p">;</span>
	<span class="n">ledger_t</span>		<span class="n">t_threadledger</span><span class="p">;</span>	<span class="cm">/* per thread ledger */</span>
	<span class="n">ledger_t</span>		<span class="n">t_bankledger</span><span class="p">;</span>  		     <span class="cm">/* ledger to charge someone */</span>
	<span class="kt">uint64_t</span>		<span class="n">t_deduct_bank_ledger_time</span><span class="p">;</span>   <span class="cm">/* cpu time to be deducted from bank ledger */</span>
	<span class="kt">uint64_t</span>		<span class="n">t_deduct_bank_ledger_energy</span><span class="p">;</span> <span class="cm">/* energy to be deducted from bank ledger */</span>

<span class="cp">#if MONOTONIC
</span>	<span class="k">struct</span> <span class="n">mt_thread</span> <span class="n">t_monotonic</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* MONOTONIC */</span><span class="cp">
</span>
	<span class="cm">/*** Machine-dependent state ***/</span>
	<span class="k">struct</span> <span class="n">machine_thread</span>   <span class="n">machine</span><span class="p">;</span>

	<span class="cm">/* policy is protected by the thread mutex */</span>
	<span class="k">struct</span> <span class="n">thread_requested_policy</span>  <span class="n">requested_policy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">thread_effective_policy</span>  <span class="n">effective_policy</span><span class="p">;</span>

	<span class="cm">/* usynch override is protected by the task lock, eventually will be thread mutex */</span>
	<span class="k">struct</span> <span class="n">thread_qos_override</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">thread_qos_override</span>	<span class="o">*</span><span class="n">override_next</span><span class="p">;</span>
		<span class="kt">uint32_t</span>	<span class="n">override_contended_resource_count</span><span class="p">;</span>
		<span class="kt">int16_t</span>		<span class="n">override_qos</span><span class="p">;</span>
		<span class="kt">int16_t</span>		<span class="n">override_resource_type</span><span class="p">;</span>
		<span class="n">user_addr_t</span>	<span class="n">override_resource</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">overrides</span><span class="p">;</span>

	<span class="k">_Atomic</span> <span class="kt">uint32_t</span> <span class="n">kqwl_owning_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span>        <span class="n">ipc_overrides</span><span class="p">;</span>
	<span class="kt">uint32_t</span>        <span class="n">sync_ipc_overrides</span><span class="p">;</span>
	<span class="kt">uint32_t</span>        <span class="n">user_promotions</span><span class="p">;</span>
	<span class="kt">uint16_t</span>        <span class="n">user_promotion_basepri</span><span class="p">;</span>
	<span class="k">_Atomic</span> <span class="kt">uint16_t</span> <span class="n">kevent_ast_bits</span><span class="p">;</span>

	<span class="n">block_hint_t</span>    <span class="n">pending_block_hint</span><span class="p">;</span>
	<span class="n">block_hint_t</span>    <span class="n">block_hint</span><span class="p">;</span>      <span class="cm">/* What type of primitive last caused us to block. */</span>

	<span class="kt">int</span>	<span class="n">iotier_override</span><span class="p">;</span> <span class="cm">/* atomic operations to set, cleared on ret to user */</span>
	<span class="n">io_stat_info_t</span>  		<span class="n">thread_io_stats</span><span class="p">;</span> <span class="cm">/* per-thread I/O statistics */</span>

<span class="cp">#if CONFIG_EMBEDDED
</span>	<span class="n">task_watch_t</span> <span class="o">*</span>	<span class="n">taskwatch</span><span class="p">;</span>		<span class="cm">/* task watch */</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_EMBEDDED */</span><span class="cp">
</span>
	<span class="kt">uint32_t</span>			<span class="n">thread_callout_interrupt_wakeups</span><span class="p">;</span>
	<span class="kt">uint32_t</span>			<span class="n">thread_callout_platform_idle_wakeups</span><span class="p">;</span>
	<span class="kt">uint32_t</span>			<span class="n">thread_timer_wakeups_bin_1</span><span class="p">;</span>
	<span class="kt">uint32_t</span>			<span class="n">thread_timer_wakeups_bin_2</span><span class="p">;</span>
	<span class="kt">uint16_t</span>			<span class="n">thread_tag</span><span class="p">;</span>
	<span class="kt">uint16_t</span>			<span class="n">callout_woken_from_icontext</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">callout_woken_from_platform_idle:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">callout_woke_thread:</span><span class="mi">1</span><span class="p">,</span>
					<span class="nl">thread_bitfield_unused:</span><span class="mi">13</span><span class="p">;</span>

	<span class="n">mach_port_name_t</span>		<span class="n">ith_voucher_name</span><span class="p">;</span>
	<span class="n">ipc_voucher_t</span>			<span class="n">ith_voucher</span><span class="p">;</span>
<span class="cp">#if CONFIG_IOSCHED
</span>	<span class="kt">void</span> 				<span class="o">*</span><span class="n">decmp_upl</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_IOSCHED */</span><span class="cp">
</span>
	<span class="cm">/* work interval (if any) associated with the thread. Uses thread mutex */</span>
	<span class="k">struct</span> <span class="n">work_interval</span>            <span class="o">*</span><span class="n">th_work_interval</span><span class="p">;</span>

<span class="cp">#if	SCHED_TRACE_THREAD_WAKEUPS
</span>	<span class="kt">uintptr_t</span>		<span class="n">thread_wakeup_bt</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div>

<p>이처럼 thread의 structure는 굉장히 방대하기 때문에 대부분의 thread는 structure를 default value로 채우는 generic template <em>( osfmk/thread/thread.c - thread_template)</em> 을 복제하여 생성한다. 이 template은 thread_bootstrap() 에 의해 채워지며 thread_create() Mach API를 구현하는 thread_create_internal() 에서 복사된다.</p>

<p>관심있는 특정 필드중 하나는 <strong>uthread</strong> member로, 이것은 BSD layer에 대한 void pointer 이다. 이 멤버는 BSD user thread를 pointing 한다.</p>

<p>thread는 여러가지 field로 가득 차있지만 실제 resource reference는 포함하지 않는다. Mach은 task를 thread의 container로 정의하여 resource를 handle하게 한다. <br />
thread는 port를 통해서 자신을 contain 하는 task에게 할당된 memory와 resource에만 access 할 수 있다.</p>

<h3 id="tasks">Tasks</h3>

<p>task는 가상 메모리 공간과 device 및 기타 handle 등의 resource를 관리하는 container object 역할을 한다. port에 의해 resource는 더욱 추상화 되므로 resource를 공유하려면 해당 port에 대한 access를 제공해야 한다.</p>

<p>엄밀히 말하면 micro kernel인 Mach은 process logic을 제공하지 않고 골자만 제공하므로 다른 운영체제의 process와는 다르다. 그러나 BSD model에서 두 개념 사이에 간단한 1:1 매핑이 존재하며 모든 BSD process에는 이와 관련된 underlying Mach task object가 있다. 이 매핑은 Mach이 알 수 없는 opaque pointer인 <strong>bsd_info</strong>를 정하여 수행된다. Mach은 비록 해당하는 PID는 없지만(기술적으로 PID 0로 생각) kernel도 task로 나타낸다(global하게 <strong>kernel_task</strong>로 referred).</p>

<p>task는 다음에서 볼 수 있듯 thread와 비교하여 비교적 lightweight structure이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">task</span> <span class="p">{</span>
	<span class="cm">/* Synchronization/destruction information */</span>
	<span class="n">decl_lck_mtx_data</span><span class="p">(,</span><span class="n">lock</span><span class="p">)</span>		<span class="cm">/* Task's lock */</span>
	<span class="k">_Atomic</span> <span class="kt">uint32_t</span>	<span class="n">ref_count</span><span class="p">;</span>	<span class="cm">/* Number of references to me */</span>
	<span class="n">boolean_t</span>	<span class="n">active</span><span class="p">;</span>		<span class="cm">/* Task has not been terminated */</span>
	<span class="n">boolean_t</span>	<span class="n">halting</span><span class="p">;</span>	<span class="cm">/* Task is being halted */</span>

	<span class="cm">/* Miscellaneous */</span>
	<span class="n">vm_map_t</span>	<span class="n">map</span><span class="p">;</span>		<span class="cm">/* Address space description */</span>
	<span class="n">queue_chain_t</span>	<span class="n">tasks</span><span class="p">;</span>	<span class="cm">/* global list of tasks */</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">user_data</span><span class="p">;</span>	<span class="cm">/* Arbitrary data settable via IPC */</span>

<span class="cp">#if defined(CONFIG_SCHED_MULTIQ)
</span>	<span class="n">sched_group_t</span> <span class="n">sched_group</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_SCHED_MULTIQ) */</span><span class="cp">
</span>
	<span class="cm">/* Threads in this task */</span>
	<span class="n">queue_head_t</span>		<span class="n">threads</span><span class="p">;</span>

	<span class="n">processor_set_t</span>		<span class="n">pset_hint</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">affinity_space</span>	<span class="o">*</span><span class="n">affinity_space</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">thread_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">active_thread_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">suspend_count</span><span class="p">;</span>	<span class="cm">/* Internal scheduling only */</span>

	<span class="cm">/* User-visible scheduling information */</span>
	<span class="n">integer_t</span>		<span class="n">user_stop_count</span><span class="p">;</span>	<span class="cm">/* outstanding stops */</span>
	<span class="n">integer_t</span>		<span class="n">legacy_stop_count</span><span class="p">;</span>	<span class="cm">/* outstanding legacy stops */</span>

	<span class="n">integer_t</span>		<span class="n">priority</span><span class="p">;</span>			<span class="cm">/* base priority for threads */</span>
	<span class="n">integer_t</span>		<span class="n">max_priority</span><span class="p">;</span>		<span class="cm">/* maximum priority for threads */</span>

	<span class="n">integer_t</span>		<span class="n">importance</span><span class="p">;</span>		<span class="cm">/* priority offset (BSD 'nice' value) */</span>

	<span class="cm">/* Task security and audit tokens */</span>
	<span class="n">security_token_t</span> <span class="n">sec_token</span><span class="p">;</span>
	<span class="n">audit_token_t</span>	<span class="n">audit_token</span><span class="p">;</span>
        
	<span class="cm">/* Statistics */</span>
	<span class="kt">uint64_t</span>		<span class="n">total_user_time</span><span class="p">;</span>	<span class="cm">/* terminated threads only */</span>
	<span class="kt">uint64_t</span>		<span class="n">total_system_time</span><span class="p">;</span>
	<span class="kt">uint64_t</span>		<span class="n">total_ptime</span><span class="p">;</span>
	
	<span class="cm">/* Virtual timers */</span>
	<span class="kt">uint32_t</span>		<span class="n">vtimers</span><span class="p">;</span>

	<span class="cm">/* IPC structures */</span>
	<span class="n">decl_lck_mtx_data</span><span class="p">(,</span><span class="n">itk_lock_data</span><span class="p">)</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_self</span><span class="p">;</span>	<span class="cm">/* not a right, doesn't hold ref */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_nself</span><span class="p">;</span>	<span class="cm">/* not a right, doesn't hold ref */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_sself</span><span class="p">;</span>	<span class="cm">/* a send right */</span>
	<span class="k">struct</span> <span class="n">exception_action</span> <span class="n">exc_actions</span><span class="p">[</span><span class="n">EXC_TYPES_COUNT</span><span class="p">];</span>
		 			<span class="cm">/* a send right each valid element  */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_host</span><span class="p">;</span>	<span class="cm">/* a send right */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_bootstrap</span><span class="p">;</span>	<span class="cm">/* a send right */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_seatbelt</span><span class="p">;</span>	<span class="cm">/* a send right */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_gssd</span><span class="p">;</span>	<span class="cm">/* yet another send right */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_debug_control</span><span class="p">;</span> <span class="cm">/* send right for debugmode communications */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_task_access</span><span class="p">;</span> <span class="cm">/* and another send right */</span> 
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_resume</span><span class="p">;</span>	<span class="cm">/* a receive right to resume this task */</span>
	<span class="k">struct</span> <span class="n">ipc_port</span> <span class="o">*</span><span class="n">itk_registered</span><span class="p">[</span><span class="n">TASK_PORT_REGISTER_MAX</span><span class="p">];</span>
					<span class="cm">/* all send rights */</span>

	<span class="k">struct</span> <span class="n">ipc_space</span> <span class="o">*</span><span class="n">itk_space</span><span class="p">;</span>

	<span class="cm">/* Synchronizer ownership information */</span>
	<span class="n">queue_head_t</span>	<span class="n">semaphore_list</span><span class="p">;</span>		<span class="cm">/* list of owned semaphores   */</span>
	<span class="kt">int</span>		<span class="n">semaphores_owned</span><span class="p">;</span>	<span class="cm">/* number of semaphores owned */</span>

	<span class="n">ledger_t</span>	<span class="n">ledger</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">priv_flags</span><span class="p">;</span>			<span class="cm">/* privilege resource flags */</span>
<span class="cp">#define VM_BACKING_STORE_PRIV	0x1
</span>
	<span class="n">MACHINE_TASK</span>
        
	<span class="n">integer_t</span> <span class="n">faults</span><span class="p">;</span>              <span class="cm">/* faults counter */</span>
        <span class="n">integer_t</span> <span class="n">pageins</span><span class="p">;</span>             <span class="cm">/* pageins counter */</span>
        <span class="n">integer_t</span> <span class="n">cow_faults</span><span class="p">;</span>          <span class="cm">/* copy on write fault counter */</span>
        <span class="n">integer_t</span> <span class="n">messages_sent</span><span class="p">;</span>       <span class="cm">/* messages sent counter */</span>
        <span class="n">integer_t</span> <span class="n">messages_received</span><span class="p">;</span>   <span class="cm">/* messages received counter */</span>
        <span class="n">integer_t</span> <span class="n">syscalls_mach</span><span class="p">;</span>       <span class="cm">/* mach system call counter */</span>
        <span class="n">integer_t</span> <span class="n">syscalls_unix</span><span class="p">;</span>       <span class="cm">/* unix system call counter */</span>
		<span class="kt">uint32_t</span>  <span class="n">c_switch</span><span class="p">;</span>			   <span class="cm">/* total context switches */</span>
		<span class="kt">uint32_t</span>  <span class="n">p_switch</span><span class="p">;</span>			   <span class="cm">/* total processor switches */</span>
		<span class="kt">uint32_t</span>  <span class="n">ps_switch</span><span class="p">;</span>		   <span class="cm">/* total pset switches */</span>

<span class="cp">#ifdef  MACH_BSD 
</span>	<span class="kt">void</span> <span class="o">*</span><span class="n">bsd_info</span><span class="p">;</span>
<span class="cp">#endif  
</span>	<span class="n">kcdata_descriptor_t</span>		<span class="n">corpse_info</span><span class="p">;</span>
	<span class="kt">uint64_t</span>			<span class="n">crashed_thread_id</span><span class="p">;</span>
	<span class="n">queue_chain_t</span>			<span class="n">corpse_tasks</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_MACF
</span>	<span class="k">struct</span> <span class="n">label</span> <span class="o">*</span>			<span class="n">crash_label</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="k">struct</span> <span class="n">vm_shared_region</span>		<span class="o">*</span><span class="n">shared_region</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">t_flags</span><span class="p">;</span>                                      <span class="cm">/* general-purpose task flags protected by task_lock (TL) */</span>
<span class="cp">#define TF_NONE                 0
#define TF_64B_ADDR             0x00000001                              </span><span class="cm">/* task has 64-bit addressing */</span><span class="cp">
#define TF_64B_DATA             0x00000002                              </span><span class="cm">/* task has 64-bit data registers */</span><span class="cp">
#define TF_CPUMON_WARNING       0x00000004                              </span><span class="cm">/* task has at least one thread in CPU usage warning zone */</span><span class="cp">
#define TF_WAKEMON_WARNING      0x00000008                              </span><span class="cm">/* task is in wakeups monitor warning zone */</span><span class="cp">
#define TF_TELEMETRY            (TF_CPUMON_WARNING | TF_WAKEMON_WARNING) </span><span class="cm">/* task is a telemetry participant */</span><span class="cp">
#define TF_GPU_DENIED           0x00000010                              </span><span class="cm">/* task is not allowed to access the GPU */</span><span class="cp">
#define TF_CORPSE               0x00000020                              </span><span class="cm">/* task is a corpse */</span><span class="cp">
#define TF_PENDING_CORPSE       0x00000040                              </span><span class="cm">/* task corpse has not been reported yet */</span><span class="cp">
#define TF_CORPSE_FORK          0x00000080                              </span><span class="cm">/* task is a forked corpse */</span><span class="cp">
#define TF_LRETURNWAIT          0x00000100                              </span><span class="cm">/* task is waiting for fork/posix_spawn/exec to complete */</span><span class="cp">
#define TF_LRETURNWAITER        0x00000200                              </span><span class="cm">/* task is waiting for TF_LRETURNWAIT to get cleared */</span><span class="cp">
#define TF_PLATFORM             0x00000400                              </span><span class="cm">/* task is a platform binary */</span><span class="cp">
#define TF_CA_CLIENT_WI         0x00000800                              </span><span class="cm">/* task has CA_CLIENT work interval */</span><span class="cp">
</span>
<span class="cp">#define task_has_64BitAddr(task)	\
	 (((task)-&gt;t_flags &amp; TF_64B_ADDR) != 0)
#define task_set_64BitAddr(task)	\
	 ((task)-&gt;t_flags |= TF_64B_ADDR)
#define task_clear_64BitAddr(task)	\
	 ((task)-&gt;t_flags &amp;= ~TF_64B_ADDR)
#define task_has_64BitData(task)    \
	 (((task)-&gt;t_flags &amp; TF_64B_DATA) != 0)
</span>
<span class="cp">#define task_is_a_corpse(task)      \
	 (((task)-&gt;t_flags &amp; TF_CORPSE) != 0)
</span>
<span class="cp">#define task_set_corpse(task)       \
	 ((task)-&gt;t_flags |= TF_CORPSE)
</span>
<span class="cp">#define task_corpse_pending_report(task) 	\
	 (((task)-&gt;t_flags &amp; TF_PENDING_CORPSE) != 0)
</span>
<span class="cp">#define task_set_corpse_pending_report(task)       \
	 ((task)-&gt;t_flags |= TF_PENDING_CORPSE)
</span>
<span class="cp">#define task_clear_corpse_pending_report(task)       \
	 ((task)-&gt;t_flags &amp;= ~TF_PENDING_CORPSE)
</span>
<span class="cp">#define task_is_a_corpse_fork(task)	\
	(((task)-&gt;t_flags &amp; TF_CORPSE_FORK) != 0)
</span>
	<span class="kt">uint32_t</span> <span class="n">t_procflags</span><span class="p">;</span>                                            <span class="cm">/* general-purpose task flags protected by proc_lock (PL) */</span>
<span class="cp">#define TPF_NONE                 0
#define TPF_DID_EXEC             0x00000001                              </span><span class="cm">/* task has been execed to a new task */</span><span class="cp">
#define TPF_EXEC_COPY            0x00000002                              </span><span class="cm">/* task is the new copy of an exec */</span><span class="cp">
#ifdef CONFIG_32BIT_TELEMETRY
#define TPF_LOG_32BIT_TELEMETRY  0x00000004                              </span><span class="cm">/* task should log identifying information */</span><span class="cp">
#endif
</span>
<span class="cp">#define task_did_exec_internal(task)		\
	(((task)-&gt;t_procflags &amp; TPF_DID_EXEC) != 0)
</span>
<span class="cp">#define task_is_exec_copy_internal(task)	\
	(((task)-&gt;t_procflags &amp; TPF_EXEC_COPY) != 0)
</span>
	<span class="n">mach_vm_address_t</span>	<span class="n">all_image_info_addr</span><span class="p">;</span> <span class="cm">/* dyld __all_image_info     */</span>
	<span class="n">mach_vm_size_t</span>		<span class="n">all_image_info_size</span><span class="p">;</span> <span class="cm">/* section location and size */</span>

<span class="cp">#if KPC
#define TASK_KPC_FORCED_ALL_CTRS	0x2	</span><span class="cm">/* Bit in "t_kpc" signifying this task forced all counters */</span><span class="cp">
</span>	<span class="kt">uint32_t</span> <span class="n">t_kpc</span><span class="p">;</span> <span class="cm">/* kpc flags */</span>
<span class="cp">#endif </span><span class="cm">/* KPC */</span><span class="cp">
</span>
	<span class="n">boolean_t</span> <span class="n">pidsuspended</span><span class="p">;</span> <span class="cm">/* pid_suspend called; no threads can execute */</span>
	<span class="n">boolean_t</span> <span class="n">frozen</span><span class="p">;</span>       <span class="cm">/* frozen; private resident pages committed to swap */</span>
	<span class="n">boolean_t</span> <span class="n">changing_freeze_state</span><span class="p">;</span>	<span class="cm">/* in the process of freezing or thawing */</span>
	<span class="kt">uint16_t</span> <span class="n">policy_ru_cpu</span>          <span class="o">:</span><span class="mi">4</span><span class="p">,</span>
	         <span class="n">policy_ru_cpu_ext</span>      <span class="o">:</span><span class="mi">4</span><span class="p">,</span>
	         <span class="n">applied_ru_cpu</span>         <span class="o">:</span><span class="mi">4</span><span class="p">,</span>
	         <span class="n">applied_ru_cpu_ext</span>     <span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">rusage_cpu_flags</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">rusage_cpu_percentage</span><span class="p">;</span>		<span class="cm">/* Task-wide CPU limit percentage */</span>
	<span class="kt">uint64_t</span> <span class="n">rusage_cpu_interval</span><span class="p">;</span>		<span class="cm">/* Task-wide CPU limit interval */</span>
	<span class="kt">uint8_t</span>  <span class="n">rusage_cpu_perthr_percentage</span><span class="p">;</span>  <span class="cm">/* Per-thread CPU limit percentage */</span>
	<span class="kt">uint64_t</span> <span class="n">rusage_cpu_perthr_interval</span><span class="p">;</span>    <span class="cm">/* Per-thread CPU limit interval */</span>
	<span class="kt">uint64_t</span> <span class="n">rusage_cpu_deadline</span><span class="p">;</span>
	<span class="n">thread_call_t</span> <span class="n">rusage_cpu_callt</span><span class="p">;</span>
<span class="cp">#if CONFIG_EMBEDDED
</span>	<span class="n">queue_head_t</span>	<span class="n">task_watchers</span><span class="p">;</span>		<span class="cm">/* app state watcher threads */</span>
	<span class="kt">int</span>	<span class="n">num_taskwatchers</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">watchapplying</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_EMBEDDED */</span><span class="cp">
</span>
<span class="cp">#if CONFIG_ATM
</span>	<span class="k">struct</span> <span class="n">atm_task_descriptor</span> <span class="o">*</span><span class="n">atm_context</span><span class="p">;</span>  <span class="cm">/* pointer to per task atm descriptor */</span>
<span class="cp">#endif
</span>	<span class="k">struct</span> <span class="n">bank_task</span> <span class="o">*</span><span class="n">bank_context</span><span class="p">;</span>  <span class="cm">/* pointer to per task bank structure */</span>

<span class="cp">#if IMPORTANCE_INHERITANCE
</span>	<span class="k">struct</span> <span class="n">ipc_importance_task</span>  <span class="o">*</span><span class="n">task_imp_base</span><span class="p">;</span>	<span class="cm">/* Base of IPC importance chain */</span>
<span class="cp">#endif </span><span class="cm">/* IMPORTANCE_INHERITANCE */</span><span class="cp">
</span>
	<span class="n">vm_extmod_statistics_data_t</span>	<span class="n">extmod_statistics</span><span class="p">;</span>

<span class="cp">#if MACH_ASSERT
</span>	<span class="kt">int8_t</span>		<span class="n">suspends_outstanding</span><span class="p">;</span>	<span class="cm">/* suspends this task performed in excess of resumes */</span>
<span class="cp">#endif
</span>
	<span class="k">struct</span> <span class="n">task_requested_policy</span> <span class="n">requested_policy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_effective_policy</span> <span class="n">effective_policy</span><span class="p">;</span>

	<span class="cm">/*
	 * Can be merged with imp_donor bits, once the IMPORTANCE_INHERITANCE macro goes away.
	 */</span>
	<span class="kt">uint32_t</span>        <span class="n">low_mem_notified_warn</span>		<span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* warning low memory notification is sent to the task */</span>
	                <span class="n">low_mem_notified_critical</span>	<span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* critical low memory notification is sent to the task */</span>
	                <span class="n">purged_memory_warn</span>		<span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* purgeable memory of the task is purged for warning level pressure */</span>
	                <span class="n">purged_memory_critical</span>		<span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* purgeable memory of the task is purged for critical level pressure */</span>
			<span class="n">low_mem_privileged_listener</span>	<span class="o">:</span><span class="mi">1</span><span class="p">,</span>	<span class="cm">/* if set, task would like to know about pressure changes before other tasks on the system */</span>
	                <span class="n">mem_notify_reserved</span>		<span class="o">:</span><span class="mi">27</span><span class="p">;</span>	<span class="cm">/* reserved for future use */</span>

	<span class="kt">uint32_t</span> <span class="n">memlimit_is_active</span>                 <span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/* if set, use active attributes, otherwise use inactive attributes */</span>
                <span class="n">memlimit_is_fatal</span>                   <span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/* if set, exceeding current memlimit will prove fatal to the task */</span>
		<span class="n">memlimit_active_exc_resource</span>        <span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/* if set, suppress exc_resource exception when task exceeds active memory limit */</span>
		<span class="n">memlimit_inactive_exc_resource</span>      <span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="cm">/* if set, suppress exc_resource exception when task exceeds inactive memory limit */</span>
		<span class="n">memlimit_attrs_reserved</span>             <span class="o">:</span><span class="mi">28</span><span class="p">;</span> <span class="cm">/* reserved for future use */</span>

	<span class="n">io_stat_info_t</span> 		<span class="n">task_io_stats</span><span class="p">;</span>
	<span class="kt">uint64_t</span> 		<span class="n">task_immediate_writes</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
	<span class="kt">uint64_t</span> 		<span class="n">task_deferred_writes</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
	<span class="kt">uint64_t</span> 		<span class="n">task_invalidated_writes</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
	<span class="kt">uint64_t</span> 		<span class="n">task_metadata_writes</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>

	<span class="cm">/* 
	 * The cpu_time_qos_stats fields are protected by the task lock
	 */</span>
	<span class="k">struct</span> <span class="n">_cpu_time_qos_stats</span> 	<span class="n">cpu_time_eqos_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_cpu_time_qos_stats</span> 	<span class="n">cpu_time_rqos_stats</span><span class="p">;</span>

	<span class="cm">/* Statistics accumulated for terminated threads from this task */</span>
	<span class="kt">uint32_t</span>	<span class="n">task_timer_wakeups_bin_1</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">task_timer_wakeups_bin_2</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">task_gpu_ns</span><span class="p">;</span>
	<span class="kt">uint64_t</span>	<span class="n">task_energy</span><span class="p">;</span>

<span class="cp">#if MONOTONIC
</span>	<span class="cm">/* Read and written under task_lock */</span>
	<span class="k">struct</span> <span class="n">mt_task</span> <span class="n">task_monotonic</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* MONOTONIC */</span><span class="cp">
</span>
	<span class="cm">/* # of purgeable volatile VM objects owned by this task: */</span>
	<span class="kt">int</span>		<span class="n">task_volatile_objects</span><span class="p">;</span>
	<span class="cm">/* # of purgeable but not volatile VM objects owned by this task: */</span>
	<span class="kt">int</span>		<span class="n">task_nonvolatile_objects</span><span class="p">;</span>
	<span class="n">boolean_t</span>	<span class="n">task_purgeable_disowning</span><span class="p">;</span>
	<span class="n">boolean_t</span>	<span class="n">task_purgeable_disowned</span><span class="p">;</span>
	<span class="n">queue_head_t</span>	<span class="n">task_objq</span><span class="p">;</span>
	<span class="n">decl_lck_mtx_data</span><span class="p">(,</span><span class="n">task_objq_lock</span><span class="p">)</span> <span class="cm">/* protects "task_objq" */</span>

	<span class="n">boolean_t</span>	<span class="n">task_region_footprint</span><span class="p">;</span>

	<span class="cm">/*
	 * A task's coalition set is "adopted" in task_create_internal
	 * and unset in task_deallocate_internal, so each array member
	 * can be referenced without the task lock.
	 * Note: these fields are protected by coalition-&gt;lock,
	 *       not the task lock.
	 */</span>
	<span class="n">coalition_t</span>	<span class="n">coalition</span><span class="p">[</span><span class="n">COALITION_NUM_TYPES</span><span class="p">];</span>
	<span class="n">queue_chain_t</span>   <span class="n">task_coalition</span><span class="p">[</span><span class="n">COALITION_NUM_TYPES</span><span class="p">];</span>
	<span class="kt">uint64_t</span>        <span class="n">dispatchqueue_offset</span><span class="p">;</span>

<span class="cp">#if DEVELOPMENT || DEBUG
</span>	<span class="n">boolean_t</span>	<span class="n">task_unnested</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">task_disconnected_count</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#if HYPERVISOR
</span>	<span class="kt">void</span> <span class="o">*</span><span class="n">hv_task_target</span><span class="p">;</span> <span class="cm">/* hypervisor virtual machine object associated with this task */</span>
<span class="cp">#endif </span><span class="cm">/* HYPERVISOR */</span><span class="cp">
</span>
<span class="cp">#if CONFIG_SECLUDED_MEMORY
</span>	<span class="n">boolean_t</span>	<span class="n">task_can_use_secluded_mem</span><span class="p">;</span>
	<span class="n">boolean_t</span>	<span class="n">task_could_use_secluded_mem</span><span class="p">;</span>
	<span class="n">boolean_t</span>	<span class="n">task_could_also_use_secluded_mem</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_SECLUDED_MEMORY */</span><span class="cp">
</span>
	<span class="n">queue_head_t</span>    <span class="n">io_user_clients</span><span class="p">;</span>
	<span class="kt">uint32_t</span>	<span class="n">exec_token</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>task 자체에는 생명이 없으며 하나 이상의 thread의 container 역할을 하기 위해 존재한다. task의 thread는 <strong>thread_count</strong> thread를 포함하는 queue (<strong>queue_had_t threads</strong>) 에서 유지보수된다.<br />
또한 task에 대한 대부분의 operation은 해당 task의 모든 thread에 대해 동일한 thread operation을 반복하는 것에 불과하다.<br />
예를들어 task 우선 순위를 설정하려면 <strong>task_priority()</strong>를 실행하면 된다.</p>

<p><img src="/assets/img/macosx/lis_11_3.png" alt="" /></p>

<p><strong>queue_iterate</strong> macro는 <strong>queue_head_t</strong> 를 반복하여 각 thread를 차례로 lock 한다음 active 이면 priority를 설정하고 thread를 unlock한다. <br />
(지금 버전에서는 해당 함수 없음)</p>

<h4 id="ledgers">Ledgers</h4>

<p>ledger는 mach task에 대한  할당량을 청구하고 제한을 설정하는 메커니즘을 제공한다. 이것은 POSIX에서 제공하는 <strong>getrlimit/setrlimit</strong> 시스템콜과 유사하다. resource(일반적으로 cpu 및 memory)는 ledger 간에 전송될 수 있으며 한계를 초과하면 ledger가 refill 될 때까지 Mach exception, callback execution 또는 thread block이 발생할 수 있다.</p>

<p>BSD system call #373(ledger) 는 문서화되어 있지 않으며 이 호출은 각각 0, 1 또는 2의 코드에 대해 Mach의 APIs인 <strong>ledger_info(), ledger_entry_info(), ledger_template_info()</strong> 에 대한 BSD bridge 이다. 이를 통해 per-task로 ledger를 사용할 수 있으므로 CPU 및 memory와 같은 system resource를 보다 강력하게 제어할 수 있다.</p>

<blockquote>
  <p><strong>getrlimit()/setrlimit():</strong> 자원의 제한값을 알아내거나 설정하기 위해 사용</p>
</blockquote>

<h3 id="task-and-thread-apis">Task and Thread APIs</h3>

<p>위에서 본것처럼 task_t 및 thread_t structure는 너무 방대하다. 대부분의 kernel API가 직접적으로 access할 필요가 없는 많은 세부 사항을 포함하며, kernel 버전 간에 구조가 바뀔 수 있다는 문제점이 있다. <br />
Mach에서는 O-OP 방식으로 task와 thread에서 사용할 수 있는 다양한 API call이 포함되어 있어 실제 구현은 opaque 하다. <br />
중요한 필드에 접근하기 위해 <strong>get_bsdthread_info(), get_bsdtask_info(), get_bsdthreadtask_info()</strong> 등과 같은 특정 accessor function을 사용해야 한다. 또한 task와 thread의 method에 해당하는 API 를 사용할 수 있다.</p>

<h4 id="getting-the-current-task-and-thread">Getting the Current Task and Thread</h4>

<p><strong>current_task()</strong> 와 <strong>current_thread()</strong> 함수를 통해 현재 task와 현재 thread 의 handle 을 얻을 수 있다. 해당 두 함수는 모두 “fast” 함수에 대한 매크로이다. <strong>current_task()</strong>는 <strong>current_taks_fast()</strong> 를 래핑하며, <strong>current_thread()</strong>는 <strong>get_active_thread()</strong>를 래핑한다. <strong>get_active_thread()</strong>는 <strong>CPU_DATA_GET</strong> 을 래핑한다.</p>

<h3 id="task-apis">Task APIs</h3>

<p>Mach은 task를 처리하기 위한 함수의 완전한 서브시스템을 제공한다.<br />
유저 모드에 expose된 API는 다음과 같다.</p>

<p><img src="/assets/img/macosx/2019-10-24-5.03.05.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-24-5.12.21.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-24-5.04.46.png" alt="" /></p>

<p>추가적으로 user mode로 expose 되지 않는 internal API들은 다음과 같다</p>

<p><img src="/assets/img/macosx/2019-10-24-5.13.44.png" alt="" /></p>

<blockquote>
  <p>task port는 해당 thread 및 resource를 완벽하게 제어할 수 있는 경로이다. <br />
위에 나와있는 API들은 Mach가 task에서 허용하는 operation의 일부에 불과하며, 이 외에도 더 많은 API 들이 존재한다. ch 12에서 task의 virtual memory image 를 위반하고 더럽힐 수 있는 API 및 tool 들이 더 나오는데, 이러한 기능은 <strong>kernel_task</strong> 에 적용 시 너무 강력해져서 privileged user가 kernel memory를 엿보고 수정할 수 있게 된다.</p>
</blockquote>

<h3 id="thread-apis">Thread APIs</h3>

<p>Mach은 thread 관리를 위한 API도 다양하게 제공한다. 이들의 대부분은 task API와 동일한 기능을 하며, 실제로 task API는 종종 각 task의 thread 목록을 반복하며 해당 API를 차례로 적용한다. 이러한 호출은 (<strong>mach_thread_self</strong> 제외) Mach message를 통해 구현되며 MIG subsystem에 의해 생성된다.<br />
다음 Table 11-3에 thread API가 나열되어있다. 별 다른 언급이 없으면 kern_return_t를 반환한다.</p>

<p><img src="/assets/img/macosx/2019-10-24-5.31.20.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-24-5.31.38.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-24-5.32.03.png" alt="" /></p>

<h4 id="in-kernel-threads-api">In-Kernel Threads API</h4>

<p>Mach은 kernel mode 에서만 access할 수 있는 일련의 thread control function을 제공한다. <br />
이들 중 일부과 다음 표에 나와있다.</p>

<p><img src="/assets/img/macosx/2019-10-24-5.35.25.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-24-5.35.37.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-24-5.35.46.png" alt="" /></p>

<h4 id="thread-creation">Thread Creation</h4>

<p>thread creation API는 특히 중요하다. 자신을 포함하고 있는 container task 밖에서는 thread가 존재할 수 없으므로 해당 API는 task.h에 정의되어 있다.</p>

<p><img src="/assets/img/macosx/2019-10-24-5.39.17.png" alt="" /></p>

<p>첫 번째 argument인 <strong>task_t parent</strong> 는 thread가 생성될 task 이다. 이것은 Mach의 관점에서 보았을 때 사용자가 해당 port를 갖는 어떤 task에서도 thread를 생성할 수 있다는 것을 의미하며, 이 덕분에 remote thread creation을 가능하게 하는 Mach infra가 매우 유연해진다.</p>

<p>따라서 <strong>pthread_create()</strong> 를 사용할 경우 <strong>mach_task_self()</strong> 를 첫 번째 argument로 사용하여 Mach의 <strong>thread_create</strong> 를 호출한다. 만약 다른 task의 port가 있다면 그 안에 thread를 삽입할 수 있다. 주입 된 thread가 task의 virtual memory에 대한 full access를 얻고 감지하기 매우 어려우므로 올바르지 않은 기능이 구현될 수 있다.</p>

<h2 id="scheduling">SCHEDULING</h2>

<p>시스템의 CPU(core)가 아무리 많아도 thread는 그보다 더 많을 것이다. 그러므로 kernel은 CPU에 thread를 저글링 할 수 있어야 하며, 인간 사용자가 동시성을 인식할 수 있게 많은 thread가 실행되도록 해야한다. 그러나 실제로 각 core는 한 번에 하나의 thread만 실행할 수 있으므로 kernel은 thread 하나를 선점하고 다른 thread로 교체하여 thread간 <strong>context switch</strong>을 수행할 수 있어야 한다.</p>

<p>processor-set 추상화를 통해 Mach은 Linux 또는 Window 보다 이것에 좀더 적합하며 실제로 동일한 <strong>pset</strong>에서 동일한 CPU의 core를 관리하고 별도의 pset에서 개별 CPU를 관리할 수 있다. 이 섹션의 나머지 부분에서는 두 가지 케이스를 구분하지 않으며, physical CPU가 아닌 logical CPU를 CPU라고 지칭한다.</p>

<h3 id="the-high-level-view">The High-Level View</h3>

<p><strong>context switching</strong>은 현재 실행중이던 기존 process의 register state를 predefine된 memory 위치에 기록하고, 새로운 process의 register state로 교체하는 작업을 말한다.</p>

<blockquote>
  <p><strong>context?:</strong> 사용자와 다른 사용자, 사용자와 시스템 또는 디바이스간의 상호작용에 영향을 미치는 현재 상태를 규정하는 정보들을 말하며, OS에서의 <strong>context</strong> 는 CPU가 해당 process를 실행하기 위한 정보들이다. <strong>PCB(Process Control Block)</strong> 에 저장되며, 다음과 같은 정보들이 있다.</p>
  <ul>
    <li>process state: 생성, 준비, 수행, 대기, 중지</li>
    <li>program counter: process가 다음에 실행할 명령어 주소</li>
    <li>register: accumulator, 스택, 색인 register</li>
    <li>process 번호</li>
  </ul>
</blockquote>

<p>운영체제에 상관없이 thread scheduling의 기본 개념은 동일하다. thread는 CPU에서 필요한 만큼 execute 된다. execute란 CPU register 가 thread state로 채워져 있는 것을 말하며, 결과적으로 CPU가 execute하고 있는 코드는 해당 thread function의 code 이다. 이 execute는 다음 중 하나가 발생할 때 까지 계속된다.</p>

<ul>
  <li><strong>thread가 종료:</strong> 대부분의 thread는 결국 endpoint에 도달한다. thread function이 return 되거나 <strong>pthread_exit()</strong>를 호출하며, 이를 <strong>thread_terminate</strong> 라고 부른다.</li>
  <li><strong>thread의 자발적인 CPU 포기:</strong> thread 작업이 끝나지 않았음에도 불구하고 resource나 다른 blocoking operaiton을 기다리기 때문에 더이상 execute를 계속할 필요가 없는 경우에 thread는 자발적으로 scheduler 에게 context switch 를 요청한다. 또한 thread는 deadline이나 몇 event에 대한 notification을 요청하여 CPU로 복귀할 시기를 system에게 알려야 한다.</li>
  <li><strong>외부 interrupt에 의한 context switching:</strong> 외부 interrupt는 thread execution을 방해하여 CPU가 thread register state를 저장하도록 지시하고 interrupt-handling code를 즉시 실행한다. thread가 중단되었기 때문에 interrupt-handling code에서 돌아오기 전에 system은 scheduler에 의해 다음에 실행할 thread를 다시 선정한다. 따라서 interrupt 직전에 실행중이던 thread가 interrupt 처리 후에 다시 시작하리라는 보장은 없다.</li>
</ul>

<h3 id="priorities">Priorities</h3>

<p>모든 thread 는 평등하다. 그러나 어떤 thread 는 다른 thread 들보다 더 평등하다. 다시 말해, thread에는 특정 prority가 할당되며, scheduled 되는 빈도에 직접 영향을 준다. Windows 에는 32개, Linux 에는 140개, Mach 에는 128개의 priority level 이 있으며 Apple이 <em>priority bands</em> 라고 부르는 priority range의 사용법은 다음과 같다.</p>

<p><img src="/assets/img/macosx/2019-10-28-10.20.11.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-28-10.20.28.png" alt="" /></p>

<p>kernel thread의 최초 priority를 user mode보다 높은 80으로 설정하면 kernel 및 system 유지 관리가 몇 가지 매우 특수한 케이스를 제외한 모든 user mode thread를 선점할 수 있다.</p>

<h4 id="priority-shift">Priority Shift</h4>

<p>thread의 priority는 시작시 지정하지만, 종종 runtime중에 priority를 조정해야한다. Mach는 thread의 CPU usage및 전체 system load를 수용하기 위해 각 thread의 우선순위를 동적으로 조정한다. 따라서 thread는 CPU를 너무 많이 사용하면 priority가 감소하고, 충분히 사용하지 못했으면 priority가 높아지도록 priority band에서 <em>drift</em>  된다. 각 thread의 priority를 동적으로 업데이트 하는 것은 <strong>do_priority_computation</strong> 매크로와 <strong>update_priority</strong> 함수 이다. macro는 계산된 <strong>sched_usage</strong>(함수에 의해 계산되고 CPU usate delta를 고려) 를 <strong>pri_shift</strong> 값만큼 이동하여 thread priority를 토글한다. <strong>pri_shift</strong> 값은 global <strong>sched_pri_shift</strong> 에서 도출되며, 이는 scheduler에 의해 정기적으로 <strong>compute_averages</strong> function의 system load 계산의 일부로 업데이트된다. CPU usage delta 를 빼면 CPU 사용량이 높은 thread에 효과적으로 페널티를 주고(positive usage delta가 priority를 낮춤) CPU 사용량이 적은 thread에 대해 보상한다(negative usage delta가 priority를 증가시킴).</p>

<p>thread의 CPU usage의 penalty 가 치명적인 지점에 도달하지 않도록 하기 위해 <strong>update_priority</strong> function은 점차적으로 CPU usage를 aging 한다. 그것은 CPU usage의 기하급수적인 붕괴를 (5/8)^n factor로 시뮬레이션 하기 위해 sched_decay_shift structure를 사용하며, predefine된 shift 값을 사용하여 bit shift 및 addition으로 표현되는 계산 속도를 높일 수 있으며 곱셈보다 시간이 덜 걸린다.</p>

<p>Mach는 또한 <em>throttling</em> 을 지원하며 priority throttled process, 즉 system 에 의해 의도적으로 불이익을 받는 process에 대해 <strong>MAXPRI_THROTTLE</strong> 을 정의한다.</p>

<p>sheduler가 가능한 최소 시간 내에 priority가 가장 높은 다음 실행 가능 thread를 찾을 수 있도록 다양하고 일시적인 priority 를 가진 모든 thread를 효율적으로 관리해야 한다. 이러한 이유로 <strong>run queue</strong> 를 사용한다.</p>

<h3 id="run-queues">Run Queues</h3>

<p>thread는 다음에 표시된 것처럼 <em>osfmk/kern/sched.h</em> 에 정의된 priority list에 따라 <strong>run queue</strong> 에 배치된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">runq_stats</span> <span class="p">{</span> 
    <span class="kt">uint64_t</span>    <span class="n">count_sum</span><span class="p">;</span> 
    <span class="kt">uint64_t</span>    <span class="n">last_change_timestamp</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#if defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_PROTO) || 
</span><span class="n">defined</span><span class="p">(</span><span class="n">CONFIG_SCHED_FIXEDPRIORITY</span><span class="p">)</span>


<span class="k">struct</span> <span class="n">run_queue</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">highq</span><span class="p">;</span>                        <span class="cm">/* highest runnable queue */</span>
    <span class="kt">int</span> <span class="n">bitmap</span><span class="p">[</span><span class="n">NRQBM</span><span class="p">];</span>                <span class="cm">/* run queue bitmap array */</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>                        <span class="cm">/* # of threads total */</span>
    <span class="kt">int</span> <span class="n">urgency</span><span class="p">;</span>                      <span class="cm">/* level of preemption urgency */</span>
    <span class="n">queue_head_t</span> <span class="n">queues</span><span class="p">[</span><span class="n">NRQS</span><span class="p">];</span>        <span class="cm">/* one for each priority */</span>
    
    <span class="k">struct</span> <span class="n">runq_stats</span> <span class="n">runq_stats</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_PROTO) || 
defined(CONFIG_SCHED_FIXEDPRIORITY) */</span><span class="cp">
</span></code></pre></div></div>

<p><strong>run queue</strong> 는 128개의 priority 각각에 대해 하나의 대기열(#defined as <strong>NRQS)</strong> 을 나타내는  multi-level list 또는 array 이다. 실행할 다음 priority를 빠르게 검색하기 위해 O(1) sheduling을 사용한다. 배열을 보지 않고 NULL이 아닌 항목을 찾을때 까지 각 항목을 체크하는 것이다. Mach는 bitmap을 check 하므로  32(#defined as <strong>NRQBM</strong>) 를 동시에 볼 수 있다. 이것은 scheduling logic 이 자주 그리고 중요한 시간에 실행된 다는 것을 고려할 때 가능한 한 빠르고 가장 중요하게 만든다</p>

<p>thread에 새로운 priority를 할당하면 thread를 한 queue에서 다른 queue로 이동한다는 의미이므로 code는 thread의 <strong>sched_pri</strong> field를 직접 수정할 수 없다. 이 작업은 <strong>set_sched_pri</strong> 에 의해 수행되며, <strong>compute_priority</strong> 에 의해 호출된다.</p>

<p><img src="/assets/img/macosx/2019-10-28-11.15.37.png" alt="" /></p>

<h4 id="wait-queues">Wait Queues</h4>

<p>thread는 processor를 기다리는 동안 running 또는 ready sate에 최적이다. thread가 block되어 일부 IPC object(mutex 또는 semaphore 등), 몇몇 I/O operation(file 또는 socket 등) 또는 event를 기다리는 경우가 있다. 이러한 경우 thread scheduling을 고려할 때 이득이 없다. object 가 사용 가능하거나, operation 이 완료, 혹은 event가 발생한 후에만 실행을 재개할 수 있기 때문이다. 이러한 경우 thread를 <strong>wait queue</strong> 에 배치할 수 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
* wait_queue_t
* This is the definition of the common event wait queue
* that the scheduler APIs understand. It is used
* internally by the gerneralized event waiting mechanism
* (assert_wait), and also for items that maintain their
* own wait queues (such as ports and semaphores). *
* It is not published to other kernel components. They
* can create wait queues by calling wait_queue_alloc. *
* NOTE: Hardware locks are used to protect event wait
* queues since interrupt code is free to post events to
* them. */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">wait_queue</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="cm">/* flags */</span>
    <span class="cm">/* boolean_t */</span>       <span class="nl">wq_tyoe:</span><span class="mi">16</span><span class="p">,</span>     <span class="cm">/* only public field */</span>
                          <span class="nl">wq_fifo:</span><span class="mi">1</span><span class="p">,</span>      <span class="cm">/* fifo wakeup policy? */</span>
                          <span class="nl">wq_prepost:</span><span class="mi">1</span><span class="p">,</span>   <span class="cm">/* waitq supports prepost? set only */</span>
                          <span class="o">:</span><span class="mi">0</span><span class="p">;</span>             <span class="cm">/* force to long boundary */</span>
    <span class="n">hw_lock_data_t</span>        <span class="n">wq_interlock</span><span class="p">;</span>   <span class="cm">/* interlock */</span>
    <span class="n">queue_head_t</span>          <span class="n">wq_queue</span><span class="p">;</span>       <span class="cm">/* queue of elements */</span>
<span class="p">}</span> <span class="n">WaitQueue</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>wait queue</strong>에 thread를 추가하려면 <strong>wait_queue_assert_wait[64[_locked]]</strong> 을 사용하면 된다. 해당 함수는 thread가 realtime, privileged, 또는 FIFO wait queue가 아닌 이상(이 세 경우에는 queue의 head에 삽입) queue 의 tail 에 thread를 집어넣는다. wait condition 이 충족되면 대기중인 thread를 unblock 하고 dispatch 할 수 있다. <br />
<strong>wait_queue_wakeup64_[all|one]_locked</strong> 는 event 발생 시 하나 또는 모든 thread를 깨우기 위하여 사용된다. 이 함수는 <strong>wait queue</strong> 에서 thread를 빼고 <strong>thread_go</strong> 를 사용하여 dispatch 한다. <strong>thread_go</strong> 는 thread를 unblock 하고dispatch 한다.</p>

<h2 id="mach-scheduler-specifics">MACH SCHEDULER SPECIFICS</h2>

<p>앞서 살펴본 scheduling에 대한 관점은 모던 운영체제에 있어서 공통되는 부분이다. <br />
이 외에도 Mach에는 다음과 같은 몇가지 기능이 추가되었다.</p>

<ul>
  <li><strong>handoff</strong>를 사용하면 thread가 자발적으로 CPU를 넘겨줄 수 있다. 다만, 다른 아무 thread에게나 CPU를 넘기는 것이 아니고, 선택한 특정 thread에게 CPU 사용권을 넘긴다. 이 기능은 Mach이 message-passing kernel이며 thread간에 message가 전달된 다는 점을 생각하면 매우 유용함을 알 수 있다. 이렇게 하면 다음 message의 sender나 reciever가 다음에 scheduled 될 때 까지 기다리지 않고 최소한의 latency로 message를 처리할 수 있다.</li>
  <li><strong>Continuations</strong> 은 thread가 자체 stack에 크게 신경 쓰지 않고 폐기할 수 있는 경우 사용되며, stack을 복원하지 않고 system 을 resume할 수 있도록 해준다. 이 기능은 Mach에만 해당하며 kernel 주변 여러 곳에서 사용된다.</li>
  <li><strong>Asynchronous Software Traps(ASTs)</strong> 는 low-level hardware trap mechanism 을 보완하는 소프트웨어이다. kernel은 <strong>AST</strong> 를 사용하여 event scheduling 과 같이 주의가 필요한 out-of-band event에 응답할 수 있다.</li>
  <li><strong>Scheduling algorithms이 modular</strong> <strong>이며 schdeuler는 부팅시 동적으로 설정</strong> <strong>가능</strong>하다. 그러나 실제로는 하나의 scheduler(traditional scheduler)만 사용된다.</li>
</ul>

<h4 id="handoffs">Handoffs</h4>

<p>모든 운영 체제는 yielding(양도)의 개념을 지원한다. 이는 CPU를 다른 thread에게 자발적으로 넘겨주는 행위이다. 고전적인 형태에서는 양도한 thread가 후속 작업을 선택할 수 없고 scheduler에 의해 다음 thread가 선정되었다. <br />
Mach에서는 CPU를 전달하는 option을 추가하여 이를 개선하였다. 이를 통해 양도한 thread 는 scheduler에 다음으로 실행할 최상의 thread에 대한 힌트를 제공할 수 있다. shceduler가 이를 반드시 따라야만 하는 것은 아니기 때문에 양도한 thread가 지정한 thread가 아닌 다른 thread가 실행될 수도 있지만(지정된 thread가 실행 불가능한 경우 등), scheduler는 thread policy를 무시하기 때문에 <strong>handoff</strong> 는 대체로 성공한다. <strong>handoff</strong> 의 결과로 현재 thread 의 남은 quantum 이 다음으로 schedule 될 새 thread에게 제공된다. 고전적인 yield 대신 handoff 하기 위해 thread는 전환할 thread의 port를 지정하는 <strong>thread_switch()</strong> 를 호출하고 옵션 플래그(ex. 교체 thread의 priority를 낮춤) 및 이러한 옵션이 적용되는 시간을 지정한다. <br />
<strong>thread handoff mechanism</strong>은 user mode에서도 엑세스 할 수 있다. Mach 는 <strong>thread_switch()</strong> trap을 제공하여 user mode에서도 <strong>handoff</strong> 를 사용할 수 있도록 한다.</p>

<h4 id="continuations">Continuations</h4>

<p>context switch 는 대부분의 운영체제에서 간단하지만, 각 thread 마다 고유한 task 를 지니는 클래식 모델에 따라 Mach 은 <strong>continuation</strong> 이라는 개념을 도입하여 대안을 제공한다. <strong>continuation</strong> 은 optional resumption function(argument와 함께) 이며, 자발적으로 context switch 를 요청하는 경우 thread 가 지정할 수 있다. <strong>continuation</strong> 이 지정되면 thread가 재개될 때 새 stack으로 continuation point 에서 reload 되고 이전 상태는 저장되지 않는다. register의 저장 및 로딩을 생략할 수 있어 context switching이 훨씬 빨라지며, kernel stack 의 공간도 절약할 수 있다. <strong>continuation</strong> 인 thread는 4~5 KB만 필요하므로 다른 thread 들이 추가적으로 필요로 하는 16K를 절약할 수 있다. 전체 register 상태 및 thread stack 대신 <strong>continuation</strong> 및 optional parameter만 저장하면 되며, thread structure 자체에서 수행될 수 있다. <br />
thread는 <strong>thread_block()</strong> 을 사용하여 차단할 것을 지정하고 선택적으로 <strong>continuation</strong> 을 지정한다(또는 <strong>THREAD_CONTINUE_NULL</strong> 사용). <strong>continuation</strong> 에 대한 argument는 <strong>thread_block_parameter()</strong> 에 의해 지정될 수 있으며, 두 호출 모두 <strong>thread_block_reason()</strong> 에 대한 래퍼이다.</p>

<p><strong>continuation</strong> 은 context switch 비용을 완화하는 빠르고 효율적인 메커니즘이며 주로 Mach의 kernel thread 에서 사용된다. 실제로 Mach의 <strong>kerenl_thread_create</strong>(및 주요 호출자인 <strong>kernel_thread_start_priority</strong>) 는 <strong>continuation</strong> 개념을 기반으로 구축되었다.</p>

<p><img src="/assets/img/macosx/2019-10-28-3.17.12.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-28-3.17.48.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-28-3.18.04%20%281%29.png" alt="" /></p>

<h4 id="preemption-modes">Preemption Modes</h4>

<p>system 의 thread는 다음 두 가지 방법 중 하나로 preempted 될 수 있다: 명시적으로 thread가 CPU control 을 포기하거나, blocking으로 define된 operation 에 들어갔을 때 interrupt로 인해 암시적으로 발생한다. explicit preemption은 사전에 예측 가능하기 때문에 synchronous 라고도 한다. 본질적으로 예측할 수 없는 인터럽트는 implicit preemption을 asynchronous로 만든다.</p>

<p><strong>Explicit Preemption</strong></p>

<p>thread가 자발적으로 CPU를 포기하려고 할 때 explicit preemption이 발생한다. resource 또는 I/O를 기다리거나 일정 시간 동안 절전 모드로 인해 발생할 수 있다. user mode thread는 <strong>read(), select(), sleep()</strong> 등과 같은 blocking system call을 호출할 때 explicit preemption을 따른다. explicit preemption을 제공하기 위해 Mach는 <strong>thread_block_reason()</strong> 함수를 제공한다.</p>

<p><strong>Implicit Preemption</strong></p>

<p>OS X는 preemptive multitasking system 이다. 일반적으로, Mach는 thread의 ready 여부에 관계 없이 특정 시점에 thread를 preemption 할 권리를 가진다. explicit preemption과 달리 implicit preemption은 thread에게 invisible 하다. thread 는 이에대해 인지하지 못하고, save되었다가 다시 restore 된다. 대부분의 thread는 신경쓰지 않지만 CPU를 많이 사용하는 thread의 경우에는 문제가 될 수도 있다.<br />
implicit preemption의 경우 explicit한 경우보다 더 간단한데, <strong>continuation</strong> 이 없기 때문이다. thread는 자신이 suspend 된 것을 알지 못하기 때문에 <strong>continuation</strong> 을 요청할 수 없다. <br />
thread가 자체 scheduling을 제어할 수는 없지만 Mach는 서비스 등급을 보장하는 데 도움이 될 수 있는 몇 가지 사전 설정된 policy를 제공한다. Mach는 real time system이 아닌 time sharing system이므로 서비스를 보증할 수 없기 때문에 “work toward”에 유의한다. user mode에서 접근 가능한 Mach trap인 <strong>thread_policy_set()</strong> 을 사용하면 이러한 정책을 요청할 수 있다.</p>

<p><img src="/assets/img/macosx/2019-10-28-5.14.10.png" alt="" /></p>

<p>이러한 특징은 개별 thread의 scheduling을 세밀하게 제어할 수 있게 한다. 기본 정책 <strong>THREAD_STANDARD_POLICY</strong>는 fair time sharing에 사용된다. 추가 매개 변수는 필요하지 않다.</p>

<p><strong>THREAD_EXTENDED_POLICY</strong> 는 이를 기반으로 하여 false 인 경우 alternative policy 를 지정하고, true 인 경우 standard policy 로 돌아가는 boolean parameter <strong>timeshare</strong> 를 추가한다.</p>

<p>더 복잡하고 realtime policy 에 더 가까운 <strong>THREAD_TIME_CONSTRAINT_POLICY</strong> 는 세밀한 scheduling 조정을 허용한다. 이 정책의 핵심은 해당 thread의 scheduling인 “processing arrival” 개념이다. 단위는 kernel의 CPU clock 주기로 측정된다. 이 정책은 여러 argument를 기반으로 한다.</p>

<ul>
  <li><strong>Period:</strong> 연속된 두 번의 processing arrival 사이의 시간을 요청한다. 이 값이 0이 아니라면 해당 thread는 주기 마다 한 번씩 processor 시간을 구하는 것으로 가정한다.</li>
  <li><strong>Computation:</strong> thread가 schedule 될 때마다 필요한 computation time을 지정하는 32-bit integer</li>
  <li><strong>Constraint:</strong> computation의 시작과 끝 사이의 maximum(real) time</li>
  <li><strong>Preemptible:</strong> computation 중단 여부를 지정하는 boolean 값. 즉, 이러한 computation cycle이 연속적이어야 하는지(preemptible = false) 또는 아닌지(preemptible = true)</li>
</ul>

<p><strong>THREAD_PRECEDENCE_POLICY</strong> 는 한 개의 argument인 <strong>importance</strong> 를 취하는데, 이는 동일한 task의 다른 thread에 비교하여 해당 thread의 상대적 중요성을 제공한다. 이 값은 signed 이며, XNU의 최소 우선 순위는 0으로 정의되어있는 <strong>IDLE_PRI</strong> 이다.</p>

<p><strong>THREAD_AFFINITY_POLICY</strong> 는 동일한 cache의 thread 간에 L2 cache affinity를 제공한다. 모든 core가 동일한 L2 캐시를 공유하므로 코어(모든 코어가 동일한 L2 캐시를 공유하므로) 에 관계 없이 이러한 thread가 동일한 CPU 에서 실행될 가능성이 높지만, true SMP환경에서 CPU를 교차할 가능성은 낮다는 것을 의미한다. 이 것을 제공하기 위해 해당 정책은 relate process(parent and descendats) 간에 공유되는 affinity_tag 를 사용한다.</p>

<h3 id="asynchronous-software-trapsasts">Asynchronous Software Traps(ASTs)</h3>

<p><strong>AST</strong> 는 인공적인 비 하드웨어 trap 조건이다. <strong>AST</strong> 는 kernel 작업에 중요하며 preemption event와 같은 scheduling event 및 BSD signal이 구현되는 기판 역할을 한다. <strong>AST</strong> 는 thread의 제어 블록에서 다양한 bit field로 구현되며 <strong>thread_ast_set()</strong> 을 호출하여 개별적으로 설정할 수 있다. <strong>thread_ast_set()</strong>은 아래에서 볼 수 있다시피 매크로 이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define thread_ast_set(act, reason) (hw_atomic_or_noret(&amp;(act)-&gt;ast, (reason))) 
#define thread_ast_clear(act, reason) (hw_atomic_and_noret(&amp;(act)-&gt;ast, ~(reason))) 
#define thread_ast_clear_all(act) (hw_atomic_and_noret(&amp;(act)-&gt;ast, AST_NONE))
</span></code></pre></div></div>

<p>Table 11-8에는 define된 <strong>ASTs</strong>와 그 목적들이 나와있다.</p>

<p><img src="/assets/img/macosx/2019-10-28-5.52.49.png" alt="" /></p>

<p><strong>AST</strong>는 또한 combo로  사용될 수 있으며 이는 preceding flags의 bitwise OR 이다. Table 11-9에 나와있다.</p>

<p><img src="/assets/img/macosx/2019-10-28-5.54.49.png" alt="" /></p>

<p>시스템이 trap(<strong>user_trap_return</strong> 호출 후) 또는 interrupt(<strong>INTERRUPT</strong> 호출 후) 에서 복귀하면 즉시 user mode로 돌아가지 않는다. 대신 code는 thread의 field를 보고 <strong>AST</strong> 가 있는지 확인한다. 0이 아닌 경우 Listing 11-12 에 표시된 것처럼 <strong>i386_astintr()</strong> 를 호출하여 처리한다.</p>

<p><img src="/assets/img/macosx/2019-10-29-8.55.27.png" alt="" /></p>

<p>Figure 11-4 는 Listing-11-12와 같이 trap 및 interrupt 에서 복귀할 때의 <strong>AST</strong> check point를 보여준다. <strong>AST</strong> 는 모든 interrupt가 활성화 된 상태로 실행되지만 여전히 “out of process time” 상태에서 실행된다는 점에서 Linux의 softIRQ와 약간 비스하다. <strong>i386_astintr()</strong> 은 Listing 11-13에 표시된 것처럼 <strong>ast_taken()</strong> 에 대한 wrapper 이다.</p>

<p><img src="/assets/img/macosx/2019-10-29-9.03.00.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-29-9.03.23.png" alt="" /></p>

<p>kernel trap 및 kernel thread termination시 호출될 수 있는 <strong>ast_taken()</strong> 함수는 kernel idle thread를 저장하는 모든 thread 에서 <strong>AST</strong> 를 처리한다. <strong>AST_URGENT</strong> 및 <strong>AST_PREEMPT</strong>(<strong>AST_PREEMPTION</strong> combo)로 표시된 <strong>AST</strong> 는 thread를 즉시 preemption 한다. 그렇지 않으면 이 함수는 BSD event(signal 등등)을 위해 Mach에 임시로 넣었지만 무기한으로 남아있는 hack을 확인한다. <strong>BSD AST</strong> 가 설정되면 signal을 처리하기 위해 <strong>bsd_ast</strong> 를 호출한다.</p>

<p><strong>AST</strong> 에서 특별한 경우는 <strong>Preemption Free Zone(PFZ)</strong> 로 알려진 <strong>commpage</strong> 상의 특별한 영역이다. 이 zone에 있는 동안 미결 <strong>AST</strong> 는 pending된다.</p>

<p><img src="/assets/img/macosx/2019-10-29-9.49.17.png" alt="" /></p>

<h3 id="scheduling-algorithms">Scheduling Algorithms</h3>

<p>Mach의 thread scheduling algorithm은 확장성이 뛰어나며, 실제로 thread scheduling에 사용되는 algorithm을 변경할 수 있다.</p>

<p><img src="/assets/img/macosx/2019-10-29-9.52.02.png" alt="" /></p>

<p>일반적으로 기존 scheduler인 traditonal scheduler만 사용 가능하지만 Mach architecture에서는 compile 중에 해당하는 <strong>CONFIG_SCHED_</strong> 지시문을 사용하여 추가 scheduler를 정의하고 선택할 수 있다. 사용할 scheduler는 scheduler boot-arg 또는 device tree entry 로 지정할 수 있다.</p>

<p>각 scheduler object는 <strong>sched_dispatch_table</strong> structure를 유지하며, 여기서 다양한 operation은 함수 포인터로 유지된다. 글로벌 테이블 <strong>sched_current_dispatch</strong> 는 현재 활성 scheduling algorithm을 보유하며 runtime 중에 scheduler 전환을 허용한다. 모든 scheduler는 동일한 field를 구현해야하며, 일반 scheduler logic은 <strong>SCHED</strong> 매크로를 사용하여 호출한다.</p>

<p><img src="/assets/img/macosx/2019-10-29-10.22.59.png" alt="" /></p>

<p>scheduler dispatch table 은 다음 Table 11-11에 설명되어있다.</p>

<p><img src="/assets/img/macosx/2019-10-29-10.24.14.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-29-10.24.41.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-29-10.25.08.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-29-10.26.06.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-29-10.27.09.png" alt="" /></p>

<p><img src="/assets/img/macosx/2019-10-29-10.27.43.png" alt="" /></p>

<p>thread scheduling 을 유지하기 위해 모든 schedule은 앞에서 설명한 <strong>continuation</strong> 메커니즘을 적용한 <strong>maintenance_continuation</strong> 함수를 구현한다. 여기에서 scheduler thread는 <strong>clock_deadline_for_periodic_event</strong> 를 사용하여 clock notification을 등록한다. <strong>assert_wait_deadline</strong> 은 thread가 지정된 최종 기한 내에 실행되고 thread가 <strong>continuation</strong> 에서 block 된다. process는 scheduler의 init function에서 jumpstart 된다.</p>

<p>scheduler는 이 장에서 논의된 <strong>AST(Asynchronous Software Trap)</strong> 메커니즘을 많이 사용한다. 특히 scheduler 는 매우 특정한 유형인 <strong>AST_PREEMPTION</strong> 의 trap을 사용한다. 이들은 interrupt handling 및  kernel/user space transition을 위해 scheduling logic 을 묶는다. <br />
또한 scheduling logic은 <strong>kdebug</strong> 메커니즘에 대한 호출과 연계되어 있어서  <strong>DBG_MACH_SCHED</strong> 로 정의된 <strong>kdebug</strong> 코드는 scheduler flow에서 가장 중요한 point를 표시한다.</p>

<h2 id="timer-interrupts">TIMER INTERRUPTS</h2>

<p>지금까지는 scheduling logic 에서 Mach가 사용하는 primitive 와 construct를 다루었다. 이 섹션에서는 이러한 idea가 scheduling 을 이끄는 “engine”, 즉 timer interrupt와 통합된다.</p>

<h3 id="interrupt-driven-scheduling">Interrupt-Driven Scheduling</h3>

<p>시스템이 preemption multitasking을 제공하려면 먼저 scheduler가 CPU를 제어하여 현재 실행중인 thread를 preempt 한 다음 scheduling algorithm을 수행하여 현재 thread 가 실행을 다시 시작할지 또는 CPU를 더 중요한 thread에게 양도하기 위해 “kicked out” 될지 여부를 결정하는 메커니즘을 지원해야 한다.</p>

<p>원래의 thread 로부터 CPU의 제어를 빼앗아 오기 위해서 현대 운영체제는 hardware interrupt의 already-existing mechanism을 활용한다. CPU로 하여금 “drop everything” 하고 interrupt handler로 longjmp 하도록 강제하는 interrupt의 특성때문에 interrupt mechanism에 의존하여 interrupt 시에 scheduler를 실행하는 것이 타당하다.</p>

<p>그러나 한가지 작은 문제가 남아있다. interrupt는 asynchronous 이므로 언제든지 발생할 수 있으며 예측할 수가 없다. 사용량이 많은 시스템이 초당 수천 개의 interrupt를 처리하는 동안 quiet I/O period - 일반적인 interrupt source(disk, network, user)가 모두 idle인 상태 - 인 system 도 interrupt-wise 로 idle 상태가 될 수 있다. 따라서 주어진 시간 프레임 내에서 interrupt를 trigger 하기 위해 신뢰할 수 있는 예측 가능한 interrupt source  가 필요하다.</p>

<p>다행이도 이러한 interrupt 소스가 존재하며 XNU는 이를 <strong>real time clock</strong>, 또는 <strong>rtclock</strong> 이라고 한다. 이 clock은 하드웨어에 따라 다르며(Interl architecture의 경우 이 목적으로 local CPU의 <strong>APIC</strong> 를 사용), 주어진 cycle 수 이후 interrupt를 생성할 수 있도록 kernel에 의해 설정할 수 있다. 이 inetrrupt source 는 종종 timer interrupt 라고 한다.</p>

<p>이전 버전의 XNU는 timer interrupt를 고정된 값의 times per second (hz)로 트리거 하였다. 이 값은 여전히 <em>bsd/kern/clock.c</em> 에 global 로 정의되어 있지만 더이상 사용되지 않고 무시되어진다. 실제로 이 값을 무시해야 하는 충분한 이유가 있다. 고정된 간격으로 kernel을 중단시키는 timer는 예측 가능하지만 관계없는 interrupt를 야기시킨다. hz 값이 너무 높으면 불필요한 interrupt가 많이 발생하고, 너무 낮을 경우엔 sub-hz delay가 타이트한 loop에 의해서만 달성될 수 있기 때문에 시스템의 responsive가 낮아지게 된다. 따라서 구버전 OS X 에서 사용된 hertz_tick() 함수는 여전히 존재하지만 XNU가 프로파일링으로 컴파일 된 경우에만 사용되지 않고 조건적으로 컴파일된다.</p>

<p>해결책은 tick-less kernel의 다른 모델을 채택하는 것이다. 이 모델은 Linux와 매우 유사하다. 매 timer interrupt 마다 scheduler 가 그럴 필요가 있다고 생각할 때만 다음 interrupt를 schedule 하기 위해 timer 를 리셋한다.즉, 매 timer interrupt 때마다 interrupt handler는 thread에 의해 설정된 sleep timeout set인 pending deadline의 list를 빠르게 전달해야 하고, 필요한 경우 이에 따라 다음 timer interrupt를 schedule 해야한다. 따라서 각 timer interrupt 에서 더 많은 처리를 수행하면 가짜 inerrupt를 줄일 수 있으며 가장 긴급한 deadline만 추적하여 처리를 최소화 할 수 있다.</p>

<h3 id="timer-interrupt-processing-in-xnu">Timer Interrupt Processing in XNU</h3>

<p>XNU는 CPU 별로 timer-based event를 추적하는 데 사용되는 <strong>rtclock_timer_t</strong> type을 정의한다. 이 구조는 timer의 deadline과 <strong>call_entry</strong> structure의 queue를 기록하며,  Listring 11-17에 나온 바와 같이 define된 callout을 유지한다.</p>

<p><img src="/assets/img/macosx/2019-10-29-1.42.41.png" alt="" /></p>

<p><strong>rtclock_timer</strong> 의 queue는 오름차순으로 정렬되며 deadline field는 가장 가까운 deadline 순으로 설정된다.</p>

<p>XNU는 다른 machine-independent한 <strong>event timer</strong>(<strong>Etimer</strong> 라고도 함) 개념을 사용하여 <strong>rtclock_timer</strong> 를 래핑하고 실제 machine level timer interrupt 구현을 숨긴다.</p>

<h4 id="scheduling-deadlines">Scheduling Deadlines</h4>

<p>deadline timers 는 <strong>timer_queue_assign</strong> 호출을 통해 설정(<strong>rtclock</strong>의 queue에 추가)된다. 이 함수는 현재 CPU의 <strong>rtclock_timer.deadline</strong> 에 이미 설정된 것보다 빠른(빨리 만료되는) 경우에만 deadline을 설정한다. 하드웨어 레벨에서의 실제 deadline 설정은 <strong>etimer_set_deadline</strong> 에 의해 처리되고, CPU의 local APIC를 설정하는 <strong>etimer_resync_deadlines</strong>  가 뒤이어서 호출된다.</p>

<p>scheduler는 thread의 <strong>wait_timer</strong> 를 매개변수로 하여 <strong>timer_call_enter</strong> 를 호출하여 <em>timer callout</em> 의 상위 레벨 abstraction 을 통해 <strong>timer_queue_assign</strong>과 interface 한다. callout은 Listing 11-18에 표시된 것처럼 <em>osfmk/kern/timer_call_entry.h</em> 에 pre-set argument가 정의되어있는 function pointer 이다.</p>

<p><img src="/assets/img/macosx/2019-10-29-2.06.21.png" alt="" /></p>

<p>crtical 하다고 간주되지 않는 timer event는 동시에 만료될 확률을 증가시키기 위해(따라서 전체 timer interrupt 를 감소시키기 위해) 이를 병합하는 이른바 “slop” 값을 추가한다. <strong>timer_call_enter</strong> 의 다양한 호출자는 <strong>TIMER_CALL_CRITICAL</strong> flag를 지정하여 중요한 호출로 선언할 수 있다. scheduler의 끝에서 timer deadline을 설정하는 과정은 Figuer 11-5에 나와있다.</p>

<p><img src="/assets/img/macosx/2019-10-29-2.09.36.png" alt="" /></p>

<h4 id="timer-interrupt-handling">Timer Interrupt Handling</h4>

<p>timer interrupt 처리는 <strong>rtclock_intr</strong> 에 의해 수행된다. 이 함수 자체는 많은 일을 처리하지 않는다. 단지 모든 interrupt가 비활성화 되어 어떤 mode(kernel 또는 user)가 중단되었는지 확인하고 기존 thread의 register를 저장한다. 실제 작업은 timer deadline(<strong>rtclock_timer-&gt;deadline</strong>) 또는 power management deadline(<strong>pmCPUGetDeadline()</strong> 에서 반환된 대로) 이 만료되었는지 확인하고 <strong>etimer_intr</strong> 를 호출하여 수행된다. scheduler를 deadline queue의 producer 로 생각하면 이 함수는 consumer 이다.</p>

<p>timer에 대해 동작하기 위해 <strong>etimer_intr</strong> 은 <strong>timer_queue_expire</strong> (power management와 관련된 deadline일 경우에는 <strong>pmCPUDeadline</strong>) 을 호출한다. 이 함수는 queue를 순회하며 만료된 timer의 callout function을 호출 한다(호출 전후로 <strong>kdebug</strong> event를 기록). 이 하무는 deadline이 아직 만료되지 않은 첫 번째 calllout에 도달할 때까지 callout을 queue에서 빼내고 호출한다. queue는 deadline에 대해 오름차순으로 정렬되므로 만료되지 않은 첫 번째 callout 에 도달하면 그 뒤의 callout들도 모두 만료되지 않은 것이다. 만료되지 않은 첫 번째 deadline은 다음으로 처리될 deadline 이므로 <strong>etimer_intr</strong> 로 반환된다. <br />
Figuer 11-6에 이 과정이 나와있다.</p>

<p><img src="/assets/img/macosx/2019-10-29-2.36.50.png" alt="" /></p>

<h4 id="setting-the-hardware-pop">Setting the Hardware Pop</h4>

<p>deadline timers는 그들이 만료될 때 다음 timer interrupt를 생성하도록 하드웨어에게 요청하기 위해서 hardware level과 communicate 해야한다. 이것이 timer event 를 scheduling 할 때와 timer expiration을 처리할 때 모두 <strong>etimer_resync_deadlines()</strong> 에 대한 호출을 포함하는 이유이다. 이 함수는 timer 또는 power management deadline이 pending 중인지 여부를 확인한다(expiration 후 rescheulde 될 수 있음). deadline type 중 하나가 발견되면 함수는 앞선 두 경우를 처리하기 위해 다음 interrupt를 schedule 하려고 <strong>setPop()</strong> 을 호출한다. 만약 pending중인 deadline이 없다면 <strong>setPop()</strong> 은 <strong>EndOfAllTime</strong> 을 의미하는 값으로 호출된다. <strong>setPop()</strong> 은 <strong>rtc_timer</strong> 를 global로 사용하여 local APIC에 timer를 설정한다. <br />
Figure 11-7은 <strong>etimer_resync_deadlines</strong> 의 흐름을 보여준다.</p>

<p><img src="/assets/img/macosx/2019-10-29-2.49.58.png" alt="" /></p>

<blockquote>
  <p><strong>EndOfAllTime</strong> 은 문자 그대로 우리가 알고 있는 ‘시간의 끝’ 이다. 이 값은 <em>etimer.h</em> 에 2^64 - 1 로 설정되어있다. 일 년이 약 3150만 초라는 것을 감안하면 해당 숫자에 도달하기 까지 거의 10^12년이 소요될 수 있다. 그 정도 시간이면 우주는 crunch back 해서 다시 우주가 시작될 때의 특이점으로 돌아갔거나 빛도 따라잡지 못하는 빠른 속도로 확장되고 있을 것이다. 어쨌거나 그 즈음이면 지구는 이미 오래전에 태양에 의해 재가 되어 사라졌을 것이다.</p>
</blockquote>

<h2 id="exceptions">EXCEPTIONS</h2>

<p>kernel의 책임 중 하나는 processor trap과 exception에 대한 event를 처리하는 것이다. 이는 모든 모던 운영체제에서 동일하며, 다른 것은 해당 기능을 달성하기 위해 각 kernel이 취할 수 있는 특정 접근 방식이다.</p>

<p>Mach는  already-existing message-passsing architecture 상에서 구현된 exception에 대해 고유한 접근 방식을 취한다. 다음 섹션에서 제시되는 이 모델은 lightweight architecture 이며 실제로 exception을 처리하지 않는다. 이것은 상위계층인 BSD 에서 처리된다.</p>

<h3 id="the-mach-exception-model">The Mach Exception Model</h3>

<p>Mach exception-handling facility의 디자이너는 다음과 같은 요소를 언급한다.</p>

<ul>
  <li><strong>consistent semantic을 갖춘 single facility:</strong> Mach는 user define, platform agnostic, platform specific에 상관없이 모든 exception에 대해 단 하나의 exception-handling mechanism을 제공한다. exception은 exception type으로 group화 되고, 특정 platform은 특정 subtype을 정의할 수 있다.</li>
  <li><strong>Cleanliness 와 simplicity:</strong> interface는 매우 정교하며(덜 효율적일지라도) well-defined 된 message 및 port의 architecture에 의존한다. 이를 통해 디버거 및 external handler 뿐만 아니라 이론적으로는 network-level exception handling에 대한 확장이 가능하다.</li>
</ul>

<p>Mach에서 exception 은 kernel의 주요 기능인 <strong>message passing</strong> 을 통해 처리된다. exception 은 오류 thread 또는 task에 의해 발생되어(<strong>msg_send()</strong> 로) handler에 의해 caught 되는(<strong>msg_recv()</strong> 로) 메시지에 지나지 않는다. 그런 다음 handler는 exception을 처리하고 exception을 지우거나(exception을 처리된 것으로 표시한 후 계속 진행) 또는 thread를 terminate 시킬 수 있다.</p>

<p>exception handler가 오류 thread의 context에서 실행되는 다른 model과 달리 Mach는 오류 thread가 미리 지정된 exception port에 message를 보내고 reply를 기다리게 하여 별도의 context 에서 exception handler를 실행한다. 각 task는 exception port를 등록할 수 있으며 이 exception port는 동일한 task의 모든 thread에게 영향을 준다. 또한 개별 <strong>thread는 thread_set_exception_port</strong> 를 써서 <em>**</em>각자 exception port를 등록할 수 있다. 일반적으로 task 및 thread의 exception port 는 모두 NULL 이므로 exception이 handle되지 않는다. 일단 생성 되면, 이 port는 시스템의 다른 port들과 동일하며 다른 task나 host로 전달될 수 있다.</p>

<p>exception 이 발생하면 먼제 exception 을 thread exception port로  raise 하고, 그 다음으로 task exception port, 마지막으로 host(i.e. machine-level registered default) excepion port로 raise 한다. 이 중 어느것도 <strong>KERN_SUCCESS</strong> 가 되지 않으면 전체 task가 terminate 된다. 그러나 앞서 언급했듯 Mach는 exception processing logic을 제공하지 않으며, exception notification을 전달하는 framework만 제공한다.</p>

<h3 id="implementation-details">Implementation Details</h3>

<p>exception은 일반적으로 processor trap으로 시작된다. trap을 처리하기 위해 modern kernel 은 trap handler 를 install 한다. 이것은 kernel의 assembly-language core에 의해 설치되고 underlying processor architecture에 matching되는 low-level functions 이다.</p>

<p>Mach는 하드웨어 abstraction layer 를 유지하지 않지만, machine-specific한 부분과 machine-agnostic한 부분간의 명확한 분리를 목표로 한다. exception code는 특정 architecture에 속하는 별도의 file에 포함되며 XNU를 컴파일 할 때 수동으로 include 된다. architecture-independent exception code는 &lt;mach/exceptoin_types.h&gt; 에 #defined 된다. 이 code는 모든 platform에 공통이며, &lt;mach/machine/exception.h&gt;를 #include 하면 machine-specific subcode  지원을 제공한다. XNU open source에서 이 file은 &lt;mach/i386/exception.h&gt; 를 제외한 다른 platform에 대해서는 컴파일에 실패한다. <br />
Listing 11-19는 일반적인 Mach exception을 보여준다.</p>

<p><img src="/assets/img/macosx/2019-10-29-6.00.51.png" alt="" /></p>

<p>마찬가지로, Mach exception handler인 <strong>exception_triage()</strong> 는 exception 을 Mach message로 convert 하는 generic handler 이다. process가 core dump로 종료될 때마다 <strong>abnormal_exit_notify</strong> 에서 <strong>**BSD의 **proc_prepareexit</strong> 의 <strong>EXC_CRASH</strong> 와 함께  호출된다. 그러나 kernel의 다른 곳에서 호출되는 경우에는 architecture dependent 하다.</p>

<p>i386/x64 에서 <strong>i386_exceptoin()</strong> 함수는 <strong>exception_traiage()</strong> 를 호출한다 (Figure 11-8 참조). <strong>i386_exception()</strong> 자체는 다음과 같은 여러 위치에서 호출될 수 있다.</p>

<ul>
  <li><strong>low level Interrupt Descriptor Table(IDT) handlers:</strong> idt.s 와 idt64.s는 kernel mode exception을 위해 <strong>CCALL3</strong> 및 <strong>CCALL5</strong> 매크로를 사용하여 <strong>i386_exception()</strong> 을 호출한다.</li>
  <li><strong>user_trap():</strong> <strong>IDT handler</strong> 에서 자체적으로 호출되며 code와 함께 <strong>i386_exception()</strong> 을 호출한다.</li>
  <li><strong>mach_call_munger_xx functions:</strong> 잘못된 Mach system call에서 <strong>EXC_SYSCALL</strong> 과 함꼐 <strong>i386_exception()</strong> 을 호출</li>
  <li><strong>fpextovrflt:</strong> 특정 FPU fault로, floating point processor가 memory access fault를 발생시 호출된다.</li>
  <li><strong>fleh_swi:</strong> 잘못된 system call 또는 <strong>EXC_BAD_ACCESS</strong>에서 <strong>EXC_SYSCALL</strong>과 함께 <strong>exception_triage</strong> 를 호출하는 system call handler</li>
  <li><strong>sleh_undef:</strong> undefined instruction에서 undefined instruction handler 인 <strong>fleh_undef</strong> 에 의해 호출</li>
  <li><strong>sleh_abort:</strong> processor instruction 또는 datat abort시 <strong>EXC_BAD_ACCESS</strong> 와 함께 <strong>exception_triage</strong> 호출</li>
</ul>

<p><img src="/assets/img/macosx/12.png" alt="" /></p>

<p><strong>exception_triage()</strong> 는 두 architecutre에 대해 동일한 main exception logic(Mach message level)으로 작동한다. 이 함수는 <strong>exception_deliver()</strong> 를 사용하여 앞에서 설명한 방식으로(thread, task, host) exception을 전달하려고 시도한다.</p>

<p>host 자체뿐만 아니라 각 thread 또는 task object는 보통 <strong>IP_NULL</strong> 로 초기화 되어있는 exception port의 배열을 가지고 있으며, <strong>xxx_set_exception_ports()</strong> 로 설정될 수 있다(xxx는 thread, task, host 이다).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set_exception_ports</span><span class="p">(</span><span class="n">xxx_priv_t</span>   <span class="n">xxx_priv</span><span class="p">,</span> <span class="c1">// xxx is thread, task, or host</span>
    <span class="n">exception_mask_t</span>             <span class="n">exception_mask</span><span class="p">,</span>
    <span class="n">ipc_port_t</span>                   <span class="n">new_port</span><span class="p">,</span>
    <span class="n">exception_behavior_t</span>         <span class="n">new_behavior</span><span class="p">,</span>
    <span class="n">thread_state_flavor_t</span>        <span class="n">new_flavor</span><span class="p">)</span>
</code></pre></div></div>

<p>“behaviors” 는 exception에서 어떤 type의 messsage 가 생성되는지에 대한 machine-independent 한 indication 이다.  각 behavior는 operating system-speific 할 수도 있는 “flavor”를 가진다.</p>

<p><img src="/assets/img/macosx/2019-10-30-9.20.13.png" alt="" /></p>

<p>behavior <strong>EXCEPTION_DEFAULT</strong> 는 <strong>[mach]_exception_raise</strong>, <strong>EXCEPTION_STATE</strong>는 <strong>[mach]_exception_state_raise</strong> 로 구현된다. 여기서 함수 이름은 behavior constant와 동일하며, exception code가 64-bit일 경우엔 [mach] function이 대신 사용된다.</p>

<p>다양한 behavior는 host level 에서 hard-coded 된 exception catcher인 <strong>catch_[mach]_exception_xxx</strong> 에 의해 처리된다. 앞서 경우와 같이 function name은 behavior와 동일하다(마찬가지로 [mach] 변형은 64-bit <strong>mach_exception_data_t</strong> 에 대해서 사용한다). 이러한 함수는 <strong>ux_exception</strong> 을 호출하여 exception을 해당하는 UNIX signal로 변환하여 <strong>threadsignal</strong> 을 통해 오류 thread로 전달한다.</p>

<p>exception port 는 OS X 의 가장 중요한 기능중 하나인 crash reporter를 활성화하는 메커니즘이다. <strong>launchd</strong> 는 exception port를 등록하고, port가 fork를 건너 상속되기 때문에 동일한 exception port가 모든 자식들에게도 적용된다. <strong>launchd</strong> 는 <strong>ReportCrash</strong> 를 <strong>MachExceptionHandler</strong> 로 설정한다. 이렇게 하면 <strong>launchd</strong> 의 job에서 exception이 발생할 경우 crash reporter가 on demand 하게 자동적으로 시작될 수 있다. debugger는 exception port를 사용하여 exception을 trap하고 error를 break 한다.</p>


</article>



<section class="tags">
  <strong>Tags:</strong> <a href="/tag/mac">mac</a>,&nbsp;<a href="/tag/osx">osx</a>,&nbsp;<a href="/tag/internals">internals</a>,&nbsp;<a href="/tag/mach">mach</a>,&nbsp;<a href="/tag/scheduling">scheduling</a>
</section>



<section class="rss">
  <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
</section>

<section class="share">
  <span>Share: </span>
  
    
    
      <a href="//twitter.com/share?text=%5BOS+X+Internals%5D+CH.11+Tempus+Fugit&url=https%3A%2F%2Fsungunjo.github.io%2Fmac-os-x%2F2019%2F12%2F08%2Fch.11-tempus-fugit.html&via="
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
        <i class="fa fa-twitter-square fa-lg"></i>
      </a>
    
    
    
    
    
    
    
  
    
    
    
      <a href="//www.facebook.com/sharer.php?t=%5BOS+X+Internals%5D+CH.11+Tempus+Fugit&u=https%3A%2F%2Fsungunjo.github.io%2Fmac-os-x%2F2019%2F12%2F08%2Fch.11-tempus-fugit.html"
        onclick="window.open(this.href, 'facebook-share', 'width=550,height=255');return false;">
        <i class="fa fa-facebook-square fa-lg"></i>
      </a>
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
      <a href="//www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fsungunjo.github.io%2Fmac-os-x%2F2019%2F12%2F08%2Fch.11-tempus-fugit.html"
        onclick="window.open(this.href, 'linkedin-share', 'width=550,height=255');return false;">
        <i class="fa fa-linkedin-square fa-lg"></i>
      </a>
    
    
    
    
  
    
    
    
    
      <a href="//plus.google.com/share?title=%5BOS+X+Internals%5D+CH.11+Tempus+Fugit&url=https%3A%2F%2Fsungunjo.github.io%2Fmac-os-x%2F2019%2F12%2F08%2Fch.11-tempus-fugit.html"
        onclick="window.open(this.href, 'google-plus-share', 'width=550,height=255');return false;">
        <i class="fa fa-google-plus-square fa-lg"></i>
      </a>
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
      <a href="//www.pinterest.com/pin/create/button/?description=%5BOS+X+Internals%5D+CH.11+Tempus+Fugit&url=https%3A%2F%2Fsungunjo.github.io%2Fmac-os-x%2F2019%2F12%2F08%2Fch.11-tempus-fugit.html&media=https://sungunjo.github.io/assets/instacode.png"
        onclick="window.open(this.href, 'pinterest-share', 'width=550,height=255');return false;">
        <i class="fa fa-pinterest-square fa-lg"></i>
      </a>
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
      <a href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent('https://sungunjo.github.io/mac-os-x/2019/12/08/ch.11-tempus-fugit.html') + '&title=[OS X Internals] CH.11 Tempus Fugit'; return false">
        <i class="fa fa-reddit-square fa-lg"></i>
      </a>
    
    
  
    
    
    
    
    
    
    
    
  
</section>




<section class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'sungunjo-github-io';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>



</div>
</div>

    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h3 class="footer-heading">감자는 맛있다</h3>

    <div class="site-navigation">

      <p><strong>Site Map</strong></p>
      <ul class="pages">
				
	
	<li class="nav-link"><a href="/about/">About</a>
	

	

	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </div>

    <div class="site-contact">

      <p><strong>Contact</strong></p>
      <ul class="social-media-list">
        <li>
          <a href="mailto:sungunjo.dev@gmail.com">
            <i class="fa fa-envelope-o"></i>
            <span class="username">sungunjo.dev@gmail.com</span>
          </a>
        </li>

        
          
        
          
        
          
          <li>
            <a href="https://github.com/sungunjo" title="Fork me on GitHub">
              <i class="fa fa-github"></i>
              <span class="username">sungunjo</span>
            </a>
          </li>
          
        
          
          <li>
            <a href="https://www.linkedin.com/in/sungunjo" title="Connect with me on LinkedIn">
              <i class="fa fa-linkedin"></i>
              <span class="username">SungUn Jo</span>
            </a>
          </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        

      </ul>
    </div>

    <div class="site-signature">
      <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
      <p class="text">개발 공부 블로그</p>
    </div>

  </div>

</footer>

<!-- Scripts -->
<script src="//code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.1/js/lightbox.min.js"></script>
<script src="//unpkg.com/popper.js@1"></script>
<script src="//unpkg.com/tippy.js@5"></script>

<script type="text/javascript">
$(document).ready(function() {
  // Default syntax highlighting
  hljs.initHighlightingOnLoad();

  // Header
  var menuToggle = $('#js-mobile-menu').unbind();
  $('#js-navigation-menu').removeClass("show");
  menuToggle.on('click', function(e) {
    e.preventDefault();
    $('#js-navigation-menu').slideToggle(function(){
      if($('#js-navigation-menu').is(':hidden')) {
        $('#js-navigation-menu').removeAttr('style');
      }
    });
  });

	// Enable tooltips via Tippy.js
	if (Array.isArray(window.tooltips)) {
		window.tooltips.forEach(function(tooltip) {
			var selector = tooltip[0];
			var config = tooltip[1];
			tippy(selector, config);
		})
	}
});

</script>




<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-156645046-1', 'auto');
  ga('send', 'pageview', {
    'page': '/mac-os-x/2019/12/08/ch.11-tempus-fugit.html',
    'title': '[OS X Internals] CH.11 Tempus Fugit'
  });
</script>



  </body>

</html>
