<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어</title>
  <meta name="description" content="10장. 객체지향 쿼리 언어">
  
  <meta name="author" content="Jo">
  <meta name="copyright" content="&copy; Jo 2022">
  

  <!-- External libraries -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css">

  <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
  <link rel="shortcut icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  
  <!-- Facebook OGP cards -->
  <meta property="og:description" content="10장. 객체지향 쿼리 언어" />
  <meta property="og:url" content="https://sungunjo.github.io/jpa-study/2022/03/01/ch.10-object-oriented-query-language.html">
  <meta property="og:site_name" content="Development Stash" />
  <meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="https://sungunjo.github.io/assets/instacode.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="612" />
  <meta property="og:image:height" content="605" />
  

  
  <!-- Twitter: card tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어">
  <meta name="twitter:description" content="10장. 객체지향 쿼리 언어">
  <meta name="twitter:image" content="https://sungunjo.github.io/assets/instacode.png">
  <meta name="twitter:url" content="https://sungunjo.github.io/jpa-study/2022/03/01/ch.10-object-oriented-query-language.html">
  

  

  <!-- Site styles -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://sungunjo.github.io/jpa-study/2022/03/01/ch.10-object-oriented-query-language.html">
	<link rel="alternate" type="application/rss+xml" title="Development Stash" href="https://sungunjo.github.io/feed.xml" />
	
	<!-- Tooltips -->
	<script type="text/javascript">
		window.tooltips = []
	</script>
</head>


  <body>

    <header class="navigation" role="banner">
  <div class="navigation-wrapper">
    <a href="/" class="logo">
      
      <img src="/assets/logo.png" alt="Development Stash">
      
    </a>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
      <i class="fa fa-bars"></i>
    </a>
    <nav role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
				
	
	<li class="nav-link"><a href="/about/">About</a>
	

	

	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </nav>
  </div>
</header>


    <div class="page-content">
        <div class="post">

<div class="post-header-container has-cover" style="background-image: url(/assets/instacode.png);">
  <div class="scrim has-cover">
    <header class="post-header">
      <h1 class="title">[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어</h1>
      <p class="info">by <strong>Jo</strong></p>
    </header>
  </div>
</div>

<div class="wrapper">



<section class="post-meta">
  <div class="post-date">March 1, 2022</div>
  <div class="post-categories">
  in 
    
    <a href="/category/jpa-study">Jpa-study</a>
    
  
  </div>
</section>

<article class="post-content">
  <h1 id="10장-객체지향-쿼리-언어">10장. 객체지향 쿼리 언어</h1>

<p><br />
<br />
<br /></p>

<h1 id="101-객체지향-쿼리-소개">10.1 객체지향 쿼리 소개</h1>
<ul>
  <li>JPQL 특징
    <ul>
      <li>DB 테이블이 아닌 엔티티 객체를 대상으로 검색하는 객체지향 쿼리</li>
      <li>SQL을 추상화하여 특정 DB SQL에 의존 X</li>
    </ul>
  </li>
  <li>JPA에서 공식 지원하는 기능
    <ul>
      <li>JPQL(Java Persistence Query Langauge)</li>
      <li>Creiteria 쿼리: JPA 작성 도와주는 API, 빌더 클래스 모음</li>
      <li>네이티브 SQL: JPA에서 JPQL 대신 직접 SQL 사용 도움</li>
    </ul>
  </li>
  <li>JPA에서 공식 지원하는 건 아니지만 유용한 기능
    <ul>
      <li>QueryDSL: Criteria 쿼리처럼 JPQL 작성 편의 도와주는 빌더 클래스 모음. 비표준 오픈소스 프레임워크임</li>
      <li>JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용: 필요하면 직접 JDBC 사용 가능k</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br /></p>

<h1 id="jpql">JPQL</h1>
<ul>
  <li>객체지향 쿼리 언어</li>
  <li>테이블 대상이 아닌 엔티티 객체를 대상으로 쿼리</li>
  <li>SQL을 추상화하여 특정 DB SQL에 의존하지 않음</li>
  <li>SQL로 변환되어 실행</li>
  <li>JPQL API는 대부분 메소드 체인 방식으로 설계되어있어서 연속으로 작성 가능</li>
</ul>

<p><strong>샘플 모델 UML</strong>
<img src="/assets/img/jpa_study/ch.10/pic-10-1.png" /></p>

<p><strong>샘플 모델 ERD</strong>
<img src="/assets/img/jpa_study/ch.10/pic-10-2.png" /></p>

<p><br />
<br /></p>

<h2 id="1021-기본-문법과-쿼리-api">10.2.1 기본 문법과 쿼리 API</h2>
<ul>
  <li>JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문 사용 가능</li>
  <li>저장시에는 <code class="language-plaintext highlighter-rouge">EntityManager::persist()</code> 사용하면 되서 INSERT 는 없음</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select_문 ::=
  select_절
  from_절
  [where_절]
  [groupby_절]
  [having_절]
  [orderby_절]

update_문 ::= update_절 [where_절]
delete_문 ::= delete_절 [where_절]
</code></pre></div>    </div>

  </div>
</details>

<p><br /></p>

<h4 id="select-문">SELECT 문</h4>
<p><code class="language-plaintext highlighter-rouge">SELECT m FROM Member AS m WHERE m.username = 'Hello'</code></p>

<ul>
  <li>대소문자 구분
    <ul>
      <li>엔티티, 속성은 대소문자를 구분 O</li>
      <li>SELECT, FROM, AS 같은 JPQL 키워드는 대소문자 구분 X</li>
    </ul>
  </li>
  <li>엔티티 이름
    <ul>
      <li>디폴드 값은 클래스 명</li>
      <li><code class="language-plaintext highlighter-rouge">@Entity(name="")</code> 으로 지정 가능</li>
    </ul>
  </li>
  <li>별칭은 필수
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Member As m</code> 처럼 JPQL에선 alias 지정 필수임</li>
      <li>AS는 생략 가능</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="typequery-query">TypeQuery, Query</h3>
<ul>
  <li>작성한 JPQL 실행 위해 쿼리 객체 필요
    <ul>
      <li>반환할 타입 명확하게 지정 가능하면 TypeQuery 객체 사용</li>
      <li>반환 타입 명확하게 지정 불가능하면 Query 객체 사용</li>
    </ul>
  </li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">useTypeQuery</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

  <span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="nl">member:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"member = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">useQuery</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m.username, m.age FROM Member m"</span><span class="o">);</span>

  <span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

  <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="nl">o:</span> <span class="n">resulstList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[])</span> <span class="n">o</span><span class="o">;</span> <span class="c1">// 결과가 둘 이상이면 Object[] 반환</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"username = "</span> <span class="o">+</span> <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"age = "</span> <span class="o">+</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br /></p>

<h3 id="결과-조회">결과 조회</h3>
<ul>
  <li>아래 메소드들 호출시 실제 쿼리 실행하여 DB 조회함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">query.getResultList()</code>: 결과를 반환. 없으면 빈 컬렉션 반환</li>
      <li><code class="language-plaintext highlighter-rouge">query.getSingleResult()</code>: 결과가 정확히 하나일 때 사용
        <ul>
          <li>결과 없으면 <code class="language-plaintext highlighter-rouge">javax.persistence.NoResultException</code> 발생</li>
          <li>결과가 1개보다 많으면 <code class="language-plaintext highlighter-rouge">javax.persistence.NoUniqueResultException</code> 발생</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1022-파라미터-바인딩">10.2.2 파라미터 바인딩</h2>
<ul>
  <li>JPQL은 이름 기준 파라미터 바인딩 지원
    <ul>
      <li>JDBC는 위치 기준 파라미터 바인딩만 지원</li>
    </ul>
  </li>
  <li>파라미터 바인딩을 사용하지 않고 직접 문자 더해 만들어 넣으면 SQL 인젝션 공격 당할 수 있음</li>
  <li>또한 파라미터 바인딩 방식 쓰면 파리미터 값 달라도 같은 쿼리로 인식해 JPQL을 SQL로 파싱한 결과를 재사용 할 수 있음</li>
</ul>

<p><br /></p>

<h3 id="이름-기준-파라미터">이름 기준 파라미터</h3>
<ul>
  <li>파라미터를 이름으로 구분하는 방법</li>
  <li>이름 기준 파라미터는 앞에 : 붙임</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Strign</span> <span class="n">usernameParam</span> <span class="o">=</span> <span class="s">"User1"</span><span class="o">;</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resulstList</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m WHERE m.username = :username"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// :username이 이름 기준 파라미터 정의</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">usernameParam</span><span class="o">);</span>                                         <span class="c1">// setParameter로 파라미터 바인딩</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br /></p>

<h3 id="위치-기준-파라미터">위치 기준 파라미터</h3>
<ul>
  <li>파라미터를 위치 기준으로 구분하는 방법</li>
  <li>? 다음에 위치 값 주면 됨</li>
  <li>위치 값은 1부터 시작</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m WHERE m.username = ?1"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">usernameParam</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="1023-프로젝션">10.2.3 프로젝션</h2>
<ul>
  <li>SELECT 절에 조회할 대상을 지정하는 것 = <strong>projection</strong></li>
  <li><code class="language-plaintext highlighter-rouge">SELECT {프로젝션 대상} FROM</code>으로 대상 선택</li>
  <li>대상으로는 엔티티, 임베디드 타입, 스칼라 타입이 있음</li>
</ul>

<p><br /></p>

<h3 id="엔티티-프로젝션">엔티티 프로젝션</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">m</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>         <span class="c1">// Member</span>
<span class="no">SELECT</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>    <span class="c1">// Team</span>
</code></pre></div></div>

<ul>
  <li>위 예시처럼 엔티티를 프로젝션 대상으로 사용해서 원하는 객체를 바로 조회</li>
  <li>이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리됨</li>
</ul>

<p><br /></p>

<h3 id="임베디드-타입-프로젝션">임베디드 타입 프로젝션</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">address</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT o.address FROM Order o"</span><span class="o">,</span> <span class="nc">Address</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>임베디드 타입은 조회의 시작점이 될 수 없음</li>
  <li>위 예시처럼 엔티티를 통해서 조회해야 함</li>
  <li>임베디드 타입은 값 타입이기 때문에 영속성 컨텍스트에서 관리 X</li>
</ul>

<p><br /></p>

<h3 id="스칼라-타입-프로젝션">스칼라 타입 프로젝션</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">usernames</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT username FROM Member m"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>숫자, 문자, 날짜와 같은 기본 데이터 타입들</li>
  <li>AVG, SUM 같은 통계 쿼리도 주로 스칼라 타입으로 조회함</li>
</ul>

<p><br /></p>

<h3 id="여러-값-조회">여러 값 조회</h3>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT o.member, o.product, o.orderAmount FROM Order o"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="nl">row:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Member</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// 엔티티</span>
  <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Product</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 엔티티</span>
  <span class="kt">int</span> <span class="n">orderAmount</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// 스칼라</span>
<span class="o">}</span>
</code></pre></div>    </div>

  </div>
</details>

<ul>
  <li>프로젝션에 여러 값 선택시 TypeQuery 대신 Query 써야 함</li>
  <li>엔티티 타입도 여러 값 함께 조회 가능하며, 이 엔티티들도 영속성 컨텍스트로 관리 됨</li>
</ul>

<p><br /></p>

<h3 id="new-명령어">NEW 명령어</h3>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">UserDTO</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m"</span><span class="o">,</span> <span class="nc">UserDTO</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">UserDTO</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>    </div>

  </div>
</details>

<ul>
  <li>SELECT 다음에 NEW 명령어 사용하여 반환받을 클래스 지정하고 해당 클래스의 생성자에 JPQL 조회 결과 넘겨줄 수 있음</li>
  <li>이렇게 하면 TypeQuery 사용해서 바로 변환된 객체로 리턴받을 수 있음</li>
  <li>NEW 명령어 사용시 주의점
    <ul>
      <li>패키지 명을 포함한 전체 클래스 명 써야함</li>
      <li>순서와 타입이 일치하는 생성자 있어야 함</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1024-페이징-api">10.2.4 페이징 API</h2>
<ul>
  <li>JPA는 페이징을 아래 두 API로 추상화
    <ul>
      <li><code class="language-plaintext highlighter-rouge">setFirstResult(int startPosition)</code>: 조회 시작 위치(0부터 시작)</li>
      <li><code class="language-plaintext highlighter-rouge">setMaxResults(int maxResult)</code>: 조회할 데이터 수</li>
    </ul>
  </li>
  <li>DB dialect에 따라 사용중인 DB에 알맞은 SQL로 자동 변환되어 쿼리 수행됨
    <ul>
      <li>최적화 더 하려면 Native SQL 사용해야 함</li>
    </ul>
  </li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m ORDER BY m.username DESC"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>    <span class="c1">// 조회 시작 위치는 11번째(0번째가 시작이므로)</span>
  <span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>     <span class="c1">// 조회할 데이터 수는 20개</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>       <span class="c1">// 결과적으로 11~30번 데이터가 조회됨</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="1025-집합과-정렬">10.2.5 집합과 정렬</h2>
<ul>
  <li>집합은 집합함수와 함께 통계 정보 구할 때 사용</li>
</ul>

<p><br /></p>

<h3 id="집합-함수">집합 함수</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">함수</th>
      <th style="text-align: left">설명</th>
      <th style="text-align: left">리턴 타입</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">COUNT</td>
      <td style="text-align: left">결과 갯수를 구함</td>
      <td style="text-align: left">Long</td>
    </tr>
    <tr>
      <td style="text-align: left">MAX, MIN</td>
      <td style="text-align: left">최대, 최솟값 구함. 문자, 숫자, 날짜 등에 사용</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">AVG</td>
      <td style="text-align: left">평균값 구함. 숫자 타입만 사용 가능</td>
      <td style="text-align: left">Double</td>
    </tr>
    <tr>
      <td style="text-align: left">SUM</td>
      <td style="text-align: left">합을 구함. 숫자 타입만 사용 가능</td>
      <td style="text-align: left">정수합: Long<br />소수합: Double<br />BigInteger합: BigInteger<br />BigDecimal합: BigDecimal</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>집합 함수 사용시 참고사항
    <ul>
      <li>null 값은 무시하므로 통계에 잡히지 않음(DISTINCT 정의되어 있어도 무시됨)</li>
      <li>값 없는데 SUM, AVG, MAX, MIN 사용시 null 값이 됨
        <ul>
          <li>COUNT는 0 됨</li>
        </ul>
      </li>
      <li>DISTINCT 를 집합 함수 안에 사용해서 중복값 제거 후 집합 구할 수 있음
        <ul>
          <li>ex) <code class="language-plaintext highlighter-rouge">SELECT COUNT(DISTINCT m.age) FROM Member m</code></li>
        </ul>
      </li>
      <li>DISTINCT 를 COUNT 에서 사용할 때 임베디드 타입은 지원 X</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="group-by-having">GROUP BY, HAVING</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>groupby_절 ::= GROUP BY {단일값 경로 | alias}+
having_절 ::= HAVING 조건식
</code></pre></div></div>

<ul>
  <li>GROUP BY는 통계 데이터 구할 때 특정 그룹끼리 묶어줌</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 팀 이름을 기준으로 그룹화하여 통계 데이터 구하기</span>
<span class="no">SELECT</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="no">COUNT</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">SUM</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">AVG</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">MAX</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">MIN</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">)</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
  <span class="no">LEFT</span> <span class="no">JOIN</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
<span class="no">GROUP</span> <span class="no">BY</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>
</code></pre></div></div>

<ul>
  <li>HAVING 은 GROUP BY 와 함께 사용하며 그룹화된 통계 데이터를 기준으로 필터링 함</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 그룹별 통계 데이터 중 평균 나이가 10살 이상인 그룹 조회</span>
<span class="c1">// 팀 이름을 기준으로 그룹화하여 통계 데이터 구하기</span>
<span class="no">SELECT</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="no">COUNT</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">SUM</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">AVG</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">MAX</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">),</span> <span class="no">MIN</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">)</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
  <span class="no">LEFT</span> <span class="no">JOIN</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
<span class="no">GROUP</span> <span class="no">BY</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>
<span class="no">HAVING</span> <span class="nf">AGV</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">10</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="정렬order-by">정렬(ORDER BY)</h3>
<p><code class="language-plaintext highlighter-rouge">orderby_절 ::= ORDER BY {상태필드 경로 | 결과 변수 [ASC | DESC]}+</code></p>

<ul>
  <li>결과 정렬시 사용</li>
  <li>ASC: 오름차순 (default)</li>
  <li>DESC: 내림차순</li>
  <li>상태필드는 <code class="language-plaintext highlighter-rouge">t.name</code> 과 같이 객체의 상태를 나타내는 필드를 말함</li>
  <li>결과 변수는 SELECT 절에 나타나는 값을 말함
    <ul>
      <li>아래 예제의 경우 t.name, cnt 가 결과 변수이고, 그중 cnt를 기준으로 정렬시킴</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="no">COUNT</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="n">as</span> <span class="n">cnt</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
  <span class="no">LEFT</span> <span class="no">JOIN</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
<span class="no">GROUP</span> <span class="no">BY</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>
<span class="no">ORDER</span> <span class="no">BY</span> <span class="n">cnt</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="1026-jpql-조인">10.2.6 JPQL 조인</h2>
<ul>
  <li>SQL 조인과 기능 동일, 문법만 약간 상이함</li>
</ul>

<p><br /></p>

<h3 id="내부-조인">내부 조인</h3>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">teamName</span> <span class="o">=</span> <span class="s">"teamA"</span><span class="o">;</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"teamName"</span><span class="o">,</span> <span class="n">teamName</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>    </div>

  </div>
</details>

<ul>
  <li>INNSER JOIN 사용, INNER 는 생략 가능</li>
  <li>JPQL 은 연관 필드를 사용하여 조인함
    <ul>
      <li>연관 필드는 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드</li>
      <li>위 예제의 경우 <code class="language-plaintext highlighter-rouge">m.team</code> 이 연관필드임</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="외부-조인">외부 조인</h3>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">m</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
  <span class="no">LEFT</span> <span class="no">OUTER</span> <span class="no">JOIN</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
</code></pre></div>    </div>

  </div>
</details>

<ul>
  <li>OUTER 는 생략 가능</li>
  <li>마찬가지로 연관필드 가지고 조인</li>
</ul>

<p><br /></p>

<h3 id="컬렉션-조인">컬렉션 조인</h3>
<ul>
  <li>1:1, N:N  관계처럼 컬렉션 사용하는 곳에 조인하는 것</li>
  <li>[Member -&gt; Team] 조인은 N:1 조인이면서 단일 값 연관 필드(m.team) 사용</li>
  <li>[Team -&gt; Member]는 1:N 조인이면서 컬렉션 값 연관 필드(m.members) 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">t</span><span class="o">,</span> <span class="n">m</span> 
<span class="no">FROM</span> <span class="nc">Team</span> <span class="n">t</span> 
  <span class="no">LEFT</span> <span class="no">JOIN</span> <span class="n">t</span><span class="o">.</span><span class="na">members</span> <span class="n">m</span>   <span class="c1">// Team 과 Team 이 보유한 Member 목록을 컬렉션 값 연관 필드로 외부 조인한 것</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="세타-조인">세타 조인</h3>
<ul>
  <li>WHERE 절을 사용해서 세타 조인 가능</li>
  <li>내부 조인만 지원함</li>
  <li>세타 조인을 사용해 전혀 관계없는 엔티티도 조인 가능</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="nf">count</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span><span class="o">,</span>
  <span class="nc">Team</span> <span class="n">t</span>
<span class="no">WHERE</span> <span class="n">m</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span>   <span class="c1">// WHERE 절에서 전혀 관계 없는 Member.username 과 Team.name 을 조인함</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br /></p>

<h3 id="join-on-절jpa-21-이상-지원">JOIN ON 절(JPA 2.1 이상 지원)</h3>
<ul>
  <li>JPA 2.1 부터 조인시 ON 절을 지원</li>
  <li>ON 절 사용하면 조인 대상 필터링 후 조인 가능</li>
  <li>내부 조인의 ON절은 WHERE 절 사용하는 거랑 결과 같으므로 보통 외부 조인에서만 사용함</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">m</span><span class="o">,</span> <span class="n">t</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
  <span class="no">LEFT</span> <span class="no">JOIN</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span> <span class="no">ON</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="sc">'A'</span>    <span class="c1">// t.name = 'A' 로 조인 시점에 조인 대상을 필터링</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="1027-페치-조인">10.2.7 페치 조인</h2>
<ul>
  <li>JPQL에서 성능 최적화를 위해 제공</li>
  <li>연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능</li>
  <li>JOIN FETCH 명령어로 사용 가능</li>
  <li>페치 조인에서는 alias 못씀</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로</code></p>

<p><br /></p>

<h3 id="엔티티-페치-조인">엔티티 페치 조인</h3>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m JOIN FETCH m.team"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="nl">member:</span> <span class="n">members</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 페치 조인으로 Member 조회시 Team 도 함께 조회되어 지연 로딩 X</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"username = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="s">"teamname = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">name</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div>    </div>

  </div>
</details>

<ul>
  <li>위 예제의 경우 Member(m) 과 Team(m.team) 을 함께 조회함</li>
  <li><code class="language-plaintext highlighter-rouge">SELECT m</code> 으로 Member 만 선택했지만 실제로 실행된 SQL에서는 <code class="language-plaintext highlighter-rouge">SELECT m.*, t.*</code> 로 member와 연관된 team 도 함께 조회함</li>
  <li>∴ 지연 로딩 설정 해놨어도 Member 조회시 Team 도 같이 조회되어 지연 로딩 발생 안함</li>
</ul>

<p><br /></p>

<h3 id="컬렉션-페치-조인">컬렉션 페치 조인</h3>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Team</span><span class="o">&gt;</span> <span class="n">teams</span> <span class="o">=</span> <span class="n">em</span>
  <span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT t FROM Team t JOIN FETCH t.members WHERE t.name = 'teamA'"</span><span class="o">,</span> <span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Team</span> <span class="nl">team:</span> <span class="n">teams</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"teamname = "</span> <span class="o">+</span> <span class="n">team</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">", team = "</span> <span class="o">+</span> <span class="n">team</span><span class="o">);</span>

  <span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="nl">member:</span> <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">())</span> <span class="o">{</span>
    <span class="c1">// 페치 조인으로 Team 조회시 Member 도 함께 조회되어 지연 로딩 X</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-&gt;username = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()</span> <span class="o">+</span> <span class="s">", member = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>

  </div>
</details>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SELECT t</code> 로 Team 만 선택했지만 실제로 실행되는건 <code class="language-plaintext highlighter-rouge">SELECT t.*, m.*</code> 로 team 과 연관된 member도 함께 조회함</li>
  <li>만약 ‘teamA’에 속한 member가 여러명이라면 <code class="language-plaintext highlighter-rouge">getResultList()</code>의 결과로 member 수만큼의 team이 반환됨
    <ul>
      <li>반환되는 team은 모두 동일한(identity) 객체임</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="페치-조인과-distinct">페치 조인과 DISTINCT</h3>
<ul>
  <li>JPQL의 DITSINCT는 SQL에 DISTINCT 명령어 추가 및 에플리케이션에서 한번 더 중복 제거</li>
  <li>앞서 컬렉션 페치 조인 같은 경우 그냥 조회하면 여러 member 속한 team은 그 수만큼 반환
    <ul>
      <li>DISTINCT 붙여서 조회해도 원래 sql이라면 각 row의 member 데이터가 달라서 중복 제거가 안됨</li>
      <li>하지만 JPQL에서의 DISTINCT는 에플리케이션에서 한번 더 중복 제거해주므로 중복된 team  entity 제거됨</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="페치-조인과-일반-조인의-차이">페치 조인과 일반 조인의 차이</h3>
<ul>
  <li>일반 조인
    <ul>
      <li>JPQL은 결과 반환시 연관관계까지 고려 X, SELECT 절에 지정한 엔티티만 조회</li>
      <li>∴ 지연 로딩 설정시엔 프록시를, 즉시 로딩 설정시엔 연관된 엔티티 조회를 위해 쿼리를 한번 더 실행함</li>
    </ul>
  </li>
  <li>페치 조인
    <ul>
      <li>연관된 엔티티도 함께 조회</li>
      <li>∴ 연관된 엔티티 위해 쿼리 한번더 실행하지 않고 한번에 해결</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="페치-조인의-특징과-한계">페치 조인의 특징과 한계</h3>
<ul>
  <li>특징
    <ul>
      <li>페치 조인 사용시 쿼리 한번으로 연관된 엔티티 함께 조회할 수 있어 호출 회수 줄이고 성능 최적화 가능</li>
      <li>페치 조인은 글로벌 로딩 전략(엔티티에 직접 작용하는 로딩 전략, ex. <code class="language-plaintext highlighter-rouge">@OneToMany(fetch = FetchType.LAZY)</code>)보다 우선함
        <ul>
          <li>∴ 글로벌 로딩 전략을 지연 로딩으로 해놔도 JPQL 에서 페치 조인 쓰면 페치 조인 적용해서 한번에 조회함</li>
          <li>최적화를 위해 글로벌 로딩 전략으로 즉시 로딩 설정시 일부는 효율적일 수 있지만 전체적으로는 안쓰는거 자주 로딩해서 악영향 올 수 있음</li>
          <li>∴ 글로벌 로딩 전략은 지연 로딩, 최적화 필요한 곳에 페치 조인 적용하는게 좋음</li>
        </ul>
      </li>
      <li>객체 그래프 유지할 때 사용하면 유용ㅍ</li>
      <li>여러 테이블 조인해서 엔티티 본 모양이 아닌 다른 결과 내어야 하면 그냥 필요한 필드들만 각각 조회해서 DTO로 반환하는게 나을수도 있음</li>
    </ul>
  </li>
  <li>한계
    <ul>
      <li>페치 조인 대상에는 alias 불가
        <ul>
          <li>∴ SELECT, WHERE, 서브쿼리에 페치 조인 대상 사용 불가</li>
          <li>하이버네이트등 일부 구현체는 alias 지원하나 잘못 쓰면 연관된 데이터 수 달라져 데이터 무결성 깨질 수 있으므로 조심해야함
            <ul>
              <li>2차 캐시랑 같이 쓸 때 특히 조심</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>둘 이상의 컬렉션 페치 불가
        <ul>
          <li>구현체의 따라 가능하나 컬렉션 * 컬렉션의 카테시안 곱 만들어지므로 주의 필요</li>
          <li>하이버네이트는 예외 발생</li>
        </ul>
      </li>
      <li>컬렉션 페치 조인시 페이징 API(setFirstResult, setMaxResults) 사용 불가
        <ul>
          <li>컬렉션(1:N)이 아닌 단일 값 연관 필드(1:1, N:1) 들은 페치 조인 써도 페이징 API 못씀</li>
          <li>하이버네이트에서는 경고 로그 남기고 메모리에서 페이징 처리함 =&gt; 성능 이슈 및 메모리 초과 예외 발생 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1028-경로-표현식-path-expression">10.2.8 경로 표현식 (Path Expression)</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">m</span><span class="o">.</span><span class="na">username</span>
<span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
  <span class="n">join</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="n">t</span>
  <span class="n">join</span> <span class="n">m</span><span class="o">.</span><span class="na">orders</span> <span class="n">o</span>
<span class="no">WHERE</span> <span class="n">t</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="err">'</span><span class="n">teamA</span><span class="err">'</span>
</code></pre></div></div>

<ul>
  <li>.을 찍어 객체 그래프를 탐색하는 것</li>
  <li>위 예제에서 <code class="language-plaintext highlighter-rouge">m.username</code>, <code class="language-plaintext highlighter-rouge">m.team</code>, <code class="language-plaintext highlighter-rouge">m.orders</code>, <code class="language-plaintext highlighter-rouge">t.name</code>이 모두 경로 표현식 사용 예</li>
</ul>

<p><br /></p>

<h3 id="경로-표현식의-용어-정리">경로 표현식의 용어 정리</h3>
<ul>
  <li><strong>상태 필드 state field:</strong> 단순히 값 저장하기 위한 필드(필드 or 프로퍼티)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">m.username</code>, <code class="language-plaintext highlighter-rouge">t.name</code></li>
    </ul>
  </li>
  <li><strong>연관 필드 association field:</strong> 연관관계 위한 필드, 임베디드 타입 포함(필드 or 프로퍼티)
    <ul>
      <li><strong>단일 값 연관 필드:</strong> <code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@OneToOne</code>, 대상이 엔티티
        <ul>
          <li><code class="language-plaintext highlighter-rouge">m.team</code></li>
        </ul>
      </li>
      <li><strong>컬렉션 값 연관 필드:</strong> <code class="language-plaintext highlighter-rouge">@OneToMany</code>, <code class="language-plaintext highlighter-rouge">@ManyToMany</code>, 대상이 컬렉션
        <ul>
          <li><code class="language-plaintext highlighter-rouge">m.orders</code></li>
        </ul>
      </li>
      <li></li>
    </ul>
  </li>
</ul>
<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@Id</span>
  <span class="nd">@GeneratedValue</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"name"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>  <span class="c1">// state field</span>
  <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">;</span>  <span class="c1">// stae field</span>

  <span class="nd">@ManyToOne</span><span class="o">(...)</span>
  <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>  <span class="c1">// association field</span>

  <span class="nd">@OneToMany</span><span class="o">(...)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">;</span> <span class="c1">// association field</span>
<span class="o">}</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br /></p>

<h3 id="경로-표현식과-특징">경로 표현식과 특징</h3>
<ul>
  <li>상태 필드 경로: 경로 탐색의 끝. 더이상 탐색 X</li>
  <li>단일 값 연관 경로: 묵시적으로 내부 조인 일어남. 계속 탐색 O</li>
  <li>컬렉션 값 연관 경로: 묵시적으로 내부 조인 일어남. 더이상 탐색 X 지만 FROM 절에서 조인 통해 alias 얻으면 alias 로 탐색 O</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 상태 필드 경로 탐색
// JPQL
SELECT m.username, m.age FROM Member m

// 실행 쿼리
SELECT m.name, m.age
FROM Member m

...

// 단일 값 연관 경로 탐색
// JPQL
SELECT o.member FROM Order o

// 실행 쿼리
SELECT m.*
FROM Orders o
  INNER JOIN Member m on o.member_id = m.id // 묵시적 조인(내부 조인). 외부 조인은 JPQL에 JOIN 키워드 명시적으로 사용해야 함

...

// 컬렉션 값 연관 경로 탐색
// JPQL
SELECT t.members from Team t // 성공
SELECT t.members.username FROM Team t // 실패
// t.members 처럼 컬렉션 까지는 경로 탐색 가능하지만, 
// t.members.username 처럼 컬렉션에서 경로 탐색 시작은 불가능
// 계속 하려면 아래처럼 조인을 사용해서 새로운 alias 획득해야 함
SELECT m.username FROM Team t JOIN t.members m

// 컬렉션에서는 크기 구할 수 있느 size 기능 사용 가능
// COUNT 함수 쓰는 쿼리로 알아서 변환됨
SELECT t.members.size FROM Team t
</code></pre></div></div>

<p><br /></p>

<h3 id="경로-탐색을-사용한-묵시적-조인-시-주의사항">경로 탐색을 사용한 묵시적 조인 시 주의사항</h3>
<ul>
  <li>항상 내부 조인임</li>
  <li>컬렉션은 경로 탐색의 끝
    <ul>
      <li>컬렉션에서 경로 탐색 하려면 명시적 조인으로 alias 획득 필요</li>
    </ul>
  </li>
  <li>주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 FROM 절에 영향 줌</li>
  <li>묵시적 조인은 조인 발생 현환 파악 어려우므로 명시적 조인 쓰는게 좋음</li>
</ul>

<p><br />
<br /></p>

<h2 id="1029-서브-쿼리">10.2.9 서브 쿼리</h2>
<ul>
  <li>WHERE, HAVING 절에만 사용 가능, SELECT, FROM 절에선 못 씀
    <ul>
      <li>하이버네이트 HQL은 SELECT 절 서브쿼리 까지는 허용</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 나이가 평균보다 많은 회원 조회</span>
<span class="no">SELECT</span> <span class="n">m</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
<span class="no">WHERE</span> <span class="n">m</span><span class="o">.</span><span class="na">age</span> <span class="o">&gt;</span> <span class="o">(</span><span class="no">SELECT</span> <span class="nf">AVG</span><span class="o">(</span><span class="n">m2</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m2</span><span class="o">)</span>

<span class="c1">// 한 건이라도 주문한 고객 조회</span>
<span class="no">SELECT</span> <span class="n">m</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
<span class="nf">WHERE</span> <span class="o">(</span><span class="no">SELECT</span> <span class="nf">COUNT</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="no">FROM</span> <span class="nc">Order</span> <span class="n">o</span> <span class="no">WHERE</span> <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="na">member</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="c1">// 한 건이라도 주문한 고객 조회 (컬렉션 크기 값 구할 수 있는 size 기능 활용, 실행 쿼리는 위에거랑 동일)</span>
<span class="no">SELECT</span> <span class="n">m</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>
<span class="no">WEHRE</span> <span class="n">m</span><span class="o">.</span><span class="na">orders</span><span class="o">.</span><span class="na">size</span> <span class="o">&gt;</span> <span class="mi">0</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="서브-쿼리-함수">서브 쿼리 함수</h3>
<ul>
  <li><strong>EXISTS</strong>
    <ul>
      <li>[NOT] EXISTS (subquery)</li>
      <li>subquery에 결과 존재하면 참, NOT 붙으면 반대</li>
    </ul>
  </li>
  <li><strong>ALL, ANY, SOME</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>{ALL</td>
              <td>ANY</td>
              <td>SOME} (subquery)</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>비교 연산자와 같이 사용
        <ul>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>{=</td>
                  <td>&gt;</td>
                  <td>&gt;=</td>
                  <td>&lt;</td>
                  <td>&lt;=</td>
                  <td>&lt;&gt;}</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li>ALL:  조건 모두 만족시 참</li>
      <li>ANY, SOME: 조건 하나라도 만족하면 참</li>
    </ul>
  </li>
  <li><strong>IN</strong>
    <ul>
      <li>[NOT] IN (subquery)</li>
      <li>subquery 결과 중 하나라도 같은 것 있으면 참</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="10210-조건식">10.2.10 조건식</h2>

<p><br /></p>

<h3 id="타입-표현">타입 표현</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">종류</th>
      <th style="text-align: left">설명</th>
      <th style="text-align: left">예제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">문자</td>
      <td style="text-align: left">작은 따옴표 사이에 표현<br />작은 따옴표 표현하려면 연속 두개 사용(‘’)</td>
      <td style="text-align: left">‘HELLO’<br />‘She’’s’</td>
    </tr>
    <tr>
      <td style="text-align: left">숫자</td>
      <td style="text-align: left">L(Long)<br />D(Double)<br />F(Float)</td>
      <td style="text-align: left">10L<br />10D<br />10F</td>
    </tr>
    <tr>
      <td style="text-align: left">날짜</td>
      <td style="text-align: left">DATE {d ‘yyyy-mm-dd’}<br />TIME {t ‘hh-mm-ss’}<br />DATETIME {ts ‘yyyy-mm-dd hh:mm:ss.f’}</td>
      <td style="text-align: left">{d ‘2021-03-03’}<br />{t ‘11-11-11’}<br />{ts ‘2021-03-03 11-11-11.111’}<br />m.createDate = {d ‘ 2021-03-03’}</td>
    </tr>
    <tr>
      <td style="text-align: left">Boolean</td>
      <td style="text-align: left">True, False</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">Enum</td>
      <td style="text-align: left">패키지명 포함 전체 이름 사용</td>
      <td style="text-align: left">jpabook.MemberType.Admin</td>
    </tr>
    <tr>
      <td style="text-align: left">엔티티 타입</td>
      <td style="text-align: left">엔티티의 타입을 표현. 주로 상속과 관련하여 사용</td>
      <td style="text-align: left">TYPE(m) = Member</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="연산자-우선-순위">연산자 우선 순위</h3>
<ol>
  <li>경로 탐색 연산: .</li>
  <li>수학 연산: 단항 연산자 +, 단항 연산자 -, *, /, +, -</li>
  <li>비교 연산: =, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;, [NOT] BETWEEN, [NOT] LIKE, [NOT] IN, IS [NOT] NULL, IS [NOT] EMPTY, [NOT] MEMBER [OF], [NOT] EXISTS</li>
  <li>논리 연산: NOT, AND, OR</li>
</ol>

<p><br /></p>

<h3 id="논리-연산과-비교식">논리 연산과 비교식</h3>
<ul>
  <li><strong>논리 연산</strong>
    <ul>
      <li>AND: 둘 다 만족하면 참</li>
      <li>OR: 둘 중 하나 만족하면 참</li>
      <li>NOT: 조건식의 결과 반대</li>
    </ul>
  </li>
  <li><strong>비교식</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>=</td>
              <td>&gt;</td>
              <td>&gt;=</td>
              <td>&lt;</td>
              <td>&lt;=</td>
              <td>&lt;&gt;</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="between-in-like-null-비교">Between, IN, Like, NULL 비교</h3>
<ul>
  <li><strong>Between 식</strong>
    <ul>
      <li>X [NOT] BETWEEN A AND B</li>
      <li>X는 A ~ B 사이 값이면 참(A, B 포함)</li>
    </ul>
  </li>
  <li><strong>IN 식</strong>
    <ul>
      <li>X [NOT] IN (예제)</li>
      <li>X와 같은 값이 예제에 하나라도 있으면 참</li>
      <li>예제에는 서브쿼리 사용 가능</li>
    </ul>
  </li>
  <li><strong>Like 식</strong>
    <ul>
      <li>문자 표현식 [NOT] LIKE 패턴값 [EXCAPE 이스케이프 문자]</li>
      <li>문자 표현식과 패턴값을 비교</li>
      <li>%: 아무 값들이 입력되어도 됨(값이 없어도 됨)</li>
      <li>_: 한 글자는 아무 값이 입력되어도 되지만 값은 있어야 함</li>
    </ul>
  </li>
  <li><strong>NULL 비교식</strong>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>{단일값 경로</td>
              <td>입력 파라미터 } IS [NOT] NULL</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>NULL 인지 비교</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="컬렉션-식">컬렉션 식</h3>
<ul>
  <li>컬렉션에만 사용하는 특별한 기능</li>
  <li>
    <p>컬렉션에선 컬렉션 식 외에 다른건 못 씀</p>
  </li>
  <li><strong>빈 컬렉션 비교식</strong>
    <ul>
      <li>{ 컬렉션 값 연관 경로 } IS [NOT] EMPTY</li>
      <li>컬렉션에 값이 비었으면 참</li>
    </ul>
  </li>
  <li><strong>컬렉션의 멤버 식</strong>
    <ul>
      <li>{엔티티나 값} [NOT] MEMBER [OF] {컬렉션 값 연관 경로}</li>
      <li>엔티티나 값이 컬렉션에 포함되어 있으면 참</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="스칼라-식">스칼라 식</h3>
<ul>
  <li>
    <p>숫자, 문자, 날짜, case, 엔티티 타입(엔티티의 타입 정보) 같은 기본적인 타입(스칼라)에 사용하는 식</p>
  </li>
  <li><strong>수학 식</strong>
    <ul>
      <li>+, -: 단항 연산자</li>
      <li>*, /, +, -: 사칙연산</li>
    </ul>
  </li>
  <li><strong>문자 함수</strong></li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">함수</th>
      <th style="text-align: left">설명</th>
      <th style="text-align: left">예제</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">CONCAT(문자1, 문자2, …)</td>
      <td style="text-align: left">문자 합침. (HQL에선</td>
      <td style="text-align: left"> </td>
      <td>로도 사용 가능)</td>
      <td>CONCAT(‘A’, ‘B’) = AB</td>
    </tr>
    <tr>
      <td style="text-align: left">SUBSTRING(문자, 위치[, 길이])</td>
      <td style="text-align: left">위치부터 시작해 길이만큼 문자 구함. 길이 값 없으면 나머지 전체 길이 의미</td>
      <td style="text-align: left">SUBSTRING(‘ABCDEF’, 2, 3) = BCD</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">TRIM([[LEADING</td>
      <td style="text-align: left">TRAILING</td>
      <td style="text-align: left">BOTH] [트림 문자] FROM] 문자)</td>
      <td>LEADING: 왼쪽만, TRAILING: 오른쪽만, BOTH:양쪽 다 트림 문자 제거(기본값은 BOTH, 트림 문자의 기본값은 공백(SPACE))</td>
      <td>TRIM(‘ ABC ‘) = ‘ABC’</td>
    </tr>
    <tr>
      <td style="text-align: left">LOWER(문자)</td>
      <td style="text-align: left">소문자화</td>
      <td style="text-align: left">LOWER(‘ABC’) = ‘abc’</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">UPPER(문자)</td>
      <td style="text-align: left">대문자화</td>
      <td style="text-align: left">UPPER(‘abc’) = ‘ABC’</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">LENGTH(문자)</td>
      <td style="text-align: left">문자 길이</td>
      <td style="text-align: left">LENGTH(‘abc’) = 3</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: left">LOCATE(찾을 문자, 원본 문자[, 검색시작위치])</td>
      <td style="text-align: left">검색시작위치부터 문자를 검색. 1부터 시작, 못찾으면 0 반환</td>
      <td style="text-align: left">LOCATE(‘DE’, ‘ABCDEFG’) = 4</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>수학 함수</strong></li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">함수</th>
      <th style="text-align: left">설명</th>
      <th style="text-align: left">예제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ABS(수학식)</td>
      <td style="text-align: left">절대값</td>
      <td style="text-align: left">ABS(-10) = 10</td>
    </tr>
    <tr>
      <td style="text-align: left">SQRT(수학식)</td>
      <td style="text-align: left">제곱근</td>
      <td style="text-align: left">SQRT(4) = 2.0</td>
    </tr>
    <tr>
      <td style="text-align: left">MOD(수학식, 나눌 수)</td>
      <td style="text-align: left">나머지</td>
      <td style="text-align: left">MOD(4, 3) = 1</td>
    </tr>
    <tr>
      <td style="text-align: left">SIZE(컬렉션 값 연관 경로식)</td>
      <td style="text-align: left">컬렉션 크기</td>
      <td style="text-align: left">SIZE(t.members)</td>
    </tr>
    <tr>
      <td style="text-align: left">INDEX(별칭)</td>
      <td style="text-align: left">LIST 타입 컬렉션의 위치값 구함(@OrderColumn 사용하는 LIST 타입일 떄만 사용 가능)</td>
      <td style="text-align: left">t.members m WHERE INDEX(m) &gt; 3</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><strong>날짜 함수</strong>
    <ul>
      <li>CURRENT_DATE: 현재 날짜</li>
      <li>CURRENT_TIME: 현재 시간</li>
      <li>CURRENT_TIMESTAMP: 현재 날짜 시간</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="case-식">CASE 식</h3>
<ul>
  <li>특정 조건에 따라 분기할 떄 사용</li>
  <li><strong>기본 CASE</strong></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CASE
  {WHEN &lt;조건식&gt; THEN &lt;스칼라식&gt;}+
  ELSE &lt;스칼라식&gt;
END

// 예제
SELECT
  CASE 
    WHEN m.age &lt;= 10 then '학생요금'
    WHEN m.age &gt;= 60 then '경로요금'
    ELSE '일반요금'
  END
FROM Member m
</code></pre></div></div>

<ul>
  <li><strong>심플 CASE</strong>
    <ul>
      <li>조건식 사용 X, 문법 단순</li>
      <li>자바의 switch case 문과 비슷</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CASE &lt;조건대상&gt;
  {WHEN &lt;스칼라식1&gt; THEN &lt;스칼라식2&gt;}+
  ELSE &lt;스칼라식&gt;
END

// 예제
SELECT
  CASE t.name
    WHEN 'teamA' then '인센티브110%'
    WHEN 'teamB' then '인센티브120%'
    ELSE '인센티브105%'
  END
FROM Team t
</code></pre></div></div>

<ul>
  <li><strong>COALESCE</strong>
    <ul>
      <li>COALESCE(<스칼라식> {,<스칼라식>}+)</스칼라식></스칼라식></li>
      <li>스칼라식을 차례로 조회해서 null 아니면 반환</li>
      <li><code class="language-plaintext highlighter-rouge">SELECT COALESCE(m.username, 'unknown member') FROM Member m // m.username null 이면  'unknown member' 반환</code></li>
    </ul>
  </li>
  <li><strong>NULLIF</strong>
    <ul>
      <li>NULLIF(<스칼라식>, <스칼라식>)</스칼라식></스칼라식></li>
      <li>두 값 같으면 null, 다르면 첫 번째 값 반환</li>
      <li><code class="language-plaintext highlighter-rouge">SELECT NULLIF(m.username, 'admin') FROM Member m // m.username이 'admin' 이면 null, 나머진 m.username 값 반환</code></li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="10211-다형성-쿼리">10.2.11 다형성 쿼리</h2>
<ul>
  <li>JPQL로 부모 엔티티 조회시 자식 엔티티도 함께 조회</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">startegy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{...}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Album, Movie ...</span>
<span class="o">...</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br /></p>

<h3 id="type">TYPE</h3>
<ul>
  <li>엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Item 중 Book, Movie 조회
// JPQL
SELECT i 
ROM Item i
WHERE TYPE(i) 
  IN (Book, Movie)

// SQL
SELECT i 
FROM Item i
WHERE i.DTYPE 
  IN ('B', 'M')
</code></pre></div></div>

<p><br /></p>

<h3 id="treat">TREAT</h3>
<ul>
  <li>JPA 2.1 에 추가된 기능</li>
  <li>자바의 타입 캐스팅과 유사함</li>
  <li>상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용</li>
  <li>표준은 FROM, WHERE 절에서 사용 가능, 하이버네이트는 SELECT 절에서도 사용 가능</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 부모인 Item, 자식인 Book
// Item 을 Book 타입처럼 다뤄서 author 필드 접근
// JPQL
SELECT i 
FROM i 
WHERE TREAT(i AS Book).author = 'kim'

// SQL
SELECT i.*
FROM Item i
WHERE i.DTYPE = 'B'
  AND i.author = 'kim
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="10212-사용자-정의-함수-호출">10.2.12 사용자 정의 함수 호출</h2>
<ul>
  <li>JPA 2.1 부터 지원</li>
  <li>function_invocation::=FUNCTION(function_name {, function_arg}*)</li>
  <li><code class="language-plaintext highlighter-rouge">SELECT FUNCTION('group_concat', i.name) FROM Item i</code></li>
  <li>하이버네이트 구현체 사용시 아래 코드와 같이 방언 클래스(H2Dialect) 상속, 구현하고 사용할 DB 함수 미리 등록하고 <code class="language-plaintext highlighter-rouge">hibernate.dialect</code> 에 해당 방언 등록해야 함
    <ul>
      <li>하이버네이트 구현체 사용시 위 예제를 다음과 같이 축약 가능 <code class="language-plaintext highlighter-rouge">SELECT group_concat(i.name) FROM Item i</code></li>
    </ul>
  </li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방언 클래스 상속</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyH2Dialect</span> <span class="kd">extends</span> <span class="nc">H2Dialect</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">MyH2Dialect</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">registerFunction</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> 
      <span class="k">new</span> <span class="nf">StandardSQLFunction</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> <span class="nc">StrandardBasicTypes</span><span class="o">.</span><span class="na">STRING</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 상속한 방언 클래스 등록
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.dialect"</span> <span class="na">value=</span><span class="s">hello.MyH2Dialect"</span> <span class="nt">/&gt;</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h3 id="10213-기타-정리">10.2.13 기타 정리</h3>
<ul>
  <li>enum은 = 비교 연산만 지원</li>
  <li>임베디드 타입은 비교 지원 X</li>
</ul>

<p><br /></p>

<h3 id="empty-string">EMPTY STRING</h3>
<ul>
  <li>JPA 표준은 ‘‘를 길이 0인 Empty String 으로 정함
    <ul>
      <li>DB에 따라 NULL 로 사용하는 곳도 있으므로 확인 후 사용</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="null-정의">NULL 정의</h3>
<ul>
  <li>조건 만족 데이터 하나도 없으면 NULL</li>
  <li>NULL 은 unknown value</li>
  <li>NULL 과의 모든 수학적 계산 결과는 NULL</li>
  <li>NULL == NULL 은 unknown value</li>
  <li>NULL is NULL 은 참</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">AND</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">F</th>
      <th style="text-align: center">U</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">U</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">F</td>
    </tr>
    <tr>
      <td style="text-align: center">U</td>
      <td style="text-align: center">U</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">U</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">OR</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">F</th>
      <th style="text-align: center">U</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
      <td style="text-align: center">U</td>
    </tr>
    <tr>
      <td style="text-align: center">U</td>
      <td style="text-align: center">T</td>
      <td style="text-align: center">U</td>
      <td style="text-align: center">U</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">NOT</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">T</td>
      <td style="text-align: center">F</td>
    </tr>
    <tr>
      <td style="text-align: center">F</td>
      <td style="text-align: center">T</td>
    </tr>
    <tr>
      <td style="text-align: center">U</td>
      <td style="text-align: center">U</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h2 id="10214-엔티티-직접-사용">10.2.14 엔티티 직접 사용</h2>

<p><br /></p>

<h3 id="기본-키-값">기본 키 값</h3>
<ul>
  <li>JPQL에서 엔티티 객체 직접 사용시 SQL에서는 해당 엔티티의 기본 키 값을 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="nf">COUNT</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">id</span><span class="o">)</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>  <span class="c1">// 엔티티의 id 사용</span>
<span class="no">SELECT</span> <span class="nf">COUNT</span><span class="o">(</span><span class="n">m</span><span class="o">)</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span> <span class="c1">// 엔티티 직접 사용</span>
</code></pre></div></div>

<ul>
  <li>두 번쨰 count(m)에서 엔티티 별칭 넘겨줘서 엔티티 직접 사용함</li>
  <li>이렇게 하면 SQL 변환시 해당 엔티티 기본 키 사용하게 바뀜</li>
  <li>∴ 위 두 예제는 동일한 쿼리로 변환됨</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cnt</span>
<span class="k">FROM</span> <span class="n">Member</span> <span class="n">m</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="외래-키-값">외래 키 값</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>

<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span> <span class="s">"SELECT m FROM Member m WHERE m.team = :team"</span><span class="o">;</span>  <span class="c1">// m.team_id 사용하도록 변환됨</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"team"</span><span class="o">,</span> <span class="n">team</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">m.team</code> 이 <code class="language-plaintext highlighter-rouge">m.team_id</code> fk 와 매핑되어 있으므로 <code class="language-plaintext highlighter-rouge">m.team_id</code> 사용하도록 변환됨</li>
</ul>

<p><br />
<br /></p>

<h2 id="10215-named-쿼리-정적-쿼리">10.2.15 Named 쿼리: 정적 쿼리</h2>
<ul>
  <li>JPQL 쿼리는 크게 동적, 정적 쿼리로 구분 가능</li>
  <li><strong>동적 쿼리:</strong> ```em.createQuery(“SELECT …”) 처럼 JPQL을 문자로 오나성해서 직접 넘기는 것. 런타임에 특정 조건 따라 동적으로 구성 가능</li>
  <li><strong>정적 쿼리:</strong> 미리 정의한 쿼리에 이름 부여해서 필요할때 사용하는 쿼리(Named 쿼리). 한번 정의하면 변경 못함
    <ul>
      <li>Named 쿼리는 애플리케이션 로딩 시점에 JPQL 문법 체크 후 미리 파싱해둠</li>
      <li>∴ 오류 확인 빠르고 파싱된 결과 재사용하여 성능상 이점 있음</li>
      <li>또한 변하지 않는 정적 SQL 생성되어 DB 조회 성능 최적화에도 도움됨</li>
      <li><code class="language-plaintext highlighter-rouge">@NamedQuery</code> 어노테이션으로 자바 코드에 작성하거나 XML 문서에 작성 가능</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="named-쿼리를-어노테이션에-정의">Named 쿼리를 어노테이션에 정의</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Named 쿼리 정의</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedQuery</span><span class="o">(</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span> <span class="c1">// Named 쿼리 이름</span>
  <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT m FROM Member m WHERE m.username = :username"</span> <span class="c1">// Named 쿼리로 사용할 쿼리</span>
<span class="o">)</span>
<span class="cm">/*
@NamedQueries({ // named 쿼리 여러개 쓰려면 @NamedQueries 어노테이션 쓰면 됨
  @NamedQuery(
    name = "Member.findByUsername", // Named 쿼리 이름
    query = "SELECT m FROM Member m WHERE m.username = :username" // Named 쿼리로 사용할 쿼리
  ),
  @NamedQuery(
    name = "Member.count", // Named 쿼리 이름
    query = "SELECT COUNT(m) FROM Member m" // Named 쿼리로 사용할 쿼리
  )
})
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="c1">// Named 쿼리 사용</span>
<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">,</span> <span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">em</span><span class="o">.</span><span class="na">createNamedQuery</span><span class="o">(</span><span class="s">"Member.findByUsername"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// EntityManger::createNamedQuery 메소드에 사용할 named 쿼리 이름 넣어서 사용</span>
    <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">username</span><span class="o">)</span>
    <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="named-쿼리를-xml에-정의">Named 쿼리를 XML에 정의</h3>
<ul>
  <li>자바에서 멀티라인 문자 쓰는건 불편한데 xml 로 쓰면 편리함</li>
  <li>그래서 named 쿼리 작성할 때 xml 쓰는게 좀 더 편함</li>
  <li>아래와 같이 xml 에 named 쿼리 정의 후 해당 xml 파일 인식할 수 있도록 persistence.xml 파일에 설정정보 추가
    <ul>
      <li>META-INF/orm.xml 은 JPA가 기본 매핑파일로 인식해서 별도 설정 필요없음</li>
      <li>아래 예제처럼 파일 이름이나 경로가 다를 때 persistence.xml 파일에 설정 정보 추가해줘야 함</li>
    </ul>
  </li>
  <li>XML과 어노테이션에 동일 설정 있으면 XML이 우선권 가짐</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- META-INF/ormMember.xml --&gt;</span>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;entity-mappings</span> <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/persistence/orm"</span> <span class="na">version=</span><span class="s">"2.1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;named-query</span> <span class="na">name=</span><span class="s">"Member.findByUsername"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;query&gt;&lt;CDATA</span><span class="err">[</span>
      <span class="err">SELECT</span> <span class="err">m</span>
      <span class="err">FROM</span> <span class="err">Member</span> <span class="err">m</span>
      <span class="err">WHERE</span> <span class="na">m.username =</span> <span class="s">:username</span>
    <span class="err">]</span><span class="nt">&gt;&lt;/query&gt;</span>
  <span class="nt">&lt;/named-query&gt;</span>

  <span class="nt">&lt;named-query</span> <span class="na">name=</span><span class="s">"Member.count"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;query&gt;</span>SELECT COUNT(m) FROM Member m<span class="nt">&lt;/query&gt;</span>
  <span class="nt">&lt;/named-query&gt;</span>
<span class="nt">&lt;/entity-mappings&gt;</span>

...

<span class="c">&lt;!-- META-INF/persistence.xml --&gt;</span>
...
<span class="nt">&lt;persistence-unit</span> <span class="na">name=</span><span class="s">"jpabook"</span> <span class="nt">&gt;</span>
  <span class="nt">&lt;mapping-file&gt;</span>META-INF/ormMember.xml<span class="nt">&lt;/mapping-file&gt;</span>
...
</code></pre></div></div>

<blockquote>
  <p>XML에서 &amp;, &lt;, &gt; 는 예약 문자라 못씀<br />
대신 <code class="language-plaintext highlighter-rouge">&amp;amp;</code>, <code class="language-plaintext highlighter-rouge">&amp;lt;</code>, <code class="language-plaintext highlighter-rouge">&amp;gt;</code> 써야 함<br />
<code class="language-plaintext highlighter-rouge">&lt;![CDATA[...]]&gt;</code> 쓰면 예약 문자도 그냥 사용 가능</p>
</blockquote>

<p><br />
<br />
<br /></p>

<h1 id="criteria">Criteria</h1>
<ul>
  <li>JPQL을 자바 코드로 작성하도록 도와주는 빌더 클래스 API</li>
  <li>문법 오류를 컴파일 단계에서 잡을 수 있고 동적 쿼리 안전하게 생성할 수 있음</li>
  <li>대신 코드가 복잡하고 장황해 직관적 이해가 힘듬</li>
</ul>

<p><br />
<br /></p>

<h2 id="1031-criteria-기초">10.3.1 Criteria 기초</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m 
  * FROM Member m
  * WHERE m.username='member1'
  * ORDER BY m.age DESC
  */</span>

<span class="c1">// EntityManager 또는 EntityManagerFactory에서 Creatria Builder 얻음</span>
<span class="nc">CriteriaBuilder</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getCriteriaBuilder</span><span class="o">();</span> 

<span class="c1">// Criteria 생성, 반환 타입 지정</span>
<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// FROM 절 생성. 반환된 값 m은 Criteria에서 사용하는 특별한 alias</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// 검색 조건 정의</span>
<span class="nc">Predicate</span> <span class="n">usernameEqual</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="s">"member1"</span><span class="o">);</span>

<span class="c1">// 정렬 조건 정의</span>
<span class="n">javax</span><span class="o">.</span><span class="na">persistence</span><span class="o">.</span><span class="na">criteria</span><span class="o">.</span><span class="na">Order</span> <span class="n">ageDesc</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">desc</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">));</span>

<span class="c1">// 쿼리 생성</span>
<span class="c1">// 위에서 만든 검색, 정렬 조건을 각각 where, orderBy 에 넣어서 원하는 쿼리 만듬</span>
<span class="n">cq</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>  <span class="c1">// SELECT 절 생성</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">usernameEqual</span><span class="o">)</span> <span class="c1">// WHERE 절 생성</span>
  <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">ageDesc</span><span class="o">);</span>  <span class="c1">// ORDER BY 절 생성</span>

<span class="c1">// JPQL 쓸때와 동일하게 EntityManager::createQuery 호출해서 쿼리 만들고 실행</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li><strong>쿼리 루트</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Root&lt;Member&gt; m = cq.from(Member.class);</code> 에서 m이 쿼리 루트</li>
      <li>쿼리 루트는 조회의 시작점</li>
      <li>Createria에서 사용되는 특별한 alias, JPQL의 alias 라 보면 됨</li>
      <li>alias는 엔티티에만 부여 가능</li>
    </ul>
  </li>
  <li><strong>경로 표현식</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">m.get("team").get("name")</code> 은 JPQL <code class="language-plaintext highlighter-rouge">m.team.name</code>과 동일</li>
      <li><code class="language-plaintext highlighter-rouge">m.get()</code> 사용할 때 String 의 경우엔 필요없지만 Integer 등일 때는 <code class="language-plaintext highlighter-rouge">m.&lt;Integer&gt;get()</code> 과 같이 제네릭으로 타입 정보 줘야 함</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1032-criteria-쿼리-생성">10.3.2 Criteria 쿼리 생성</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CriteriaBuilder.createQuery()</code> 메소드로 CriteriaQuery 생성</li>
  <li>CreiteriaQuery 생성시 파라미터로 쿼리 결과에 대한 반환 타입 지정 가능
    <ul>
      <li>이 때 반환 타입을 지정해두면 <code class="language-plaintext highlighter-rouge">em.createQuery()</code> 호출시 따로 지정 안해줘도 됨</li>
      <li>반환 타입 지정 못하거나 둘 이상이면 Object 로 반환받으면 됨</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1033-조회">10.3.3 조회</h2>

<p><br /></p>

<h3 id="조회-대상을-한-건-여러-건-지정">조회 대상을 한 건, 여러 건 지정</h3>
<ul>
  <li>조회 대상 하나만 지정할 땐
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cq.select(m) // SELECT m</code></li>
    </ul>
  </li>
  <li>여러 건 지정시에는 multiselect 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cq.multiselect(m.get("username"), m.get("age")); // SELECT m.username, m.age</code></li>
      <li>또는 아래와 같이 <code class="language-plaintext highlighter-rouge">CriteriaBuilder::array()</code> 써도 됨
        <ul>
          <li><code class="language-plaintext highlighter-rouge">cq.select(cb.array(m.get("username"), m.get("age")));</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="distinct">DISTINCT</h3>
<ul>
  <li>select, multiselect 다음에 <code class="language-plaintext highlighter-rouge">distinct(true)</code> 추가하면 됨
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cq.multiselect(m.get("username"), m.get("age")).distinct(true); // SELECT DISTINCT m.username, m.age</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="new-construct">NEW, construct()</h3>
<ul>
  <li>JPQL에서의 <code class="language-plaintext highlighter-rouge">SELECT NEW 생성자()</code> 구문이 Criteria 에서는 <code class="language-plaintext highlighter-rouge">CriteriaBuilder::construct(클래스 타입, ...)</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cq.select(cb.construct(MemberDTO.class, m.get("username"), m.get("age")));  // SELECT NEW jpabook.domain.MemberDTO(m.username, m.age)</code></li>
    </ul>
  </li>
  <li>Criteria는 코드를 직접 다루기 때문에 JPQL 처럼 패키지명 다 안쓰고 <code class="language-plaintext highlighter-rouge">MemberDTO.class</code> 처럼 간략하게 써도 됨</li>
</ul>

<p><br /></p>

<h3 id="튜플">튜플</h3>
<ul>
  <li>Crietria 에서 제공하는 특별한 반환 객체</li>
  <li>Map 과 비슷함</li>
  <li>튜플로 받으려면 <code class="language-plaintext highlighter-rouge">cb.createTupleQuery()</code> 또는 <code class="language-plaintext highlighter-rouge">cb.createQuery(Tuple.class)</code> 로 Criteria 생성</li>
  <li>select 메소드에서 튜플 검색키로 사용할 전용 alias 필수로 할당해야 함</li>
  <li>선언한 tuple alias로 데이터 조회할 수 있음</li>
  <li>이름 기반이기 때문에 Ojbect[] 로 반환받는거보다 안전함</li>
  <li>튜플로 엔티티도 조회할 수 있음</li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SELECT m.username, m.age FROM Member m</span>

<span class="nc">CriteriaBuilder</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getCriteriaBuilder</span><span class="o">();</span>

<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">createTupleQuery</span><span class="o">();</span>  <span class="c1">// cb.createQuery(Tuple.class);</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">cq</span><span class="o">.</span><span class="na">multiselect</span><span class="o">(</span>
  <span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">).</span><span class="na">alias</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span>  <span class="c1">// 튜플에서 쓸 튜플 alias</span>
  <span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">).</span><span class="na">alias</span><span class="o">(</span><span class="s">"age"</span><span class="o">)</span>
<span class="o">);</span>

<span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Tuple</span> <span class="nl">tuple:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// 위에서 지정한 tuple alias 로 데이터 조회</span>
  <span class="nc">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="c1">// 튜플과 엔티티 조회</span>

<span class="c1">// cq.multiselect(...) 대신 아래처럼 cq.select(cb.tuple(...)) 써도 같은 동작 함</span>
<span class="n">cq</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">tuple</span><span class="o">(</span>
  <span class="n">m</span><span class="o">.</span><span class="na">alias</span><span class="o">(</span><span class="s">"m"</span><span class="o">),</span> <span class="c1">// Member entity 조회, alias m (쿼리 루트인 m과 관련 없음)</span>
  <span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">).</span><span class="na">alias</span><span class="o">(</span><span class="s">"username"</span><span class="o">)</span> <span class="c1">// 단순 값 조회, alias username</span>
<span class="o">));</span>

<span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Tuple</span> <span class="nl">tuple:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>

</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="1034-집합">10.3.4 집합</h2>

<p><br /></p>

<h3 id="group-by">GROUP BY</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cq.groupBy(m.get("team").get("name"))  // GROUP BY m.team.name</code></li>
</ul>

<p><br /></p>

<h3 id="having">HAVING</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cq.having(cb.gt(minAge, 10)) // HAVING min(m.age) &gt; 10</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CriteriaBuilder::gt()</code> === <code class="language-plaintext highlighter-rouge">CriteriaBuilder::greaterThan()</code></li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1035-정렬">10.3.5 정렬</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">cq.orderBy(cb.desc(m.get("age"))); // ORDER BY m.age DESC</code></li>
</ul>

<p><br />
<br /></p>

<h2 id="1036-조인">10.3.6 조인</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">join()</code> 메소드, <code class="language-plaintext highlighter-rouge">JoinType</code> 클래스 사용</li>
  <li>fetch join은 <code class="language-plaintext highlighter-rouge">fetch()</code> 메소드 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">JoinType</span> <span class="o">{</span>
  <span class="no">INNER</span>   <span class="c1">// inner join. JoinType 지정 안하면 default INNER</span>
  <span class="o">,</span> <span class="no">LEFT</span>  <span class="c1">// left outer join</span>
  <span class="o">,</span> <span class="no">RIGHT</span> <span class="c1">// right outer join</span>
<span class="o">}</span>
</code></pre></div></div>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m, t
  * FROM Member m
  *   INNER JOIN m.team t
  * WHERE t.name = 'teamA';
  */</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Join</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Team</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">"team"</span><span class="o">,</span> <span class="nc">JoinType</span><span class="o">.</span><span class="na">INNER</span><span class="o">);</span>  <span class="c1">// 쿼리 루트(m)에서 Member, Team 조인. t는 조인한 team 의 alias</span>

<span class="n">cq</span><span class="o">.</span><span class="na">multiselect</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"name"</span><span class="o">),</span> <span class="s">"teamA"</span><span class="o">));</span>

<span class="o">...</span>

<span class="c1">// FETCH join</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">m</span><span class="o">.</span><span class="na">fetch</span><span class="o">(</span><span class="s">"team"</span><span class="o">,</span> <span class="nc">JoinType</span><span class="o">.</span><span class="na">LFET</span><span class="o">);</span>  <span class="c1">// join 대신 fetch 메소드 사용</span>

<span class="n">cq</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m2</span><span class="o">);</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="1037-서브-쿼리">10.3.7 서브 쿼리</h2>
<ul>
  <li><strong>간단한 서브 쿼리</strong>
    <ul>
      <li>메인 쿼리와 서브 쿼리가 서로 무관한 경우</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m
  * FROM Member m
  * WHERE m.age &gt;= (
  *   SELECT AVG(m2.age) 
  *   FROM Member m2
  * )
  */</span>

<span class="c1">// 서브 쿼리 생성</span>
<span class="nc">SubQuery</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">subQuery</span> <span class="o">=</span> <span class="n">mainQuery</span><span class="o">.</span><span class="na">subquery</span><span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">subQuery</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">subQuery</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">avg</span><span class="o">(</span><span class="n">m2</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">)));</span>

<span class="c1">// 메인 쿼리 생성(위에서 생성한 subQuery 갖다 씀)</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mainQuery</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">mainQuery</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">ge</span><span class="o">(</span><span class="n">m</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">),</span> <span class="n">subQuery</span><span class="o">));</span>
</code></pre></div></div>

<ul>
  <li><strong>상호 관련 서브 쿼리</strong>
    <ul>
      <li>메인 쿼리와 서브 쿼리 간 서로 관련 있을 경우</li>
      <li>서브 쿼리에서 메인 쿼리 정보 사용하려면 메인 쿼리에서 사용한 별칭 얻어야 함
        <ul>
          <li>메인 쿼리의 Root 나 Join 을 통해 생성된 별칭 받아서 사용</li>
          <li><code class="language-plaintext highlighter-rouge">CriteriaQuery::correlate(...)</code> 메소드 사용해서 메인 쿼리의 alias를 서브쿼리에서 사용할 수 있음</li>
          <li></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m
  * FROM Member m
  * WHERE EXISTS (
  *   SELECT t
  *   FROM m.team t
  *   WHERE t.name="teamA"
  * )
  */</span>

<span class="c1">// 서브 쿼리에서 사용되는 메인 쿼리의 alias m</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mainQuery</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// 서브 쿼리 생성</span>
<span class="nc">Subquery</span><span class="o">&lt;</span><span class="nc">Team</span><span class="o">&gt;</span> <span class="n">subQuery</span> <span class="o">=</span> <span class="n">mainQuery</span><span class="o">.</span><span class="na">subquery</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">subM</span> <span class="o">=</span> <span class="n">subQuery</span><span class="o">.</span><span class="na">correlate</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>  <span class="c1">// main query의 alias 가져옴. main query 의 m을 sub query 에선 subM으로 사용</span>

<span class="nc">Join</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Team</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">subM</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">"team"</span><span class="o">);</span>
<span class="n">subQuery</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"name"</span><span class="o">),</span> <span class="s">"teamA"</span><span class="o">));</span>

<span class="c1">// 메인 쿼리 생성</span>
<span class="n">mainQuery</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">.</span><span class="na">qhere</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">subQuery</span><span class="o">));</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">mainQuery</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="1038-in-식">10.3.8 IN 식</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">in(...).value(...).value(...)...</code> 형태
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cq.where(cb.in(m.get("username")).value("member1").value("member2"));  // WHERE m.username IN ("member1", "meber2")</code></li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1039-case-식">10.3.9 CASE 식</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">selectCase()</code>, <code class="language-plaintext highlighter-rouge">when()</code>, <code class="language-plaintext highlighter-rouge">otherwise()</code> 메소드 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m.username,
  *   CASE 
  *     WHEN m.age &gt;= 60 THEN 600
  *     WHEN m.age &lt;= 15 THEN 500
  *     ELSE 1000
  *   END
  * FROM Member m
  */</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">cq</span><span class="o">.</span><span class="na">multiselect</span><span class="o">(</span>
  <span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span>
  <span class="n">cb</span><span class="o">.</span><span class="na">selectCase</span><span class="o">()</span>
    <span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">ge</span><span class="o">(</span><span class="n">m</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">),</span> <span class="mi">60</span><span class="o">),</span> <span class="mi">600</span><span class="o">)</span>
    <span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">le</span><span class="o">(</span><span class="n">m</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">),</span> <span class="mi">15</span><span class="o">),</span> <span class="mi">500</span><span class="o">)</span>
    <span class="o">.</span><span class="na">otherwise</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="10310-파라미터-정의">10.3.10 파라미터 정의</h2>
<ul>
  <li>JPQL에서 <code class="language-plaintext highlighter-rouge">:param</code> 으로 파라미터 정의한 것 처럼 Criteria도 파라미터 정의 가능
    <ul>
      <li><code class="language-plaintext highlighter-rouge">CriteriaBuilder::parameter(타입, 파라미터 이름)</code> 메소드로 파라미터 정의</li>
      <li><code class="language-plaintext highlighter-rouge">setParameter(파라미터 이름, 파라미터 값)</code> 으로 사용할 값 바인딩</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m
  * FROM Member m
  * WHERE m.username = :usernameParam
  */</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">cq</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="n">cb</span><span class="o">.</span><span class="na">parameter</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"usernameParam"</span><span class="o">)));</span> <span class="c1">// 파라미터 정의</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"usernameParam"</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">)</span> <span class="c1">// 파라미터 바인딩</span>
  <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="10311-네이티브-함수-호출">10.3.11 네이티브 함수 호출</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CriteriaBuilder::function(...)</code> 메소드 쓰면 됨</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT SUM(m.age)
  * FROM Member m
  */</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">Expression</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">function</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">function</span><span class="o">(</span><span class="s">"SUM"</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">));</span> <span class="c1">// SUM SQL 함수 호출</span>

<span class="n">cq</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">function</span><span class="o">);</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="10312-동적-쿼리">10.3.12 동적 쿼리</h2>
<ul>
  <li>다양한 검색 조건 따라 실행 시점에 쿼리 생성하는 것</li>
  <li>파라미터 바인딩처럼 파라미터 값만 바뀌는게 아니라 쿼리 자체가 달라짐
    <ul>
      <li>ex) 날짜, 제목, 글 내용 가지고 검색 가능한 게시판 있을 때 제목만 입력하면 제목만으로 쿼리, 날짜까지 입력하면 제목, 날짜로 쿼리하는 등</li>
    </ul>
  </li>
  <li>문자 기반인 JPQL 로 동적 쿼리 작성 시 버그 날 확률도 높고 불편함</li>
  <li>Criteria는 코드기반이라 좀 낫긴 한데 그래도 코드 읽기 힘들긴 함
    <ul>
      <li>최소한 공백, where, and 위치로 인한 에러는 안남</li>
    </ul>
  </li>
</ul>

<details>
<summary style="color:rgb(200, 50, 50)"><b>코드</b></summary>
<div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** JPQL
  * SELECT m
  * FROM Member m
  *   INNER JOIN m.team t
  * WHERE m.age = 10
  *   AND t.name = "teamA"
  */</span>

<span class="c1">// 검색 조건</span>
<span class="nc">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">teamName</span> <span class="o">=</span> <span class="s">"teamA"</span><span class="o">;</span>

<span class="c1">// Criteria 동적 쿼리 생성</span>
<span class="nc">CriteriaBuilder</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getCriteriaBuilder</span><span class="o">();</span>
<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">cq</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Join</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Team</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">"team"</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Predicate</span><span class="o">&gt;</span> <span class="n">criteria</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Predicate</span><span class="o">&gt;();</span>

<span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">criteria</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">get</span><span class="o">(</span><span class="s">"age"</span><span class="o">),</span> <span class="n">cb</span><span class="o">.</span><span class="na">parameter</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"age"</span><span class="o">)));</span>
<span class="k">if</span> <span class="o">(</span><span class="n">username</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">criteria</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="n">cb</span><span class="o">.</span><span class="na">parameter</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"username"</span><span class="o">)));</span>
<span class="k">if</span> <span class="o">(</span><span class="n">teamName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">criteria</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"name"</span><span class="o">),</span> <span class="n">cb</span><span class="o">.</span><span class="na">parameter</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"teamName"</span><span class="o">)));</span>

<span class="n">cq</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">criteria</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Predicate</span><span class="o">[</span><span class="mi">0</span><span class="o">])));</span>

<span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">username</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">username</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">teamName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"teamName"</span><span class="o">,</span> <span class="n">teamName</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>    </div>

  </div>
</details>

<p><br />
<br /></p>

<h2 id="10313-함수-정리">10.3.13 함수 정리</h2>
<ul>
  <li>Criteria는 JPQL 빌더 역할을 하므로 JPQL 함수를 코드로 지원</li>
  <li>대부분 CriteriaBuilder 에 정의되어 있음</li>
</ul>

<p><br />
<br /></p>

<h2 id="10314-criteria-메타-모델-api">10.3.14 Criteria 메타 모델 API</h2>
<ul>
  <li>Criteria는 코드 기반이지만 <code class="language-plaintext highlighter-rouge">m.get("age");</code>에서의 “age” 처럼 문자가 사용됨</li>
  <li>이로 인해서 컴파일 시점에 발견하지 못하는 에러 생길 수 있음</li>
  <li>메타 모델 API 사용하면 이런 부분도 코드로 작성 가능</li>
  <li>메타 모델 클래스를 코드 자동 생성기를 통해 생성해서 사용하면 됨</li>
  <li>코드 생성기는 보통 maven, gradle 등의 빌드 도구를 써서 실행
    <ul>
      <li>디펜던시랑 플러그인 설정 후 빌드 도구 compile 하면 메타 모델 클래스 생성됨</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br /></p>

<h1 id="104-querydsl">10.4 QueryDSL</h1>
<ul>
  <li>Criteria 처럼 JPQL 빌더 역할 함</li>
</ul>

<p><br />
<br /></p>

<h2 id="1041-querydsl-설정">10.4.1 QueryDSL 설정</h2>
<ul>
  <li><strong>pom.xml 추가</strong>
    <ul>
      <li>querydsl-jpa: QueryDSL JPA 라이브러리</li>
      <li>querydsl-apt: Query Type(Q) 생성에 필요한 라이브러리</li>
    </ul>
  </li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>com.mysema.querydsl<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>querydsl-jpa<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>3.6.3<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>com.mysema.querydsl<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>querydsl-apt<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>3.6.3<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;scope&gt;</span>provided<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<ul>
  <li><strong>환경설정</strong>
    <ul>
      <li>queryDSL 사용시 Creiteria의 메타 모델 클래스처럼 엔티티를 기반으로한 Query Type 이라는 쿼리용 클래스 생성해야 함</li>
      <li>이를 위해 Query Type 생성용 플러그인을 pom.xml 에 추가</li>
      <li>설정 다 하고 mvn compile 돌리면 아래에서 지정한 target/generated-sources 에 Q로 시작하는 쿼리 타입들이 생성됨</li>
    </ul>
  </li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;build&gt;</span>
  <span class="nt">&lt;plugins&gt;</span>
    <span class="nt">&lt;plugin&gt;</span>
      <span class="nt">&lt;groupId&gt;</span>com.mysema.maven<span class="nt">&lt;/groupId&gt;</span>
      <span class="nt">&lt;artifactId&gt;</span>apt-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
      <span class="nt">&lt;version&gt;</span>1.1.3<span class="nt">&lt;/version&gt;</span>
      <span class="nt">&lt;excutions&gt;</span>
        <span class="nt">&lt;excution&gt;</span>
          <span class="nt">&lt;goals&gt;</span>
            <span class="nt">&lt;goal&gt;</span>process<span class="nt">&lt;/goal&gt;</span>
          <span class="nt">&lt;/goals&gt;</span>
          <span class="nt">&lt;configuration&gt;</span>
            <span class="nt">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="nt">&lt;/outputDirectory&gt;</span>
            <span class="nt">&lt;processor&gt;</span>com.mysema.query.apt.jpa.JPAAnnotationProcessor<span class="nt">&lt;/processor&gt;</span>
          <span class="nt">&lt;/configuration&gt;</span>
        <span class="nt">&lt;/excution&gt;</span>
      <span class="nt">&lt;/excutions&gt;</span>
    <span class="nt">&lt;/plugin&gt;</span>
  <span class="nt">&lt;/plugins&gt;</span>
<span class="nt">&lt;/build&gt;</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="1042-시작">10.4.2 시작</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**JPQL
  * SELECT m
  * FROM Member m
  * WHERE m.name = 'member1'
  * ORDER BY m.name DESC
  */</span>

<span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>

<span class="c1">// 엔티티 매니저로 JPAQuery 객체 생성</span>
<span class="nc">JPAQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAQuery</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>

<span class="c1">// 사용할 Query Type 생성, JPQL에서 사용할 alias 부여</span>
<span class="nc">QMember</span> <span class="n">qMember</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QMember</span><span class="o">(</span><span class="s">"m"</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">qMember</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">qMember</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"member1"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">qMember</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">desc</span><span class="o">())</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">qMember</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="기본-q-생성">기본 Q 생성</h3>
<ul>
  <li>Query Type(Q)는 기본 인스턴스를 보관하고 있어서 alias 지정 안하고 걍 기본 인스턴스 써도 됨
    <ul>
      <li><code class="language-plaintext highlighter-rouge">QMember qMember = QMember.meber;  // 기본 인스턴스 사용</code></li>
    </ul>
  </li>
  <li>하지만 같은 엔티티 조인하거나 서브쿼리에 사용하면 같은 alias 사용되므로 직접 지정해서 써야 함
    <ul>
      <li><code class="language-plaintext highlighter-rouge">QMember qMember = new QMember("m"); // alias 직접 지정</code></li>
    </ul>
  </li>
  <li>Q의 기본 인스턴스를 static 으로 임포트하면 아래와 같이 더 편리하게 코드 작성 가능</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Query Type 의 기본 인스턴스를 static으로 import</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">jpabook</span><span class="o">.</span><span class="na">jpashop</span><span class="o">.</span><span class="na">domain</span><span class="o">.</span><span class="na">QMember</span><span class="o">.</span><span class="na">member</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">basic</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>

  <span class="nc">JPAQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAQuery</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">query</span>
    <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="c1">// 기본 인스턴스 걍 갖다 씀</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"member1"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">desc</span><span class="o">())</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="1043-검색-조건-쿼리">10.4.3 검색 조건 쿼리</h2>
<ul>
  <li>where 절에는 and, or 사용 가능
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.where(item.name.eq("itemA").and(item.price.gt(20000)))</code></li>
    </ul>
  </li>
  <li>다음과 같이 and, or 없이 여러 검색 조건 넣으면 자동으로 and 연산 됨
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.where(item.name.eq("itemA"), item.price.gt(20000))</code></li>
    </ul>
  </li>
  <li>이 외에도 between, contains, startWith 등 제공</li>
</ul>

<p><br />
<br /></p>

<h2 id="1044-결과-조회">10.4.4 결과 조회</h2>
<ul>
  <li>쿼리 작성 완료 후 결과 조회 메소드 호출할 때 실제 DB 조회함</li>
  <li>보통 <code class="language-plaintext highlighter-rouge">uniqueResult()</code> 나 <code class="language-plaintext highlighter-rouge">list()</code> 사용하고 파라미터로 프로젝션 대상 넘겨줌
    <ul>
      <li><strong>uniqueResult()</strong>
        <ul>
          <li>조회 결과 단건일 때 사용</li>
          <li>결과 없으면 null, 두 개 이상이면 예외 발생</li>
        </ul>
      </li>
      <li><strong>singleResult()</strong>
        <ul>
          <li>결과가 두 개 이상이면 그중 처음 데이터를 반환</li>
        </ul>
      </li>
      <li><strong>list()</strong>
        <ul>
          <li>결과가 두 개 이상일 때 사용</li>
          <li>결과 없으면 빈 컬렉션 반환</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1045-페이징과-정렬">10.4.5 페이징과 정렬</h2>
<ul>
  <li>정렬은 orderBy와 Q 가 제공하는 <code class="language-plaintext highlighter-rouge">asc()</code>, <code class="language-plaintext highlighter-rouge">desc()</code> 메소드 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.orderBy(item.price.desc(), item.stockQuantity.asc())</code></li>
    </ul>
  </li>
  <li>페이징은 <code class="language-plaintext highlighter-rouge">offset()</code>, <code class="language-plaintext highlighter-rouge">limit()</code> 메소드 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.offset(10).limit(20)</code></li>
      <li>이거 대신에 <code class="language-plaintext highlighter-rouge">restrict()</code> 메소드에 <code class="language-plaintext highlighter-rouge">com.mysema.query.QueryModifiers</code> 를 파라미터로 사용해도 됨
        <ul>
          <li><code class="language-plaintext highlighter-rouge">restrict(new QueryModifiers(20L, 10L)) // 각각 limit, offset</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>실제 페이징 처리 하려면 검색된 전체 데이터 수 알아야 하므로 <code class="language-plaintext highlighter-rouge">list()</code> 대신 <code class="language-plaintext highlighter-rouge">listResults()</code>사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">listResults()</code> 사용시 전체 데이터 조회 위한 count 쿼리를 한 번 더 실행함</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResults</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="mi">10000</span><span class="o">))</span>
  <span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
  <span class="o">.</span><span class="na">listResults</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>

<span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getTotal</span><span class="o">();</span> <span class="c1">// 검색된 전체 데이터 수</span>
<span class="kt">long</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getLimit</span><span class="o">();</span> <span class="c1">// 조회할 때 쓴 limit</span>
<span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getOffset</span><span class="o">();</span> <span class="c1">// 조회할 때 쓴 offset</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getResults</span><span class="o">();</span> <span class="c1">// 조회된 데이터</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="1046-그룹">10.4.6 그룹</h2>
<ul>
  <li>groupBy 사용, 그룹화된 결과 제한하려면 having 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.groupBy(item.price).having(item.price.gt(1000))</code></li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1047-조인">10.4.7 조인</h2>
<ul>
  <li>innerJoin, leftJoin, rightJoin, fullJoin 사용 가능</li>
  <li>jPAL의 on, 성능 최적화를 위한 fetch 조인도 가능</li>
  <li>첫 번째 파라미터에 조인 대상, 두 번째 파라미터에 alias 로 사용할 Query Type 지정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">join(조인 대상, alias 로 사용할 쿼리 타입)</code></li>
    </ul>
  </li>
  <li>join에 on 사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.leftJoin(order.orderItems, orderItem).on(orderItem.count.gt(2))</code></li>
    </ul>
  </li>
  <li>fetch join
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.innerJoin(order.member, member).fetch()</code></li>
      <li><code class="language-plaintext highlighter-rouge">.leftJoin(order.orderItems.orderItem).fetch()</code></li>
    </ul>
  </li>
  <li>from 절에 여러 조인 사용하는 세타 조인 방법
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.from(order, member)</code></li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1048-서브-쿼리">10.4.8. 서브 쿼리</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">com.mysema.query.jpa.JPASubQuery</code> 를 생성해서 사용</li>
  <li>서브 쿼리 결과 하나면 <code class="language-plaintext highlighter-rouge">unique()</code>, 여러 건이면 <code class="language-plaintext highlighter-rouge">list()</code></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 결과 한 건</span>
<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">QItem</span> <span class="n">itemSub</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QItem</span><span class="o">(</span><span class="s">"itemSub"</span><span class="o">);</span>

<span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">JPASubQuery</span><span class="o">()</span>
        <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">itemSub</span><span class="o">)</span>
        <span class="o">.</span><span class="na">unique</span><span class="o">(</span><span class="n">itemSub</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">max</span><span class="o">())</span>
      
  <span class="o">)).</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>

<span class="c1">// 결과 여러 건</span>
<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">QItem</span> <span class="n">itemSub</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QItem</span><span class="o">(</span><span class="s">"itemSub"</span><span class="o">);</span>

<span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">JPASubQuery</span><span class="o">()</span>
        <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">itemSub</span><span class="o">)</span>
        <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">itemSub</span><span class="o">.</span><span class="na">name</span><span class="o">))</span>
        <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">itemSub</span><span class="o">)</span>
      
  <span class="o">)).</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="1049-프로젝션과-결과-반환">10.4.9 프로젝션과 결과 반환</h2>
<ul>
  <li>SELECT 절에 조회 대상을 지정 하는 것 =&gt; 프로젝션</li>
  <li>QueryDSL 에서는 결과 조회 메소드의 파라미터로 프로젝션 대상 지정</li>
</ul>

<p><br /></p>

<h3 id="프로젝션-대상-하나">프로젝션 대상 하나</h3>
<ul>
  <li>해당 타입으로 반환
    <ul>
      <li><code class="language-plaintext highlighter-rouge">List&lt;String&gt; result = query.from(item).list(item.name);  // 프로젝션 대상이 name 하나라 String 으로 바로 반환</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="여러-컬럼-반환과-튜플">여러 컬럼 반환과 튜플</h3>
<ul>
  <li>```com.mysema.query.Tuple`` 이라는 Map 과 유사한 내부 타입 사용</li>
  <li>조회 결과는 <code class="language-plaintext highlighter-rouge">tuple.get()</code> 메소드에 조회한 Query Type 지정하면 됨</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">);</span> <span class="c1">// === .list(new QTuple(item.name, item.price));</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Tuple</span> <span class="nl">tuple:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"name = "</span> <span class="o">+</span> <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">));</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"price = "</span> <span class="o">+</span> <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="빈-생성">빈 생성</h3>
<ul>
  <li>쿼리 결과를 엔티티가 아닌 다른 특정 객체로 받으려면 Bean population 기능을 사용하면 됨</li>
  <li>QueryDSL 은 객체를 생성하는 다양한 방법을 제공
    <ul>
      <li>프로퍼티 접근(Setter)</li>
      <li>필드 직접 접근</li>
      <li>생성자 사용</li>
    </ul>
  </li>
  <li>원하는 방법 지정하려면 <code class="language-plaintext highlighter-rouge">com.mysema.query.types.Projections</code> 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DTO</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemDTO</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>

  <span class="c1">// constructor, getter, setter...</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>

<span class="c1">// 프로퍼티 접근(Setter)</span>
<span class="c1">// Setter 사용해서 값 채워줌</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ItemDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span>
    <span class="nc">Projections</span><span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="nc">ItemDTO</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">)</span> <span class="c1">// 쿼리 결과와 매핑할 프로퍼티 이름 다르면 as 사용</span>
  <span class="o">);</span>

<span class="c1">// field 직접 접근</span>
<span class="c1">// Projections.fields() 메소드 사용시 필드에 직접 접근해서 값 채워줌</span>
<span class="c1">// 필드를 private으로 설정해도 동작함</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ItemDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span>
    <span class="nc">Projections</span><span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="nc">ItemDTO</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">)</span>
  <span class="o">);</span>

<span class="c1">// constructor 사용</span>
<span class="c1">// 생성자 이용해서 값 채움</span>
<span class="c1">// 지정한 프로젝션과 파라미터 순서 동일한 생성자가 필요</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ItemDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span>
    <span class="nc">Projections</span><span class="o">.</span><span class="na">constructor</span><span class="o">(</span><span class="nc">ItemDTO</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">)</span>
  <span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="disctinct">DISCTINCT</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">query.distinct().from(item)...</code></li>
</ul>

<p><br />
<br /></p>

<h2 id="10410-수정-삭제-배치-쿼리">10.4.10 수정, 삭제 배치 쿼리</h2>
<ul>
  <li>QueryDSL도 수정, 삭제 같은 배치 쿼리 지원
    <ul>
      <li>JPQL 배치 쿼리와 같이 영속성 컨텍스트를 무시하고 DB에 직접 쿼리</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 수정 배치 쿼리 예시</span>
<span class="nc">JPAUpdateClause</span> <span class="n">updateClause</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAUpdateClause</span><span class="o">(</span><span class="n">em</span><span class="o">,</span> <span class="n">item</span><span class="o">);</span> <span class="c1">// 수정 배치 쿼리는 JPAUpdateClause 사용</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">updateCluase</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"itemA"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">))</span>
  <span class="o">.</span><span class="na">execute</span><span class="o">();</span>

<span class="o">...</span>

<span class="c1">// 삭제 배치 쿼리 예시</span>
<span class="nc">JPADeleteClause</span> <span class="n">deleteClause</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPADeleteClause</span><span class="o">(</span><span class="n">em</span><span class="o">,</span> <span class="n">item</span><span class="o">);</span> <span class="c1">// 삭제 배치 쿼리는 JPADeleteClause 사용</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">deleteClause</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"itemA"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">execute</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="10411-동적-쿼리">10.4.11 동적 쿼리</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">com.mysema.query.BooleanBuilder</code> 사용하면 특정 조건에 따른 동적 쿼리 생성 가능</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchParam</span> <span class="n">param</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SearchParam</span><span class="o">();</span>
<span class="n">param</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"itemA"</span><span class="o">)</span>
<span class="n">param</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>

<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>

<span class="nc">BooleanBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BooleanBuilder</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
  <span class="n">builder</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
<span class="o">}</span>
<span class="n">ig</span> <span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">builder</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()));</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">builder</span><span class="o">)</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="10412-메소드-위임">10.4.12 메소드 위임</h2>
<ul>
  <li>delegate methods 기능 사용하면 Query Type 에 검색 조건 직접 정의 가능
    <ul>
      <li>우선 static method를 만들고 <code class="language-plaintext highlighter-rouge">@QueryDelegate</code> 어노테이션에 속성으로 이 기능을 적용할 엔티티를 지정</li>
      <li>static method 의 첫 번째 파라미터에는 대상 엔티티의 Query Type 을 지정하고 나머지는 필요한 파라미터를 정의</li>
    </ul>
  </li>
  <li>String, Date 등 자바 기본 내장 타입에도 메소드 위임 기능 사용 가능</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// delegate methods 기능으로 검색 조건 정의</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemExpression</span> <span class="o">{</span>
  <span class="nd">@QueryDelegate</span><span class="o">(</span><span class="nc">Item</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">BooleanExpression</span> <span class="nf">isExpensive</span><span class="o">(</span><span class="nc">QItem</span> <span class="n">item</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="c1">// 실제 Query Type 에 생성된 결과</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QItem</span> <span class="kd">extends</span> <span class="nc">EntityPathBase</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="kd">public</span> <span class="n">com</span><span class="o">.</span><span class="na">mysema</span><span class="o">.</span><span class="na">query</span><span class="o">.</span><span class="na">types</span><span class="o">.</span><span class="na">expr</span><span class="o">.</span><span class="na">BooleanExpression</span> <span class="nf">isExpensive</span><span class="o">(</span><span class="nc">Intger</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">ItemExpression</span><span class="o">.</span><span class="na">isExpensive</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">price</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="o">...</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="c1">// delegate methods 기능 사용</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span>
  <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
  <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">isExpensive</span><span class="o">(</span><span class="mi">30000</span><span class="o">))</span>
  <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>

<p><br />
<br />
<br /></p>

<h1 id="105-네이티브-sql">10.5 네이티브 SQL</h1>
<ul>
  <li>JPQL은 특정 DB에 종속적인 기능은 지원 X, 대신 JPA는 특정 DB 종속적 기능 사용할 수 있는 다양한 방법 열어두었고 구현체들은 더 다양한 방법 지원함
    <ul>
      <li>특정 데이터베이스만 지원하는 함수
        <ul>
          <li>JPQL에서 네이티브 SQL 함수 호출 가능(JPA 2.1)</li>
          <li>하이버네이트는 DB 방언에 각 DB 종속적 함수들 정의해두었음. 직접 호출할 함수 정의도 가능</li>
        </ul>
      </li>
      <li>특정 데이터베이스만 지원하는 SQL 쿼리 힌트
        <ul>
          <li>하이버네이트 등 몇 JPA 구현제들이 지원</li>
        </ul>
      </li>
      <li>인라인 뷰(From 절에서 사용하는 서브 쿼리), UNION, INTERSECT
        <ul>
          <li>일부 JPA 구현체들이 지원</li>
        </ul>
      </li>
      <li>stored procedure
        <ul>
          <li>JPQL에서 스토어드 프로시저 호출 가능(JPA 2.1)</li>
        </ul>
      </li>
      <li>특정 데이터베이스만 지원하는 문법
        <ul>
          <li>오라클 CONNECT BY 처럼 너무 종속적인건 지원 안함</li>
          <li>이럴 땐 네이티브 SQL 사용해야 함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>여러 이유로 JPQL 사용 못할 때 직접 SQL 사용할 수 있는 기능 =&gt; 네이티브 SQL
    <ul>
      <li>JPQL 사용하면 JPA 가 SQL 생성</li>
      <li>네이티브 SQL 사용하면 개발자가 직접 생성</li>
      <li>네이티브 SQL 써도 JPA 가 지원하는 영속성 컨텍스트의 기능 그대로 사용할 수 있음</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1051-네이티브-sql-사용">10.5.1 네이티브 SQL 사용</h2>

<p><br /></p>

<h3 id="엔티티-조회">엔티티 조회</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">em.createNativeQuery(SQL, 결과 클래스)</code>
    <ul>
      <li>첫 번째 파라미터는 네이티브 SQL, 두 번째 파라미터는 조회할 엔티티 클래스의 타입</li>
    </ul>
  </li>
  <li>JPQL과 거의 비스샇지만 실제 DB sql 사용하며 위치기반 파라미터만 지원함</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> 
  <span class="s">"SELECT id, age, name, team_id "</span> <span class="o">+</span>
  <span class="s">"FROM member "</span> <span class="o">+</span>
  <span class="s">"WHERE age &gt; ?"</span><span class="o">;</span>

<span class="nc">Query</span> <span class="n">nativeQuery</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// native SQL은 type 정보 줘도 TypeQuery 아니고 Query 임</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">20</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">nativeQuery</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="값-조회">값 조회</h3>
<ul>
  <li>여러 값으로 조회하려면 <code class="language-plaintext highlighter-rouge">em.createNativeQuery(SQL)</code> 처럼 두 번째 파라미터 사용 안하면 됨</li>
  <li>이렇게 하면 조회한 값들이 Object[] 에 담겨서 반환됨</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> 
  <span class="s">"SELECT id, age, name, team_id "</span> <span class="o">+</span>
  <span class="s">"FROM member "</span> <span class="o">+</span>
  <span class="s">"WHERE age &gt; ?"</span><span class="o">;</span>

<span class="nc">Query</span> <span class="n">nativeQuery</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">nativeQuery</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="nl">row:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"id = "</span> <span class="o">+</span> <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"age = "</span> <span class="o">+</span> <span class="n">row</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"name = "</span> <span class="o">+</span> <span class="n">row</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"team_id = "</span> <span class="o">+</span> <span class="n">row</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="결과-매핑-사용">결과 매핑 사용</h3>
<ul>
  <li>엔티티와 스칼라 값을 함께 조회하는 것처럼 매핑 복잡해지면 <code class="language-plaintext highlighter-rouge">@SqlResultSetMapping</code>을 정의해서 결과 매핑 사용해야 함</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 결과 매핑 정의</span>
<span class="nd">@Entity</span>
<span class="nd">@SqlResultSetMapping</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"memberWithOrderCount"</span><span class="o">,</span>
  <span class="n">entities</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@EntityResult</span><span class="o">(</span><span class="n">entityClass</span> <span class="o">=</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)},</span> <span class="c1">// 여러 엔티티랑 매핑 가능</span>
  <span class="n">columns</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@ColumnResult</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_count"</span><span class="o">)}</span> <span class="c1">// 여러 컬럼이랑 매핑 가능</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="o">...</span>

<span class="c1">// Native SQL 쿼리</span>
<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span>
  <span class="s">"SELECT m.id age, name, team_id, i.order_count "</span> <span class="o">+</span>
  <span class="s">"FROM member m "</span> <span class="o">+</span>
  <span class="s">" LEFT JOIN "</span> <span class="o">+</span>
  <span class="s">"   (SELECT im.id, COUNT(*) AS order_count "</span> <span class="o">+</span>
  <span class="s">"   FROM orders o, member im "</span> <span class="o">+</span>
  <span class="s">"   WHERE o.member_id = im.id) i "</span> <span class="o">+</span>
  <span class="s">" ON m.id = i.id"</span><span class="o">;</span>

<span class="nc">Query</span> <span class="n">nativeQuery</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="s">"memberWithOrderCount"</span><span class="o">);</span>  <span class="c1">// 위에서 정의한 결과 매핑 memberWithOrderCount 를 조회할 타입 파라미터로 사용</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">nativeQuery</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="nl">row:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Member</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
  <span class="nc">BigInteger</span> <span class="n">orderCount</span> <span class="o">=</span> <span class="o">(</span><span class="nc">BigIntiger</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"member = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">);</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"orderCount = "</span> <span class="o">+</span> <span class="n">orderCount</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>결과 매핑시 <code class="language-plaintext highlighter-rouge">@FieldResult</code> 를 사용해서 엔티티의 필드명과 컬럼명을 직접 매핑할 수 있음</li>
  <li>이걸로 설정한 건 엔티티의 필드에 설정한 <code class="language-plaintext highlighter-rouge">@Column</code> 보다 우선됨</li>
  <li>하나라도 <code class="language-plaintext highlighter-rouge">@FieldResult</code> 쓰면 나머지 필드도 다 써야함</li>
  <li>두 엔티티 조회 시 컬럼명 중복될 때도 <code class="language-plaintext highlighter-rouge">@FieldResult</code> 사용
    <ul>
      <li>alias로 충돌하는 컬럼명 적당히 바꿔놓고 <code class="language-plaintext highlighter-rouge">@FieldResult</code>로 alias랑 엔티티 필드 매핑해주면 됨</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 결과 매핑 정의</span>
<span class="nd">@SqlResultSetMapping</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"OrderResults"</span><span class="o">,</span>
  <span class="n">entities</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@EntityResult</span><span class="o">(</span><span class="n">entityClass</span><span class="o">=</span><span class="n">com</span><span class="o">.</span><span class="na">acme</span><span class="o">.</span><span class="na">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">fields</span> <span class="o">=</span> <span class="o">{</span>
      <span class="nd">@FieldResult</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"id"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="s">"order_id"</span><span class="o">),</span>
      <span class="nd">@FieldResult</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"quantity"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="s">"order_quantity"</span><span class="o">),</span>
      <span class="nd">@FieldResult</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"item"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="s">"order_item"</span><span class="o">)</span>
    <span class="o">})</span>
  <span class="o">},</span>
  <span class="n">columns</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@ColumnResult</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"item_name"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">)</span>

<span class="c1">// Native SQL 쿼리</span>
<span class="nc">Query</span> <span class="n">q</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span>
  <span class="s">"SELECT o.id AS order_id, "</span> <span class="o">+</span>
  <span class="s">" o.quantity AS order_quantity, "</span> <span class="o">+</span>
  <span class="s">" o.item AS order_item, "</span> <span class="o">+</span>
  <span class="s">" i.name AS item_name "</span> <span class="o">+</span>
  <span class="s">"FROM order o, item i "</span> <span class="o">+</span>
  <span class="s">"WHERE (order_quantity &gt; 25) "</span> <span class="o">+</span>
  <span class="s">" AND (order_item = i.id_)"</span><span class="o">,</span> <span class="s">"OrderResults"</span><span class="o">);</span>
<span class="o">)</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="결과-매핑-어노테이션-result-set-mapping">결과 매핑 어노테이션 (Result set mapping)</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@SqlResultSetMapping</code> 속성</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">속성</th>
      <th style="text-align: left">기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">name</td>
      <td style="text-align: left">결과 매핑 이름</td>
    </tr>
    <tr>
      <td style="text-align: left">entities</td>
      <td style="text-align: left">@EntityResult를 사용해서 엔티티를 결과로 매핑</td>
    </tr>
    <tr>
      <td style="text-align: left">columns</td>
      <td style="text-align: left">@ColumnResult를 사용해서 컬럼을 결과로 매핑</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@EntityResult</code> 속성</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">속성</th>
      <th style="text-align: left">기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">entityClass</td>
      <td style="text-align: left">결과로 사용할 엔티티 클래스 지정</td>
    </tr>
    <tr>
      <td style="text-align: left">fields</td>
      <td style="text-align: left">@FieldResult를 사용해서 결과 컬럼을 필드와 매핑</td>
    </tr>
    <tr>
      <td style="text-align: left">discriminatorColumn</td>
      <td style="text-align: left">엔티티의 인스턴스 타입을 구분하는 필드(상속시 사용)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@FieldResult</code> 속성</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">속성</th>
      <th style="text-align: left">기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">name</td>
      <td style="text-align: left">결과를 받을 필드명</td>
    </tr>
    <tr>
      <td style="text-align: left">column</td>
      <td style="text-align: left">결과 컬럼명</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@CloumnResult</code> 속성</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">속성</th>
      <th style="text-align: left">기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">name</td>
      <td style="text-align: left">결과 컬럼명</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h2 id="1052-named-네이티브-sql">10.5.2 Named 네이티브 SQL</h2>
<ul>
  <li>JPQL 처럼 Named Native SQL 로 정적 SQL 작성 가능</li>
  <li><code class="language-plaintext highlighter-rouge">@NamedNativeQuery</code> 어노테이션으로 정의하거나 xml에 등록해서 사용</li>
  <li>일반적인 Native SQL 처럼 <code class="language-plaintext highlighter-rouge">em.createNativeQuery()</code> 대신 <code class="language-plaintext highlighter-rouge">em.createNamedQuery()</code> 메소드를 사용함
    <ul>
      <li>TypedQuery 사용할 수 있음</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 어노테이션으로 등록</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedNativeQuery</span><span class="o">(</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.memberSQL"</span><span class="o">,</span>
  <span class="n">query</span> <span class="o">=</span> 
    <span class="s">"SELECT id, age, name, team_id "</span> <span class="o">+</span>
    <span class="s">"FROM member "</span> <span class="o">+</span>
    <span class="s">"WHERE age &gt; ?"</span><span class="o">,</span> 
  <span class="n">resultClass</span> <span class="o">=</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="o">...</span>

<span class="c1">// 결과 매핑 사용</span>
<span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">nativeQuery</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNamedQuery</span><span class="o">(</span><span class="s">"Member.memberSQL"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParamter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">20</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="namednativequery">@NamedNativeQuery</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">속성</th>
      <th style="text-align: left">기능</th>
      <th style="text-align: left">기본값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">name</td>
      <td style="text-align: left">네임드 쿼리 이름(필수)</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">query</td>
      <td style="text-align: left">SQL 쿼리(필수)</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">hints</td>
      <td style="text-align: left">벤더 종속적인 hint(SQL 힌트가 아닌 JPA 구현체에 제공하는 힌트)</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">resultClass</td>
      <td style="text-align: left">결과 클래스</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">resultSetMapping</td>
      <td style="text-align: left">결고 ㅏ매핑 사용</td>
      <td style="text-align: left"> </td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h2 id="1053-네이티브-sql-xml에-정의">10.5.3 네이티브 SQL XML에 정의</h2>
<ul>
  <li>어노테이션 대신 xml 에 다음과 같이 정의해서도 사용할 수 있음
    <ul>
      <li>named native query, result set mapping 둘 다 가능</li>
      <li><code class="language-plaintext highlighter-rouge">&lt;named-native-query/&gt;</code> 먼저 정의 후 <code class="language-plaintext highlighter-rouge">&lt;result-set-mapping/&gt;</code> 정의해야 함</li>
    </ul>
  </li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;entity-mappings</span> <span class="err">...</span><span class="nt">&gt;</span>
  <span class="nt">&lt;named-native-query</span> <span class="na">name=</span><span class="s">"Member.memberWithOrderCountXml"</span>
    <span class="na">result-set-mapping=</span><span class="s">"memberWithOrderCountResultMap"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;query&gt;&lt;CDATA</span><span class="err">[</span>
      <span class="err">SELECT</span> <span class="err">m.id,</span> <span class="err">age,</span> <span class="err">name,</span> <span class="err">team_id,</span> <span class="err">i.order_count</span>
      <span class="err">FROM</span> <span class="err">member</span> <span class="err">m</span>
        <span class="err">LEFT</span> <span class="err">JOIN</span> <span class="err">(</span>
          <span class="err">SELECT</span> <span class="err">im.id,</span> <span class="err">COUNT(*)</span> <span class="err">as</span> <span class="err">order_count</span>
          <span class="err">FROM</span> <span class="err">orders</span> <span class="err">o,</span> <span class="err">member</span> <span class="err">im</span>
          <span class="err">WHERE</span> <span class="na">o.member_id =</span> <span class="s">im.id</span>
        <span class="err">)</span> <span class="err">i</span>
        <span class="err">ON</span> <span class="na">m.id =</span> <span class="s">i.id</span>
    <span class="err">]</span><span class="nt">&gt;&lt;/query&gt;</span>
  <span class="nt">&lt;/named-native-query&gt;</span>

  <span class="nt">&lt;sql-result-set-mapping</span> <span class="na">name=</span><span class="s">"memberWithOrderCountResultMap"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;entity-result</span> <span class="na">entity-class=</span><span class="s">"jpabook.domain.Member"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;column-result</span> <span class="na">name=</span><span class="s">"order_count"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/sql-result-set-mapping&gt;</span>
<span class="nt">&lt;/entity-mappings&gt;</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h2 id="1054-네이티브-sql-정리">10.5.4 네이티브 SQL 정리</h2>
<ul>
  <li>네이티브 SQL도 JPQL과 마찬가지로 Query, TypedQuery(named native query 사용시에만)를 반환</li>
  <li>∴ 페이징 처리 API 등 JPQL API 그대로 사용 가능</li>
</ul>

<p><br />
<br /></p>

<h2 id="1055-스토어드-프로시저jpa-21">10.5.5 스토어드 프로시저(JPA 2.1)</h2>

<p><br /></p>

<h3 id="스토어드-프로시저-사용">스토어드 프로시저 사용</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">em.createStoredProcedureQuery()</code>메소드에 사용할 스토어드 프로시저 이름을 파라미터로 호출</li>
  <li><code class="language-plaintext highlighter-rouge">registerStoredProcedureParamter()</code> 메소드를 사용해서 프로시저에서 사용할 파라미터를 순서, 타입, 파라미터 모드 순으로 정의
    <ul>
      <li>파라미터 모드
        <ul>
          <li>IN: INPUT 파라미터</li>
          <li>INOUT: INPUT, OUTPUT 파라미터</li>
          <li>OUT: OUTPUT 파라미터</li>
          <li>REF_CURSOR: CURSOR 파라미터</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<pre><code class="language-SQL"># 첫 번째 파라미터로 값 입력받고 곱하기 2 해서 두 번째 파라미터로 결과 반환하는 프로시저 생성

DELIMITER //

CREATE PROCEDURE proc_multiply (INOUT inParam INT, INOUT outParam INT)
BEGIN
  SET outParam = inParam * 2;
END //
</code></pre>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// proc_multiply 프로시저 호출 (순서 기반 파라미터)</span>
<span class="nc">StoredProcedureQuery</span> <span class="n">spq</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createStoredProcedureQuery</span><span class="o">(</span><span class="s">"proc_multiply"</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">registerStoredProcedureParamter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ParamterMode</span><span class="o">.</span><span class="na">IN</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">registerStoredProcedureParamter</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ParamterMode</span><span class="o">.</span><span class="na">OUT</span><span class="o">);</span>

<span class="n">spq</span><span class="o">.</span><span class="na">setParamter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>

<span class="nc">Integer</span> <span class="n">out</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">spq</span><span class="o">.</span><span class="na">getOutputParamterValue</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"out = "</span> <span class="o">+</span> <span class="n">out</span><span class="o">);</span> <span class="c1">// out = 200</span>

<span class="o">...</span>

<span class="c1">// proc_multiply 프로시저 호출 (이름 기반 파라미터)</span>
<span class="nc">StoredProcedureQuery</span> <span class="n">spq</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createStoredProcedureQuery</span><span class="o">(</span><span class="s">"proc_multiply"</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">registerStoredProcedureParamter</span><span class="o">(</span><span class="s">"inParam"</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ParamterMode</span><span class="o">.</span><span class="na">IN</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">registerStoredProcedureParamter</span><span class="o">(</span><span class="s">"outParam"</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">ParamterMode</span><span class="o">.</span><span class="na">OUT</span><span class="o">);</span>

<span class="n">spq</span><span class="o">.</span><span class="na">setParamter</span><span class="o">(</span><span class="s">"inParam"</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>

<span class="nc">Integer</span> <span class="n">out</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">spq</span><span class="o">.</span><span class="na">getOutputParamterValue</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"out = "</span> <span class="o">+</span> <span class="n">out</span><span class="o">);</span> <span class="c1">// out = 200</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="named-스토어드-프로시저-사용">Named 스토어드 프로시저 사용</h3>
<ul>
  <li>스토어드 프로시저 쿼리에 이름 부여해서 사용하는 것</li>
  <li><code class="language-plaintext highlighter-rouge">@NamedStoredProcedureQuery</code>로 정의
    <ul>
      <li>name 속성으로 이름 부여</li>
      <li>procedureName 속성에 실제 호출할 프로시저 이름 설정</li>
      <li><code class="language-plaintext highlighter-rouge">@StoredProcedureParameter</code> 사용해서 파라미터 정보 정의</li>
    </ul>
  </li>
  <li>둘 이상 정의하려면 <code class="language-plaintext highlighter-rouge">@NamedStoredPRocedureQueries</code> 사용</li>
  <li>어노테이션 대신 xml 로도 정의할 수 있음</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// named stored procedure 정의</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedStoredProcedureQuery</span><span class="o">(</span>
  <span class="n">name</span> <span class="o">=</span> <span class="s">"multiply"</span><span class="o">,</span>
  <span class="n">procedureName</span> <span class="o">=</span> <span class="s">"proc_multiply"</span><span class="o">,</span>
  <span class="n">paramter</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@StoredProcedurePatameter</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"inParam"</span><span class="o">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="nc">ParameterMode</span><span class="o">.</span><span class="na">IN</span><span class="o">,</span> <span class="n">type</span> <span class="o">=</span> <span class="nc">Intger</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
    <span class="nd">@StoredProcedureParamter</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"outParam"</span><span class="o">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="nc">ParameterMode</span><span class="o">.</span><span class="na">OUT</span><span class="o">,</span> <span class="n">type</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// 정의한 named stored procedure 호출</span>
<span class="nc">StoredProcedureQuery</span> <span class="n">spq</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNamedStoredProcedureQuery</span><span class="o">(</span><span class="s">"multiply"</span><span class="o">);</span>

<span class="n">spq</span><span class="o">.</span><span class="na">setParamter</span><span class="o">(</span><span class="s">"inParam"</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
<span class="n">spq</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>

<span class="nc">Integer</span> <span class="n">out</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">spq</span><span class="o">.</span><span class="na">getOutputParamterValue</span><span class="o">(</span><span class="s">"outParam"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"out = "</span> <span class="o">+</span> <span class="n">out</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- xml에 named stored procedure 정의 --&gt;</span>

<span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;entity-mappings</span> <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/persistence/orm"</span> <span class="na">version=</span><span class="s">"2.1"</span><span class="nt">&gt;</span>
  
  <span class="nt">&lt;named-stored-procedure-query</span> <span class="na">name=</span><span class="s">"multiply"</span>
    <span class="na">procedure-name=</span><span class="s">"proc_multiply"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;paramter</span> <span class="na">name=</span><span class="s">"inParam"</span> <span class="na">mode=</span><span class="s">"IN"</span> <span class="na">class=</span><span class="s">"java.lang.Integer"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;paramter</span> <span class="na">name=</span><span class="s">"outParam"</span> <span class="na">mode=</span><span class="s">"OUT"</span> <span class="na">class=</span><span class="s">"java.lang.Integer"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/named-stored-procedure-query&gt;</span>
<span class="nt">&lt;/entity-mappings&gt;</span>
</code></pre></div></div>

<p><br />
<br />
<br /></p>

<h1 id="106-객체지향-쿼리-심화">10.6 객체지향 쿼리 심화</h1>

<p><br />
<br /></p>

<h2 id="1061-벌크-연산">10.6.1 벌크 연산</h2>
<ul>
  <li>여러 건을 한 번에 수정/삭제할 때 사용</li>
  <li><code class="language-plaintext highlighter-rouge">executeUpdate()</code> 메소드를 사용하며, return 값으로 벌크 연산에 영향 받은 엔티티 건수 반환</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// UPDATE 벌크 연산</span>
<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span>
  <span class="s">"UPDATE Product p "</span> <span class="o">+</span>
  <span class="s">"SET s.price = p.price * 1.1 "</span> <span class="o">+</span>
  <span class="s">"WHERE p.stockAmount &lt; :stockAmount"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">resultCounht</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParamter</span><span class="o">(</span><span class="s">"stockAmount"</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
  <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>

<span class="o">...</span>

<span class="c1">// DELETE 벌크 연산</span>
<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span>
  <span class="s">"DELETE from Product p "</span> <span class="o">+</span>
  <span class="s">"WHERE p.price &lt; :price"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
  <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>

<span class="c1">// INSERT 벌크 연산 (hibernate만 지원)</span>
<span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span>
  <span class="s">"INSERT into ProductTemp(id, name, price, stockAmount) "</span> <span class="o">+</span>
  <span class="s">"SELECT p.id, p.name, p.price, p.stockAmount FROM Product p "</span> <span class="o">+</span>
  <span class="s">"WHERE p.price &lt; :price"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
  <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
  <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="벌크-연산의-주의점">벌크 연산의 주의점</h3>
<ul>
  <li>벌크 연산시엔 영속성 컨텍스트 무시하고 바로 DB에 쿼리함</li>
  <li>∴ 영속성 컨텍스트에 있는 값과 DB 값 간의 차이 발생할 수 있으므로 주의</li>
  <li>이를 해결할 수 있는 방법은 다음과 같음
    <ul>
      <li><strong>em.refresh() 사용</strong>
        <ul>
          <li>벌크 연산 수행 직후 해당 연산 영향 받은 엔티티 사용해야 하면 <code class="language-plaintext highlighter-rouge">em.refresh()</code>호출해서 다시 조회</li>
        </ul>
      </li>
      <li><strong>벌크 연산 먼저 실행</strong>
        <ul>
          <li>벌크 연산부터 실행 후 나머지 진행하면 됨</li>
          <li>이 방법은 JPA, JDBC 같이 사용할 때도 유용함</li>
        </ul>
      </li>
      <li><strong>벌크 연산 수행 후 영속성 컨텍스트 초기화</strong>
        <ul>
          <li>벌크 연산 수행 직후 바로 영속성 컨텍스트 초기화 시켜서 남아있는 엔티티 제거하면 이후 사용할 때 다시 조회하기 때문에 차이 없앨 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1062-영속성-컨텍스트와-jpql">10.6.2 영속성 컨텍스트와 JPQL</h2>

<p><br /></p>

<h3 id="쿼리-후-영속-상태인-것과-아닌-것">쿼리 후 영속 상태인 것과 아닌 것</h3>
<ul>
  <li>JPQL로 엔티티 조회시
    <ul>
      <li>엔티티 =&gt; 영속성 컨텍스트에서 관리</li>
      <li>엔티티 X(임베디드 타입, 단순 필드 조회 등) =&gt; 영속성 컨텍스트에서 관리 안함</li>
      <li>∴ 엔티티 아닌거 조회하면 변경해도 수정 안됨</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="jpql로-조회한-엔티티와-영속성-컨텍스트">JPQL로 조회한 엔티티와 영속성 컨텍스트</h3>
<ul>
  <li>영속성 컨텍스트에 이미 존재하는 엔티티를 JPQL로 다시 조회하는 경우 =&gt; 조회 결과 버리고 영속성 컨텍스트에 있던 기존 엔티티를 반환
    <ol>
      <li>JPQL을 사용해서 조회 요청</li>
      <li>JPQL -&gt; SQL로 변환되어 DB 조회</li>
      <li>조회한 결과와 영속성 컨텍스트 비교(식별자 값을 기준으로 함)
        <ul>
          <li>이미 존재하는 엔티티인 경우 =&gt; 버리고 기존 엔티티를 반환</li>
          <li>없으면 =&gt; 영속성 컨텍스트에 추가하고 반환</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>기존 엔티티 대신 새로 조회한 엔티티로 대체하지 않는 이유
    <ul>
      <li>영속성 컨텍스트에서 수정 중인 데이터가 사라질 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="find-vs-jpql">find() vs JPQL</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">em.find</code> 메소드는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 DB 조회</li>
  <li>JPQL은 항상 DB에서 SQL 실행해서 결과를 조회
    <ul>
      <li>조회 후 영속성 컨텍스트랑 비교해서 영속 상태 유지되긴 함</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h2 id="1063-jpql과-플러시-모드">10.6.3 JPQL과 플러시 모드</h2>

<p><br /></p>

<h3 id="쿼리와-플러시-모드">쿼리와 플러시 모드</h3>
<ul>
  <li>영속성 컨텍스트에서 엔티티 수정 후 JPQL로 조회하는 경우 플러시 모드에 따라 의도치 않은 결과 얻을 수 있음
    <ul>
      <li><strong>플러시 모드 AUTO인 경우</strong>
        <ul>
          <li>JPQL 실행 직전에 영속성 컨텍스트가 플러시 돼서 수정된 결과를 조회 =&gt; 문제 없음</li>
        </ul>
      </li>
      <li><strong>플러시 모드 COMMIT인 경우</strong>
        <ul>
          <li>쿼리시에는 플러시 하지 않으므로 방금 수정한 데이터가 조회되지 않음 =&gt; 의도치 않은 결과</li>
          <li>∴ 직접 <code class="language-plaintext highlighter-rouge">em.flush()</code> 호출하거나 아래와 같이 Query 객체에 flush mode 설정해줘야 함
            <ul>
              <li><code class="language-plaintext highlighter-rouge">em.createQuery(...).setFlushMode(FlushModeType.AUTO).getSingleResult();</code></li>
              <li>이렇게 쿼리에 직접 설정하면 entity manager 에서 설정한 것보다 우선시 됨</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="플러시-모드와-최적화">플러시 모드와 최적화</h3>
<ul>
  <li>데이터 무결성 깨질 위험 감수하고 flush mode를 COMMIT 으로 쓰는 경우
    <ul>
      <li><strong>플러시가 너무 자주 일어나는 상황</strong>
        <ul>
          <li>매번 플러시 될 경우 성능 하락 생길 수 있음</li>
          <li>이런 경우에 쿼리시 발생하는 플러시 횟수를 줄여서 성능 최적화</li>
        </ul>
      </li>
      <li><strong>JPA 사용하지 않고 JDBC 직접 사용해서 SQL 실행하는 경우</strong>
        <ul>
          <li>JDBC로 쿼리 직접 실행 시 JPA는 JDBC가 실행한 쿼리 인식 못함</li>
          <li>∴ 별도의 JDBC 호출은 플러시 모드 AUTO 설정해도 플러시 안됨</li>
          <li>이런 경우엔 쿼리 실행 전 <code class="language-plaintext highlighter-rouge">em.flush()</code> 호출해서 동기화 하는게 안전</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

</article>



<section class="tags">
  <strong>Tags:</strong> <a href="/tag/jpa">jpa</a>,&nbsp;<a href="/tag/object-oriented">object-oriented</a>,&nbsp;<a href="/tag/query">query</a>,&nbsp;<a href="/tag/language">language</a>,&nbsp;<a href="/tag/jpql">jpql</a>,&nbsp;<a href="/tag/criteria">criteria</a>,&nbsp;<a href="/tag/querydsl">querydsl</a>,&nbsp;<a href="/tag/nativesql">nativesql</a>
</section>



<section class="rss">
  <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
</section>

<section class="share">
  <span>Share: </span>
  
    
    
      <a href="//twitter.com/share?text=%5B%EC%9E%90%EB%B0%94+ORM+%ED%91%9C%EC%A4%80+JPA+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%5D+10%EC%9E%A5.+%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5+%EC%BF%BC%EB%A6%AC+%EC%96%B8%EC%96%B4&url=https%3A%2F%2Fsungunjo.github.io%2Fjpa-study%2F2022%2F03%2F01%2Fch.10-object-oriented-query-language.html&via="
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
        <i class="fa fa-twitter-square fa-lg"></i>
      </a>
    
    
    
    
    
    
    
  
    
    
    
      <a href="//www.facebook.com/sharer.php?t=%5B%EC%9E%90%EB%B0%94+ORM+%ED%91%9C%EC%A4%80+JPA+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%5D+10%EC%9E%A5.+%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5+%EC%BF%BC%EB%A6%AC+%EC%96%B8%EC%96%B4&u=https%3A%2F%2Fsungunjo.github.io%2Fjpa-study%2F2022%2F03%2F01%2Fch.10-object-oriented-query-language.html"
        onclick="window.open(this.href, 'facebook-share', 'width=550,height=255');return false;">
        <i class="fa fa-facebook-square fa-lg"></i>
      </a>
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
      <a href="//www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fsungunjo.github.io%2Fjpa-study%2F2022%2F03%2F01%2Fch.10-object-oriented-query-language.html"
        onclick="window.open(this.href, 'linkedin-share', 'width=550,height=255');return false;">
        <i class="fa fa-linkedin-square fa-lg"></i>
      </a>
    
    
    
    
  
    
    
    
    
      <a href="//plus.google.com/share?title=%5B%EC%9E%90%EB%B0%94+ORM+%ED%91%9C%EC%A4%80+JPA+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%5D+10%EC%9E%A5.+%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5+%EC%BF%BC%EB%A6%AC+%EC%96%B8%EC%96%B4&url=https%3A%2F%2Fsungunjo.github.io%2Fjpa-study%2F2022%2F03%2F01%2Fch.10-object-oriented-query-language.html"
        onclick="window.open(this.href, 'google-plus-share', 'width=550,height=255');return false;">
        <i class="fa fa-google-plus-square fa-lg"></i>
      </a>
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
      <a href="//www.pinterest.com/pin/create/button/?description=%5B%EC%9E%90%EB%B0%94+ORM+%ED%91%9C%EC%A4%80+JPA+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%5D+10%EC%9E%A5.+%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5+%EC%BF%BC%EB%A6%AC+%EC%96%B8%EC%96%B4&url=https%3A%2F%2Fsungunjo.github.io%2Fjpa-study%2F2022%2F03%2F01%2Fch.10-object-oriented-query-language.html&media=https://sungunjo.github.io/assets/instacode.png"
        onclick="window.open(this.href, 'pinterest-share', 'width=550,height=255');return false;">
        <i class="fa fa-pinterest-square fa-lg"></i>
      </a>
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
      <a href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent('https://sungunjo.github.io/jpa-study/2022/03/01/ch.10-object-oriented-query-language.html') + '&title=[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어'; return false">
        <i class="fa fa-reddit-square fa-lg"></i>
      </a>
    
    
  
    
    
    
    
    
    
    
    
  
</section>




<section class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'sungunjo-github-io';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>



</div>
</div>

    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h3 class="footer-heading">Development Stash</h3>

    <div class="site-navigation">

      <p><strong>Site Map</strong></p>
      <ul class="pages">
				
	
	<li class="nav-link"><a href="/about/">About</a>
	

	

	

	
	<li class="nav-link"><a href="/posts/">Posts</a>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	


      </ul>
    </div>

    <div class="site-contact">

      <p><strong>Contact</strong></p>
      <ul class="social-media-list">
        <li>
          <a href="mailto:sungunjo.dev@gmail.com">
            <i class="fa fa-envelope-o"></i>
            <span class="username">sungunjo.dev@gmail.com</span>
          </a>
        </li>

        
          
        
          
        
          
          <li>
            <a href="https://github.com/sungunjo" title="Fork me on GitHub">
              <i class="fa fa-github"></i>
              <span class="username">sungunjo</span>
            </a>
          </li>
          
        
          
          <li>
            <a href="https://www.linkedin.com/in/sungunjo" title="Connect with me on LinkedIn">
              <i class="fa fa-linkedin"></i>
              <span class="username">SungUn Jo</span>
            </a>
          </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        

      </ul>
    </div>

    <div class="site-signature">
      <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
      <p class="text">개발 공부 블로그</p>
    </div>

  </div>

</footer>

<!-- Scripts -->
<script src="//code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.11.1/js/lightbox.min.js"></script>
<script src="//unpkg.com/popper.js@1"></script>
<script src="//unpkg.com/tippy.js@5"></script>

<script type="text/javascript">
$(document).ready(function() {
  // Default syntax highlighting
  hljs.initHighlightingOnLoad();

  // Header
  var menuToggle = $('#js-mobile-menu').unbind();
  $('#js-navigation-menu').removeClass("show");
  menuToggle.on('click', function(e) {
    e.preventDefault();
    $('#js-navigation-menu').slideToggle(function(){
      if($('#js-navigation-menu').is(':hidden')) {
        $('#js-navigation-menu').removeAttr('style');
      }
    });
  });

	// Enable tooltips via Tippy.js
	if (Array.isArray(window.tooltips)) {
		window.tooltips.forEach(function(tooltip) {
			var selector = tooltip[0];
			var config = tooltip[1];
			tippy(selector, config);
		})
	}
});

</script>




<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-156645046-1', 'auto');
  ga('send', 'pageview', {
    'page': '/jpa-study/2022/03/01/ch.10-object-oriented-query-language.html',
    'title': '[자바 ORM 표준 JPA 프로그래밍] 10장. 객체지향 쿼리 언어'
  });
</script>



  </body>

</html>
